<PRE><CODE>
;Small-c Compiler rev 1.1 re:NASM c0.2.7 Feb. 2009
	[MAP ALL NCCR1.MAP]
	SECTION .text vstart=0100h

;/************************************************/ 
;/** Module: NCCR1.C  By: s_dubrovich@yahoo.com  */ 
;/** Last: 15-Feb-09 11:22:07 AM                 */ 
;/** Prev: 02-Feb-09 08:06:03 AM                 */ 
;/** Vers: 0.2.7  Release 1.0                    */ 
;/** Note: edits, rename, Release Version.       */ 
;/************************************************/ 
;/** Module: TNR6CC.C  By: s_dubrovich@yahoo.com */ 
;/** Last: 02-Feb-09 08:06:03 AM                 */ 
;/** Vers: 0.2.6                                 */ 
;/************************************************/ 
;/** Module: N2CC.C  By: s_dubrovich@yahoo.com   */ 
;/** Last: 1:52 PM 1/18/2009                     */ 
;/** Vers: 0.2.4                                 */ 
;/** Change: names, add comments                **/ 
;/************************************************/ 
;/** Module: ECC.C  By: s_dubrovich@yahoo.com    */ 
;/** Last: 12:31 PM 9/04/2008                    */ 
;/** Vers: 0.2.2                                 */ 
;/** Change:                                    **/ 
;/** input => fp_in, input2 => fp_in2, output =>**/ 
;/** fp_out, eof => eof_flg, getarg =>          **/ 
;/** decl_autoarg, kill => kill_ln              **/ 
;/************************************************/ 
;/** Module: ECC.C  By: s_dubrovich@yahoo.com    */ 
;/** Last: 8:17 AM 8/31/2008                     */ 
;/** Init: 12:52 PM 8/29/2008 was DCC.C v.c0.1.5 */ 
;/** Vers: c0.2.1 New: re-edit, added comments,  */ 
;/**   changed labels to reflect C terminology.  */ 
;/**  symbols significant to 10 chrs.            */ 
;/**  sho_last();                                */ 
;/** Uses: C5LIB.C                               */ 
;/************************************************/ 
;/** Last: 4:23 PM 8/14/2008 DCC.C               */ 
;/** Vers: c0.1.5 New: inc macro pool 1664->2176 */ 
;/** Stat: compiles itself! Vers for .com by mod */ 
;/**  vstart=0100h, and commenting out section   */ 
;/**  .dseg to form small model CS=DS=SS, the    */ 
;/**  CMD.EXE dpmi server sets SP=FFF0h on load- */ 
;/**  ing a .COM file at segment:0100h and the   */ 
;/**  Program Segment Prefix is initialized with */ 
;/**  the legacy Location 0005h Vector for the   */ 
;/**  CP/M-80 API Emulation under dos fcb struct-*/ 
;/**  ures, also using the CP/M-80 ABI register  */ 
;/**  usage. see: http://www.patersontech.com/   */ 
;/**   dos/Docs/86_Dos_inst_.pdf                 */ 
;/**  also, added user input hints..             */ 
;/************************************************/ 
;/************************************************/ 
;/** SCNXa.C for LVL1 compile w/ POWERC          */ 
;/** SCNX.C for LVL2 compile w/ SCNXa.EXE        */ 
;/** Extern Files Req'd: IOC5.C for LVL2.        */ 
;/** POWERC compiles K&R with pcDos iolib which  */ 
;/** runs under win XP thru CMD.EXE, a DPMIv.9   */ 
;/** server, this is a LVL1 build.  LVL2 build   */ 
;/** binds a Call_5 legacy io-lib, which mimics  */ 
;/** CP/M-80 io functions under pcDos.  LVL2 is a*/ 
;/** 'stand-in' for your hobby io-lib.  It shows */ 
;/** the cross development step needed to boot-  */ 
;/** strap mimimalist small-c for your hobby OS. */ 
;/** Since this demonstrates small-c compiling   */ 
;/** itself, along with grafting a minimal custom*/ 
;/** io-lib, it shows how the migration path to a*/ 
;/** new hobby OS platform can be achieved with  */ 
;/** small-c initially.  The back-end assembler  */ 
;/** syntax chosen is for NASM, 16bit small model*/ 
;/** with an eye for 32bit multi-segmented, or   */ 
;/** 64 bit later on.                            */ 
;/************************************************/ 
;/************************************************/ 
;/** Re-Codified roughly as:                    **/ 
;/**     I.   Static Storage Defn, main()       **/ 
;/**     II.  Recursive Descent Parser          **/ 
;/**     III. Utility Functions                 **/ 
;/**     IV.  U.I. & I/O                        **/ 
;/**     V.   Backend, NASM Object Output       **/ 
;/************************************************/ 
;/************************************************/ 
;/*          small-c compiler                    */ 
;/*              rev. 1.1                        */ 
;/*            by Ron Cain                       */ 
;/*              (1980)                          */ 
;/************************************************/ 
; 
;#define eol 10	/** this is correct **/ 
;#define NULL 0 
; 
;/** move to the end --> #include C5LIB.C 	      */ 
;/** However, initfcb() still must be called	*/ 
;/**  before main(), so include stub function,	*/ 
;/**  just ahead of file io in main(). 		*/ 
;/************************************************/ 
;/** Appendix A                                 **/ 
;/**  4. C bases interp. of Identifier upon two **/ 
;/**     attributes: Storage Class and its Type.**/ 
;/** Storage Class determines Location, Lifetime**/ 
;/** Type determines the meaning of the values  **/ 
;/**  found in the identifier's storage.        **/ 
;/** Storage Classes[4]={auto,static,extern,reg}**/ 
;/** Type[Object]={char,int[3],float,double}    **/ 
;/**  Type[derived]={array,functions,pointer,   **/ 
;/**                 structures,unions}         **/ 
;/**  5. Objects and lvalues - An Object is a   **/ 
;/** manipulatable region of storage, an lvalue **/ 
;/** is an expression refering to an object.    **/ 
;/************************************************/ 
;/** NOTE: the preprocessor macro does text sub-**/ 
;/** stitution only, so macro expressions are   **/ 
;/** evaluated at runtime.  It is more efficient**/ 
;/** to evaluate macro expressions by hand than **/ 
;/** otherwise having 'runtime' code generated  **/ 
;/** to evaluate the macro expression.          **/ 
;/************************************************/ 
; 
;/**--------------------------------------------**/ 
;/** Appendix A pg 179, Lexical Conventions.    **/ 
;/**  six classes of tokens.                    **/ 
;/** 1. indentifiers                            **/ 
;/** 2. keywords                                **/ 
;/** 3. constants                               **/ 
;/** 4. strings                                 **/ 
;/** 5. operators                               **/ 
;/** 6. other separators {blanks, tabs, newlines,*/ 
;/**    and comments, i.e. whitespace.          **/ 
;/**--------------------------------------------**/ 
; 
;/**--------------------------------------------**/ 
;/** 7.1 -Primary Expressions-                  **/ 
;/** An Identifier is a Primary Expression,     **/ 
;/**  provided it has been suitably declared.   **/ 
;/**--------------------------------------------**/ 
;/** 3.1  -Statements and Blocks-               **/ 
;/** An Expression becomes a Statement when it  **/ 
;/** is followed by a semicolon.  In C the      **/ 
;/** semicolon is a statement terminator.       **/ 
;/**--------------------------------------------**/ 
;/**  Define the symbol table parameters        **/ 
;/**  #define symsiz  38  */       /** 38 bytes **/ 
;/**  symbol table overflows with 38            **/ 
;/**--------------------------------------------**/ 
;#define symsiz 16 /* incr sz by 2 for name */ 
;#define symtbsz   5760 /** 360x16 **/ 
;#define numstatics 300 
;#define numautos    60 /* new def */ 
;#define startstatic symtab 
;#define endstatic startstatic+numstatics*symsiz 
;                  /** which is 4200 **/ 
;#define startauto endstatic+symsiz 
;                  /** which is 4214 **/ 
;#define endauto   symtab+symtbsz-symsiz 
;                  /** which is net 812 **/ 
;/**  812 div by symsiz = 58 autos              **/ 
;/**--------------------------------------------**/ 
;/*  Define symbol table entry format,          **/ 
;/** modify if longer symbol name.              **/ 
;#define name    0   /** length 11 {0..10}      **/ 
;#define ob_cl   11  /** len 1 (indirection ndx)**/ 
;#define type    12  /** length 1               **/ 
;#define stor_cl 13  /** length 1               **/ 
;#define offset  14  /** length 2 {14..15}      **/ 
;/** ++ scope?. attributes`lvalue`rvalue.       **/ 
;/*	System wide name size (for symbols)	      */ 
;#define namesize 11 /** namemax plus terminator */ 
;#define namemax  10 /** symbol len max, clipped */ 
; 
;/**--------------------------------------------**/ 
;/**--- TBI => To Be Implemented. --------------**/ 
;/**--------------------------------------------**/ 
;/** Define possible entries for "ob_cl"ass     **/ 
;/** 14. -Types Revisted-                       **/ 
; 
;#define ob_const 0 /** 15. Constant Expression **/ 
;#define ob_var   1 
;#define ob_array 2 /** 14.3 **/ 
;#define ob_ptr   3 /** 14.3 **/ 
;#define ob_fn    4 /** 14.2 **/ 
;#define ob_struc 5 /** 14.1 TBI **/ 
;#define ob_union 6 /** 14.1 TBI **/ 
; 
;/**  Define possible entries for storage "type" specifiers */ 
;#define cchar      1 /** 8 bits **/ 
;#define cint       2 /** 16 bits **/ 
;#define cdouble    3 /**  new, TBI **/ 
;#define cfloat     4 /**  new, TBI **/ 
;#define ts_struct  5 /**  new, TBI **/ 
;#define ts_union   6 /**  new, TBI **/ 
;#define ts_typedef 7 /**  new, TBI **/ 
; 
;/**  Define possible entries for "type adjective" 8.2 **/ 
;#define ta_unsigned 1 /**  new, TBI **/ 
;#define ta_short    2 /**  new, TBI **/ 
;#define ta_long     3 /**  new, TBI **/ 
; 
;/**  Define possible entries for "storage class" */ 
;/** Storage Class-                              **/ 
;#define sc_fn       0 /** new **/ 
;#define sc_static   1 
;#define sc_auto     2 
;#define sc_extern   3 /** new, meant for common block, TBI **/ 
;#define sc_register 4 /** new, TBI **/ 
;/** 8.1 typedef as sc-specifier for syntatic convenience **/ 
;#define sc_typedef  5 /** new, TBI **/ 
; 
;/**--------------------------------------------**/ 
;/*	Define the "while" statement queue	*/ 
;#define wqtabsz 100 /** {0..24} entries    **/ 
;#define wqsiz 4   /** ea. entry size, 4 bytes**/ 
;#define wqmax wq+wqtabsz-wqsiz /**lim offs 96**/ 
; 
;/*	Define entry offsets in while queue	*/ 
;/** Entry of byte elements of indexes:         **/ 
;#define wqsym  0 
;#define wqsp   1 
;#define wqloop 2 
;#define wqlab  3 
; 
;/**--------------------------------------------**/ 
;/*	Define the literal pool			*/ 
;/*#define	litabsz	2000			*/ 
;/** 2000 limit reached on self compile [1]      */ 
;#define litabsz 4000   
;#define litmax  litabsz-1 
; 
;/**--------------------------------------------**/ 
;/*	Define the input line			*/ 
;#define linesize 80 
;#define linemax linesize-1 
;#define mpmax   linemax 
; 
;/**--------------------------------------------**/ 
;/*	Define the macro (define) pool		*/ 
;#define macqsize 2176 /** was 1664 **/ 
;#define macmax macqsize-1 
; 
;/**--------------------------------------------**/ 
;/*	Define statement types (tokens)		*/ 
;#define stif     1 
;#define stwhile  2 
;#define streturn 3 
;#define stbreak  4 
;#define stcont   5 
;#define stasm    6 
;#define stexp    7 
; 
; 
;/* Now reserve some storage words */ 
;char  symtab[symtbsz];    /* symbol table */ 
;char  *staticptr,*autoptr; /* ptrs to next entries */ 
;int   wq[wqtabsz];        /* while queue */ 
;int   *wqptr;             /* ptr to next entry */ 
; 
;char  litq[litabsz]; /* literal pool */ 
;int   litptr;        /* ptr to next entry */ 
; 
;char  macq[macqsize]; /* macro string buffer */ 
;int   macptr;         /* and its index */ 
; 
;/** char  fnamebuf[16];   * fout name store **/ 
;char  line[linesize];  /* parsing buffer */ 
;char  mline[linesize]; /* temp macro buffer */ 
;int   lptr,mptr;       /* ptrs into each */ 
; 
;/*  Misc storage  */ 
;int   nxtlab,     /* next avail label # */ 
;      litlab,     /* label # assigned to literal pool */ 
;      c_sp,       /* compiler relative stk ptr */ 
;      argstk,     /* function arg c_sp */ 
;      ncmp,       /* # open compound statements */ 
;      errcnt,     /* # errors in compilation */ 
;      eof_flg,    /* set non-zero on final input eof */ 
;      fp_in,      /* iob # for input file */ 
;      fp_out,     /* iob # for output file (if any) */ 
;      fp_in2,     /* iob # for "include" file */ 
;      staticflag, /* non-zero if internal globals */ 
;      ctext,      /* non-zero to intermix c-source */ 
;      cmode,      /* non-zero while parsing c-code */ 
;             /** .else. zero when passing assembly code */ 
;      lastst;     /* last executed statement type */ 
; 
;char  quote[2];   /* literal string for '"' */ 
;char  *cptr;      /* work ptr to any char buffer */ 
;int   *iptr;      /* work ptr to any int buffer */ 
; 
;/************************************************/ 
;/** Module: SCCN1.C                            **/ 
;/** Last: 20 JUL 2007  Init: 14 JUL 2007       **/ 
;/** Vers: 0.0.2b  Goal: Self Compile, Nasm out **/ 
;/** Modified for NASM by s_dubrovich@yahoo.com **/ 
;/************************************************/ 
;/** modified dumpstatics, dumplits             **/ 
; 
;/*	>>>>> start cc1 <<<<<<		*/ 
;/*					*/ 
;/*	Compiler begins execution here	*/ 
;/*					*/ 
;main() 
main:
;{ 
;	staticptr=startstatic; /* clear global symbols */ 
	MOV  AX,symtab
	MOV  [staticptr],AX
;	autoptr=startauto;     /* clear local symbols */ 
	MOV  AX,symtab
	PUSH AX
	MOV  AX,300
	PUSH AX
	MOV  AX,16
	POP  BX
	MUL  BX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,16
	POP  BX
	ADD  AX,BX
	MOV  [autoptr],AX
;	wqptr=wq;         /* clear while queue */ 
	MOV  AX,wq
	MOV  [wqptr],AX
;	macptr=           /* clear the macro pool */ 
;	litptr=           /* clear literal pool */ 
;  	c_sp =            /* stack ptr (relative) */ 
;	errcnt=           /* no errors */ 
;	eof_flg=          /* not eof yet */ 
;	fp_in=            /* no input file */ 
;	fp_in2=           /* or include file */ 
;	fp_out=           /* no open units */ 
;	ncmp=             /* no open compound states */ 
;	lastst=           /* no last statement yet */ 
;	quote[1]= 
	MOV  AX,quote
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	PUSH AX
;	0;                /*  ...all set to zero.... */ 
	MOV  AX,0
	POP  BP
	MOV  [BP],AL
	MOV  [lastst],AX
	MOV  [ncmp],AX
	MOV  [fp_out],AX
	MOV  [fp_in2],AX
	MOV  [fp_in],AX
	MOV  [eof_flg],AX
	MOV  [errcnt],AX
	MOV  [c_sp],AX
	MOV  [litptr],AX
	MOV  [macptr],AX
;	quote[0]='"';     /* fake a quote literal */ 
	MOV  AX,quote
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,34
	POP  BP
	MOV  [BP],AL
;	cmode=1;          /* enable preprocessing */ 
	MOV  AX,1
	MOV  [cmode],AX
;/***--------------------------------------------*/ 
;/*** IO Init code before file use, in C5LIB.C ***/ 
;	initfcb();  
	CALL initfcb
;/***--------------------------------------------*/ 
;/*                      */ 
;/*	compiler body     */ 
;/*                      */ 
;	ask();     /* get user options */ 
	CALL ask
;	openout(); /* get an output file */ 
	CALL openout
;	openin();  /* and initial input file */ 
	CALL openin
;	header();  /* intro code */ 
	CALL header
;	preprocess(); /* process ALL input */ 
	CALL preprocess
;                  /** added back in **/ 
;	dumplits(); /* then dump literal pool */ 
	CALL dumplits
;/** dump global static defs. to output source, req'd **/ 
;	dumpstatics(); /* and all static memory  */ 
	CALL dumpstatic
;                  /** original place, added back in **/ 
;	errorsummary(); /* summarize errors */ 
	CALL errorsumma
;	trailer();  /* follow-up code */ 
	CALL trailer
;	closeout(); /* close the output (if any) */ 
	CALL closeout
;	exit(); /*** sjd 25-JUL-2008 ***/ 
	CALL exit
;} 
	RET
;/************************************************/ 
;/** Re-Codified roughly as:                    **/ 
;/**     I.   Static Storage Defn, main()       **/ 
;/**     II.  Recursive Descent Parser          **/ 
;/**     III. Utility Functions                 **/ 
;/**     IV.  U.I. & I/O                        **/ 
;/**     V.   Backend, NASM Object Output       **/ 
;/************************************************/ 
;/************************************************/ 
;/*          small-c compiler                    */ 
;/*              rev. 1.1                        */ 
;/*            by Ron Cain                       */ 
;/*              (1980)                          */ 
;/************************************************/ 
;/** Fn's in this file                          **/ 
;/** preprocess(); 	** process ALL input    */ 
;/** declstatic, newfunc, addmac,  doasm        **/ 
;/** declauto(), put in here                    **/ 
;/** doinclude(), is in SCN_IV                  **/ 
;/************************************************/ 
;/************************************************/ 
;/*      Process all input text                  */ 
;/*                                              */ 
;/*   At this level, only static declarations,   */ 
;/*      defines, includes, and function         */ 
;/*      definitions are legal...                */ 
;/************************************************/ 
; 
;preprocess() 
preprocess:
;{ 
;	while (eof_flg==0)  /* do until no more input */ 
cc2:
	MOV  AX,[eof_flg]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc3
;		{ 
;		if (amatch("char",4)) 
	MOV  AX,cc1+0
	PUSH AX
	MOV  AX,4
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc4
;			{ 
;			declstatic(cchar); 
	MOV  AX,1
	PUSH AX
	CALL declstatic
	ADD  SP,2
;			ns(); 
	CALL ns
;			} 
;		else if (amatch("int",3)) 
	JMP  cc5
cc4:
	MOV  AX,cc1+5
	PUSH AX
	MOV  AX,3
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc6
;			{ 
;			declstatic(cint); 
	MOV  AX,2
	PUSH AX
	CALL declstatic
	ADD  SP,2
;			ns(); 
	CALL ns
;			} 
;		else if (match("#asm")) doasm(); 
	JMP  cc7
cc6:
	MOV  AX,cc1+9
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc8
	CALL doasm
;		else if (match("#include")) doinclude(); 
	JMP  cc9
cc8:
	MOV  AX,cc1+14
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc10
	CALL doinclude
;		else if (match("#define")) addmac(); 
	JMP  cc11
cc10:
	MOV  AX,cc1+23
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc12
	CALL addmac
;		else newfunc(); 
	JMP  cc13
cc12:
	CALL newfunc
cc13:
cc11:
cc9:
cc7:
cc5:
;		blanks();  /* force eof if pending */ 
	CALL blanks
;		} 
	JMP  cc2
cc3:
;} 
	RET
; 
;/************************************************/ 
;/*      Declare a static variable               */ 
;/*        (i.e. define for use)                 */ 
;/*                                              */ 
;/*  makes an entry in the symbol table so       */ 
;/* subsequent references can call symbol by name*/ 
;/************************************************/ 
; 
;declstatic(typ) int typ; /* typ is cchar or cint */ 
declstatic:
; 
;{ 
;	int k,id_typ; char sname[namesize]; 
	PUSH 0
	PUSH 0
	ADD  SP,-11
; 
;	while (1) 
cc14:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc15
;		{ 
;		while (1) 
cc16:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc17
;			{ 
;			if (endst()) return;  /* do line */ 
	CALL endst
	CMP  AX,0
	JNE  $+5
	JMP  cc18
	ADD  SP,15
	RET
;			k = 1;       /* assume 1 element */ 
cc18:
	MOV  AX,13
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	POP  BP
	MOV  [BP],AX
;			if (match("*"))	/* pointer ? */ 
	MOV  AX,cc1+31
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc19
;				id_typ = ob_ptr; /* yes */ 
	MOV  AX,11
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	POP  BP
	MOV  [BP],AX
;			else id_typ = ob_var;  /* no */ 
	JMP  cc20
cc19:
	MOV  AX,11
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	POP  BP
	MOV  [BP],AX
cc20:
;			if (symbform(sname)==0) /* name ok? */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL symbform
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc21
;				illname();     /* no... */ 
	CALL illname
;			if (findstatic(sname))  /* already there? */ 
cc21:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL findstatic
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc22
;				multidef(sname); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL multidef
	ADD  SP,2
;			if (match("["))        /* array? */ 
cc22:
	MOV  AX,cc1+33
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc23
;				{ 
;				k = needsub();  /* get size */ 
	MOV  AX,13
	ADD  AX,SP
	PUSH AX
	CALL needsub
	POP  BP
	MOV  [BP],AX
;				if (k) id_typ = ob_array;  /* !0=ob_array */ 
	MOV  AX,13
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc24
	MOV  AX,11
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	POP  BP
	MOV  [BP],AX
;				else id_typ = ob_ptr;  /* 0=ptr */ 
	JMP  cc25
cc24:
	MOV  AX,11
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	POP  BP
	MOV  [BP],AX
cc25:
;				} 
;			addstatic(sname,id_typ,typ,k);  /* add symbol */ 
cc23:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,13
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,21
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,19
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL addstatic
	ADD  SP,8
;			break; 
	JMP  cc17
;			} 
	JMP  cc16
cc17:
;		if (match(",")==0) return;  /* more? */ 
	MOV  AX,cc1+35
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc26
	ADD  SP,15
	RET
;		} 
cc26:
	JMP  cc14
cc15:
;} 
	ADD  SP,15
	RET
; 
; 
;/************************************************/ 
;/*      Declare local variables                 */ 
;/*      (i.e. define for use)                   */ 
;/*                                              */ 
;/*  works just like "declstatic" but modifies   */ 
;/*   machine stack and adds symbol table entry  */ 
;/*   with appropriate stack offset to find it   */ 
;/*   again.                                     */ 
;/************************************************/ 
;/** modifying machine stack creates Syntatic Action **/ 
; 
;declauto(typ) int typ; /* typ is cchar or cint */ 
declauto:
;{ 
;	int k,id_typ; char sname[namesize]; 
	PUSH 0
	PUSH 0
	ADD  SP,-11
; 
;	while (1) 
cc27:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc28
;		{ /** declare comma'd identifier list **/ 
;		while (1) 
cc29:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc30
;			{ /** declare identifier **/ 
;			if (endst()) return; 
	CALL endst
	CMP  AX,0
	JNE  $+5
	JMP  cc31
	ADD  SP,15
	RET
;			if (match("*")) 
cc31:
	MOV  AX,cc1+37
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc32
;				id_typ = ob_ptr; 
	MOV  AX,11
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	POP  BP
	MOV  [BP],AX
;			else id_typ = ob_var; 
	JMP  cc33
cc32:
	MOV  AX,11
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	POP  BP
	MOV  [BP],AX
cc33:
;			if (symbform(sname)==0) 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL symbform
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc34
;				illname(); 
	CALL illname
;			if(findauto(sname)) 
cc34:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL findauto
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc35
;				multidef(sname); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL multidef
	ADD  SP,2
;			if (match("[")) 
cc35:
	MOV  AX,cc1+39
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc36
;				{ 
;				k = needsub(); 
	MOV  AX,13
	ADD  AX,SP
	PUSH AX
	CALL needsub
	POP  BP
	MOV  [BP],AX
;				if (k) 
	MOV  AX,13
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc37
;					{ 
;					id_typ = ob_array; 
	MOV  AX,11
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	POP  BP
	MOV  [BP],AX
;					if (typ==cint) k = k + k; 
	MOV  AX,17
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc38
	MOV  AX,13
	ADD  AX,SP
	PUSH AX
	MOV  AX,15
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,17
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;					} 
cc38:
;				else	{ 
	JMP  cc39
cc37:
;					id_typ = ob_ptr; 
	MOV  AX,11
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	POP  BP
	MOV  [BP],AX
;					k = 2; 
	MOV  AX,13
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	POP  BP
	MOV  [BP],AX
;					} 
cc39:
;				} 
;			else 
	JMP  cc40
cc36:
;				if ((typ==cchar) 
	MOV  AX,17
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
;					&(id_typ != ob_ptr)) 
	PUSH AX
	MOV  AX,13
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc41
;					k = 1; 
	MOV  AX,13
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	POP  BP
	MOV  [BP],AX
;				else k = 2; 
	JMP  cc42
cc41:
	MOV  AX,13
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	POP  BP
	MOV  [BP],AX
cc42:
cc40:
; 
;		/* change machine stack */ 
;			c_sp = sa_modstk(c_sp - k); 
	MOV  AX,[c_sp]
	PUSH AX
	MOV  AX,15
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	PUSH AX
	CALL sa_modstk
	ADD  SP,2
	MOV  [c_sp],AX
;			addauto(sname,id_typ,typ,c_sp); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,13
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,21
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,[c_sp]
	PUSH AX
	CALL addauto
	ADD  SP,8
;			break; 
	JMP  cc30
;			} 
	JMP  cc29
cc30:
;		if (match(",")==0) return; 
	MOV  AX,cc1+41
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc43
	ADD  SP,15
	RET
;		/** .else. loop list **/ 
;		} 
cc43:
	JMP  cc27
cc28:
;} 
	ADD  SP,15
	RET
; 
;/************************************************/ 
;/**--------------------------------------------**/ 
;/** matches "#define"                          **/ 
;  
;addmac() 
addmac:
;{ 
;	char sname[namesize]; int k; 
	ADD  SP,-11
	PUSH 0
; 
;	if (symbform(sname)==0) 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	CALL symbform
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc44
;		{ 
;		illname(); 
	CALL illname
;		kill_ln(); 
	CALL kill_ln
;		return; 
	ADD  SP,13
	RET
;		} 
;	k = 0; 
cc44:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;	while (putmac(sname[k++])); 
cc45:
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL putmac
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc46
	JMP  cc45
cc46:
;	while (chr()==' ' | chr()==9) gchr(); 
cc47:
	CALL chr
	PUSH AX
	MOV  AX,32
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	CALL chr
	PUSH AX
	MOV  AX,9
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc48
	CALL gchr
	JMP  cc47
cc48:
;	while (putmac(gchr())); 
cc49:
	CALL gchr
	PUSH AX
	CALL putmac
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc50
	JMP  cc49
cc50:
;	if (macptr >= macmax) error("macro table full"); 
	MOV  AX,[macptr]
	PUSH AX
	MOV  AX,2176
	PUSH AX
	MOV  AX,1
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc51
	MOV  AX,cc1+43
	PUSH AX
	CALL error
	ADD  SP,2
;} 
cc51:
	ADD  SP,13
	RET
; 
;/**--------------------------------------------**/ 
;putmac(c) char c; 
putmac:
;{ 
;	macq[macptr]=c; 
	MOV  AX,macq
	PUSH AX
	MOV  AX,[macptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;	if (macptr<macmax) macptr++; 
	MOV  AX,[macptr]
	PUSH AX
	MOV  AX,2176
	PUSH AX
	MOV  AX,1
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc52
	MOV  AX,[macptr]
	INC  AX
	MOV  [macptr],AX
	DEC  AX
;	return c; 
cc52:
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	RET
;} 
; 
;/**--------------------------------------------**/ 
;findmac(sname) char *sname; 
findmac:
;{ 
;	int k; 
	PUSH 0
; 
;	k = 0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;	while (k < macptr) 
cc53:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,[macptr]
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc54
;		{ 
;		if (astreq(sname,macq+k,namemax)) 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,macq
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,10
	PUSH AX
	CALL astreq
	ADD  SP,6
	CMP  AX,0
	JNE  $+5
	JMP  cc55
;			{ 
;			while (macq[k++]); 
cc56:
	MOV  AX,macq
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc57
	JMP  cc56
cc57:
;			return k; 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,2
	RET
;			} 
;		while (macq[k++]); 
cc55:
cc58:
	MOV  AX,macq
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc59
	JMP  cc58
cc59:
;		while (macq[k++]); 
cc60:
	MOV  AX,macq
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc61
	JMP  cc60
cc61:
;		} 
	JMP  cc53
cc54:
;	return 0; 
	MOV  AX,0
	ADD  SP,2
	RET
;} 
;/**--------------------------------------------**/ 
; 
;/************************************************/ 
;/*      Get required array size                 */ 
;/*                                              */ 
;/* invoked when declared variable is followed   */ 
;/*  by "[" this routine makes subscript the     */ 
;/*  absolute size of the array.                 */ 
;/************************************************/ 
; 
;needsub() 
needsub:
;{ 
;	int num[1]; 
	PUSH 0
; 
;	if (match("]")) return 0; /* null size */ 
	MOV  AX,cc1+60
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc62
	MOV  AX,0
	ADD  SP,2
	RET
;	if (number(num) == 0)     /* go after a number */ 
cc62:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL number
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc63
;		{               /* it isn't */ 
;		error("must be constant"); 
	MOV  AX,cc1+62
	PUSH AX
	CALL error
	ADD  SP,2
;		num[0] = 1;  /* so force one */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,1
	POP  BP
	MOV  [BP],AX
;		} 
;	if (num[0] < 0) 
cc63:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc64
;		{ 
;		error("negative size illegal"); 
	MOV  AX,cc1+79
	PUSH AX
	CALL error
	ADD  SP,2
;		num[0] = (-num[0]); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	NEG  AX
	POP  BP
	MOV  [BP],AX
;		} 
;	needbrack("]");  /* force single dimension */ 
cc64:
	MOV  AX,cc1+101
	PUSH AX
	CALL needbrack
	ADD  SP,2
;	return num[0];   /* and return size */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,2
	RET
;} 
; 
; 
;/************************************************/ 
;/*      Begin a function                        */ 
;/*                                              */ 
;/* Called from "preprocess" this routine tries  */ 
;/*  to make a function out of what follows.     */ 
;/************************************************/ 
; 
;newfunc() 
newfunc:
;{ 
;	char n[namesize],*ptr; 
	ADD  SP,-11
	PUSH 0
; 
;	if (symbform(n) == 0) 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	CALL symbform
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc65
;		{ 
;		error("illegal function or declaration"); 
	MOV  AX,cc1+103
	PUSH AX
	CALL error
	ADD  SP,2
;		kill_ln();	/* invalidate line */ 
	CALL kill_ln
;		return; 
	ADD  SP,13
	RET
;		} 
;	if (ptr = findstatic(n)) /* already in symbol table ? */ 
cc65:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	CALL findstatic
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc66
;		{              /** yes, in static symbol table **/ 
;		if (ptr[ob_cl] != ob_fn)  multidef(n); 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,4
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc67
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	CALL multidef
	ADD  SP,2
;			/* already variable by that name */ 
;		else if (ptr[offset] == ob_fn)  multidef(n); 
	JMP  cc68
cc67:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,14
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,4
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc69
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	CALL multidef
	ADD  SP,2
;			/* already function by that name */ 
;		else ptr[offset] = ob_fn; /** flag it as new fn **/ 
	JMP  cc70
cc69:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,14
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,4
	POP  BP
	MOV  [BP],AL
cc70:
cc68:
;			/* otherwise we have what was earlier      */ 
;			/*  assumed to be a function .             */ 
;		} /** otherwise, lexeme is not in static symb tbl*/ 
; 
;	/* if not in table, define as a function now */ 
; 
;	else addstatic(n,ob_fn,cint,ob_fn); /** ob_fn == 4 **/ 
	JMP  cc71
cc66:
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,4
	PUSH AX
	MOV  AX,2
	PUSH AX
	MOV  AX,4
	PUSH AX
	CALL addstatic
	ADD  SP,8
cc71:
; 
;	/* we had better see open paren for args... */ 
; 
;	if (match("(") == 0) error("missing open paren"); 
	MOV  AX,cc1+135
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc72
	MOV  AX,cc1+137
	PUSH AX
	CALL error
	ADD  SP,2
; 
;          /*** .else. cont. syntatic action with Label: ***/ 
;	outstr(n); colon(); nl(); /* print function name */ 
cc72:
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	CALL outstr
	ADD  SP,2
	CALL colon
	CALL nl
; 
;	argstk = 0;		/* init arg count */ 
	MOV  AX,0
	MOV  [argstk],AX
;	while (match(")") == 0) /* then count args */ 
cc73:
	MOV  AX,cc1+156
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc74
;		/* any legal name bumps arg count */ 
;		{ 
;		if (symbform(n)) argstk = argstk + 2; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	CALL symbform
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc75
	MOV  AX,[argstk]
	PUSH AX
	MOV  AX,2
	POP  BX
	ADD  AX,BX
	MOV  [argstk],AX
;		else	{ 
	JMP  cc76
cc75:
;			error("illegal argument name"); 
	MOV  AX,cc1+158
	PUSH AX
	CALL error
	ADD  SP,2
;			junk(); 
	CALL junk
;			} 
cc76:
;		blanks(); 
	CALL blanks
;		/* if not closing paren, should be comma */ 
;		if (streq(line+lptr,")") == 0) 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+180
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc77
;			{ 
;			if (match(",") == 0) 
	MOV  AX,cc1+182
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc78
;			error("expected comma"); 
	MOV  AX,cc1+184
	PUSH AX
	CALL error
	ADD  SP,2
;			} 
cc78:
;		if (endst()) break; 
cc77:
	CALL endst
	CMP  AX,0
	JNE  $+5
	JMP  cc79
	JMP  cc74
;		} /** end of argument list loop **/ 
cc79:
	JMP  cc73
cc74:
; 
;	autoptr = startauto;  /* "clear" local symbol table */ 
	MOV  AX,symtab
	PUSH AX
	MOV  AX,300
	PUSH AX
	MOV  AX,16
	POP  BX
	MUL  BX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,16
	POP  BX
	ADD  AX,BX
	MOV  [autoptr],AX
;	c_sp = 0;             /* preset stack ptr */ 
	MOV  AX,0
	MOV  [c_sp],AX
;	while (argstk) 
cc80:
	MOV  AX,[argstk]
	CMP  AX,0
	JNE  $+5
	JMP  cc81
;		/* now let user declare what types of things */ 
;		/*	those arguments were */ 
;		{ 
;		if (amatch("char",4)) 
	MOV  AX,cc1+199
	PUSH AX
	MOV  AX,4
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc82
;			{ 
;			decl_autoarg(cchar); 
	MOV  AX,1
	PUSH AX
	CALL decl_autoa
	ADD  SP,2
;			ns(); 
	CALL ns
;			} 
;		else if (amatch("int",3)) 
	JMP  cc83
cc82:
	MOV  AX,cc1+204
	PUSH AX
	MOV  AX,3
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc84
;			{ 
;			decl_autoarg(cint); 
	MOV  AX,2
	PUSH AX
	CALL decl_autoa
	ADD  SP,2
;			ns(); 
	CALL ns
;			} 
;		else	{ 
	JMP  cc85
cc84:
;			error("wrong number args"); 
	MOV  AX,cc1+208
	PUSH AX
	CALL error
	ADD  SP,2
;			break; 
	JMP  cc81
;			} 
cc85:
cc83:
;		} 
	JMP  cc80
cc81:
; 
;	if (statement() != streturn) /* do a statement, but if */ 
	CALL statement
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc86
;                /* it's a return, skip cleaning up the stack */ 
;		{ 
;		sa_modstk(0); 
	MOV  AX,0
	PUSH AX
	CALL sa_modstk
	ADD  SP,2
;		sa_ret(); 
	CALL sa_ret
;		} 
;	c_sp = 0;            /* reset stack ptr again */ 
cc86:
	MOV  AX,0
	MOV  [c_sp],AX
;	autoptr = startauto; /* deallocate all autos */ 
	MOV  AX,symtab
	PUSH AX
	MOV  AX,300
	PUSH AX
	MOV  AX,16
	POP  BX
	MUL  BX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,16
	POP  BX
	ADD  AX,BX
	MOV  [autoptr],AX
;} /** end of parsing a function formulation **/ 
	ADD  SP,13
	RET
; 
;/************************************************/ 
;/*      Declare argument types                  */ 
;/*                                              */ 
;/* called from "newfunc" this routine adds an   */ 
;/* entry in the local (auto) symbol table for   */ 
;/* each named argument.                         */ 
;/************************************************/ 
; 
;decl_autoarg(t) int t;  /* t = cchar or cint */ 
decl_autoa:
;{ 
;	char n[namesize],c; int j; 
	ADD  SP,-11
	DEC  SP
	PUSH 0
; 
;	while (1) 
cc87:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc88
;		{ 
;		if (argstk == 0) return; /* no more args */ 
	MOV  AX,[argstk]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc89
	ADD  SP,14
	RET
;		if (match("*")) j = ob_ptr; 
cc89:
	MOV  AX,cc1+226
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc90
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	POP  BP
	MOV  [BP],AX
;		else j = ob_var; /** ptr or var, not fn **/ 
	JMP  cc91
cc90:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	POP  BP
	MOV  [BP],AX
cc91:
; 
;		if (symbform(n) == 0) illname(); 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	CALL symbform
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc92
	CALL illname
;		if (findauto(n))  multidef(n); 
cc92:
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	CALL findauto
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc93
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	CALL multidef
	ADD  SP,2
; 
;		if (match("["))	/* pointer ? */ 
cc93:
	MOV  AX,cc1+228
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc94
;			/* it is a pointer, so skip all */ 
;			/* stuff between "[]" */ 
;			{ 
;			while (inbyte() != ']') 
cc95:
	CALL inbyte
	PUSH AX
	MOV  AX,93
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc96
;				if (endst()) break; 
	CALL endst
	CMP  AX,0
	JNE  $+5
	JMP  cc97
	JMP  cc96
;			j = ob_ptr; 
cc97:
	JMP  cc95
cc96:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	POP  BP
	MOV  [BP],AX
;			/* add entry as pointer */ 
;			} 
; 
;		addauto(n,j,t,argstk); 
cc94:
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,20
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,[argstk]
	PUSH AX
	CALL addauto
	ADD  SP,8
;		argstk = argstk - 2;	/* cnt down */ 
	MOV  AX,[argstk]
	PUSH AX
	MOV  AX,2
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	MOV  [argstk],AX
;		if (endst())  return; 
	CALL endst
	CMP  AX,0
	JNE  $+5
	JMP  cc98
	ADD  SP,14
	RET
;		if (match(",") == 0) error("expected comma"); 
cc98:
	MOV  AX,cc1+230
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc99
	MOV  AX,cc1+232
	PUSH AX
	CALL error
	ADD  SP,2
;		} 
cc99:
	JMP  cc87
cc88:
;} 
	ADD  SP,14
	RET
; 
;/************************************************/ 
;/*      Statement parser                        */ 
;/*                                              */ 
;/* called whenever syntax requires a statement. */ 
;/*  this routine performs that statement        */ 
;/*  and returns a number telling which one      */ 
;/************************************************/ 
;/** Callers: preprocess=>newfunc(); compound();**/ 
;/** doif(); dowhile();                         **/ 
; 
;statement() 
statement:
;{ 
;	if ((chr() == 0) & (eof_flg)) return; 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,[eof_flg]
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc100
	RET
;	else if (amatch("char",4)) 
	JMP  cc101
cc100:
	MOV  AX,cc1+247
	PUSH AX
	MOV  AX,4
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc102
;		{ 
;		declauto(cchar); 
	MOV  AX,1
	PUSH AX
	CALL declauto
	ADD  SP,2
;		ns(); 
	CALL ns
;		} 
;	else if (amatch("int",3)) 
	JMP  cc103
cc102:
	MOV  AX,cc1+252
	PUSH AX
	MOV  AX,3
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc104
;		{ 
;		declauto(cint); 
	MOV  AX,2
	PUSH AX
	CALL declauto
	ADD  SP,2
;		ns(); 
	CALL ns
;		} 
;	else if (match("{")) compound(); 
	JMP  cc105
cc104:
	MOV  AX,cc1+256
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc106
	CALL compound
;	else if (amatch("if",2)) 
	JMP  cc107
cc106:
	MOV  AX,cc1+258
	PUSH AX
	MOV  AX,2
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc108
;		{ 
;		doif(); 
	CALL doif
;		lastst = stif; 
	MOV  AX,1
	MOV  [lastst],AX
;		} 
; 
;/*	else if (amatch("do",2))  added by codeworks */ 
;/*		{dodo();lastst=stwhile;} version */ 
; 
;	else if (amatch("while",5)) 
	JMP  cc109
cc108:
	MOV  AX,cc1+261
	PUSH AX
	MOV  AX,5
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc110
;		{ 
;		dowhile(); 
	CALL dowhile
;		lastst = stwhile; 
	MOV  AX,2
	MOV  [lastst],AX
;		} 
;	else if (amatch("return",6)) 
	JMP  cc111
cc110:
	MOV  AX,cc1+267
	PUSH AX
	MOV  AX,6
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc112
;		{ 
;		doreturn(); 
	CALL doreturn
;		ns(); 
	CALL ns
;		lastst = streturn; 
	MOV  AX,3
	MOV  [lastst],AX
;		} 
;	else if (amatch("break",5)) 
	JMP  cc113
cc112:
	MOV  AX,cc1+274
	PUSH AX
	MOV  AX,5
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc114
;		{ 
;		dobreak(); 
	CALL dobreak
;		ns(); 
	CALL ns
;		lastst = stbreak; 
	MOV  AX,4
	MOV  [lastst],AX
;		} 
;	else if (amatch("continue",8)) 
	JMP  cc115
cc114:
	MOV  AX,cc1+280
	PUSH AX
	MOV  AX,8
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc116
;		{ 
;		docont(); 
	CALL docont
;		ns(); 
	CALL ns
;		lastst = stcont; 
	MOV  AX,5
	MOV  [lastst],AX
;		} 
;	else if (match(";")); 
	JMP  cc117
cc116:
	MOV  AX,cc1+289
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc118
;	else if (match("#asm")) 
	JMP  cc119
cc118:
	MOV  AX,cc1+291
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc120
;		{ 
;		doasm(); 
	CALL doasm
;		lastst = stasm; 
	MOV  AX,6
	MOV  [lastst],AX
;		} 
;	/* if nothing else, assume it's an expression */ 
;	else	{ 
	JMP  cc121
cc120:
;		expression(); 
	CALL expression
;		ns(); 
	CALL ns
;		lastst = stexp; 
	MOV  AX,7
	MOV  [lastst],AX
;		} 
cc121:
cc119:
cc117:
cc115:
cc113:
cc111:
cc109:
cc107:
cc105:
cc103:
cc101:
;	return lastst; 
	MOV  AX,[lastst]
	RET
;} 
; 
;/************************************************/ 
;/*      Semicolon enforcer                      */ 
;/*                                              */ 
;/* called whenever syntax requires a semicolon  */ 
;/************************************************/ 
; 
;ns() 
ns:
;{ 
;	if (match(";") == 0)  error("missing semicolon"); 
	MOV  AX,cc1+296
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc122
	MOV  AX,cc1+298
	PUSH AX
	CALL error
	ADD  SP,2
;} 
cc122:
	RET
; 
;/************************************************/ 
;/*      Compound statement                      */ 
;/*                                              */ 
;/*  allow any number of statements to fall      */ 
;/*  inbetween "{}"                              */ 
;/************************************************/ 
; 
;compound() 
compound:
;{ 
;	++ncmp;  /* new level open */ 
	MOV  AX,[ncmp]
	INC  AX
	MOV  [ncmp],AX
;	while (match("}") == 0) 
cc123:
	MOV  AX,cc1+316
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc124
;		if (eof_flg) return; 
	MOV  AX,[eof_flg]
	CMP  AX,0
	JNE  $+5
	JMP  cc125
	RET
;		else statement(); 
	JMP  cc126
cc125:
	CALL statement
cc126:
	JMP  cc123
cc124:
;	--ncmp;		/* close current level */ 
	MOV  AX,[ncmp]
	DEC  AX
	MOV  [ncmp],AX
;} 
	RET
; 
;/************************************************/ 
;/*              "if" statement                  */ 
;/************************************************/ 
; 
;doif() 
doif:
;{ 
;	int flev,fsp,flab1,flab2; 
	PUSH 0
	PUSH 0
	PUSH 0
	PUSH 0
; 
;	flev = autoptr;	/* record current local level */ 
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	MOV  AX,[autoptr]
	POP  BP
	MOV  [BP],AX
;	fsp = c_sp;		/* record current stk ptr */ 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,[c_sp]
	POP  BP
	MOV  [BP],AX
;	flab1 = getlabel(); /* get label for false branch */ 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	CALL getlabel
	POP  BP
	MOV  [BP],AX
;	m_test(flab1);	/* get expression, and branch false */ 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL m_test
	ADD  SP,2
;	statement();	/* if true, do a statement */ 
	CALL statement
;	c_sp = sa_modstk(fsp);	/* then clean up the stack */ 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL sa_modstk
	ADD  SP,2
	MOV  [c_sp],AX
;	autoptr = flev;	/* and deallocate any autos */ 
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  [autoptr],AX
;	if (amatch("else",4) == 0)	/* if...else ? */ 
	MOV  AX,cc1+318
	PUSH AX
	MOV  AX,4
	PUSH AX
	CALL amatch
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc127
;		/* simple "if"...print false label */ 
;		{ 
;		printlabel(flab1); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL printlabel
	ADD  SP,2
;		colon(); 
	CALL colon
;		nl(); 
	CALL nl
;		return;		/* and exit */ 
	ADD  SP,8
	RET
;		} 
;	/* an "if...else" statement. */ 
; 
;	sa_jump(flab2 = getlabel());	/* jump around false code */ 
cc127:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL getlabel
	POP  BP
	MOV  [BP],AX
	PUSH AX
	CALL sa_jump
	ADD  SP,2
;	printlabel(flab1);colon();nl();	/* print false label */ 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL printlabel
	ADD  SP,2
	CALL colon
	CALL nl
;	statement();		/* and do "else" clause */ 
	CALL statement
;	c_sp = sa_modstk(fsp);		/* then clean up stk ptr */ 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL sa_modstk
	ADD  SP,2
	MOV  [c_sp],AX
;	autoptr = flev;		/* and deallocate autos */ 
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  [autoptr],AX
;	printlabel(flab2);colon();nl();	/* print true label */ 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL printlabel
	ADD  SP,2
	CALL colon
	CALL nl
;} 
	ADD  SP,8
	RET
; 
;/************************************************/ 
;/*      "while" statement                       */ 
;/************************************************/ 
;dowhile() 
dowhile:
;{ 
;	int wq[4];          /* allocate local queue */ 
	ADD  SP,-8
;	wq[wqsym] = autoptr;    /* record local level */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,[autoptr]
	POP  BP
	MOV  [BP],AX
;	wq[wqsp] = c_sp;        /* and stk ptr */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,[c_sp]
	POP  BP
	MOV  [BP],AX
;	wq[wqloop] = getlabel(); /* and looping label */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL getlabel
	POP  BP
	MOV  [BP],AX
;	wq[wqlab] = getlabel(); /* and exit label */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL getlabel
	POP  BP
	MOV  [BP],AX
;	addwhile(wq);           /* add entry to queue */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL addwhile
	ADD  SP,2
;				/* (for "break" statement) */ 
;	printlabel(wq[wqloop]);colon();nl(); /* loop label */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL printlabel
	ADD  SP,2
	CALL colon
	CALL nl
;	m_test(wq[wqlab]);      /* see if true */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL m_test
	ADD  SP,2
;	statement();            /* if so, do a statement */ 
	CALL statement
;	sa_jump(wq[wqloop]);    /* loop to label */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL sa_jump
	ADD  SP,2
;	printlabel(wq[wqlab]);colon();nl(); /* exit label */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL printlabel
	ADD  SP,2
	CALL colon
	CALL nl
;	autoptr = wq[wqsym];    /* deallocate autos */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  [autoptr],AX
;	c_sp = sa_modstk(wq[wqsp]); /* clean up stk ptr */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL sa_modstk
	ADD  SP,2
	MOV  [c_sp],AX
;	delwhile();             /* delete queue entry */ 
	CALL delwhile
;} 
	ADD  SP,8
	RET
; 
;/************************************************/ 
;/*      "return" statement                      */ 
;/************************************************/ 
;doreturn() 
doreturn:
;{ 
;	/* if not end of statement, get an expression */ 
;	if (endst() == 0)  expression(); 
	CALL endst
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc128
	CALL expression
;	sa_modstk(0);	/* clean up stk */ 
cc128:
	MOV  AX,0
	PUSH AX
	CALL sa_modstk
	ADD  SP,2
;	sa_ret();	/* and exit function */ 
	CALL sa_ret
;} 
	RET
; 
;/************************************************/ 
;/*      "break" statement                       */ 
;/************************************************/ 
;dobreak() 
dobreak:
;{ 
;	int *ptr; 
	PUSH 0
;	/* see if any "whiles" are open */ 
;	if ((ptr=readwhile()) == 0) return; /* no */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL readwhile
	POP  BP
	MOV  [BP],AX
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc129
	ADD  SP,2
	RET
;	sa_modstk((ptr[wqsp])); /* else clean up stk ptr */ 
cc129:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL sa_modstk
	ADD  SP,2
;	sa_jump(ptr[wqlab]);    /* jump to exit label */ 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,3
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL sa_jump
	ADD  SP,2
;} 
	ADD  SP,2
	RET
; 
;/************************************************/ 
;/*      "continue" statement                    */ 
;/************************************************/ 
;docont() 
docont:
;{ 
;	int *ptr; 
	PUSH 0
;	/* see if any "whiles" are open */ 
;	if ((ptr = readwhile()) == 0) return;  /* no */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL readwhile
	POP  BP
	MOV  [BP],AX
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc130
	ADD  SP,2
	RET
;	sa_modstk((ptr[wqsp])); /* else clean up stk ptr */ 
cc130:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL sa_modstk
	ADD  SP,2
;	sa_jump(ptr[wqloop]);   /* jump to loop label */ 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL sa_jump
	ADD  SP,2
;} 
	ADD  SP,2
	RET
; 
;/************************************************/ 
;/*      "asm" pseudo-statement                  */ 
;/*                                              */ 
;/* enters mode where assembly language statement*/ 
;/*   are passed intact through parser           */ 
;/************************************************/ 
;doasm() 
doasm:
;{ 
;	cmode = 0;  /* mark mode as "asm" */ 
	MOV  AX,0
	MOV  [cmode],AX
;	while (1) 
cc131:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc132
;		{ 
;		inline();  /* get and print lines */ 
	CALL inline
;		if (match("#endasm"))  break; /* until... */ 
	MOV  AX,cc1+323
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc133
	JMP  cc132
;		if (eof_flg)  break; 
cc133:
	MOV  AX,[eof_flg]
	CMP  AX,0
	JNE  $+5
	JMP  cc134
	JMP  cc132
;		outstr(line); 
cc134:
	MOV  AX,line
	PUSH AX
	CALL outstr
	ADD  SP,2
;		nl(); 
	CALL nl
;		} 
	JMP  cc131
cc132:
;	kill_ln();  /* invalidate line */ 
	CALL kill_ln
;	cmode = 1;  /* then back to parse level */ 
	MOV  AX,1
	MOV  [cmode],AX
;} 
	RET
; 
;/************************************************/ 
;/*      Perform a function call                 */ 
;/*                                              */ 
;/* called from heir11, this routine will either */ 
;/*   call the named function, or if the supplied*/ 
;/*   ptr is zero, will call the contents of     */ 
;/*   HL- Primary                                */ 
;/************************************************/ 
;/** Actually the Primary value is placed on the stack **/ 
;/**  and called from off the stack.                   **/ 
; 
;callfunction(ptr) char *ptr;  /* symbol table entry (or 0) */ 
callfuncti:
;{ 
;	int nargs; 
	PUSH 0
; 
;	nargs = 0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;	blanks();  /* already saw open paren */ 
	CALL blanks
;/** If Null Ptr, Push the primary register onto the stack **/ 
;	if (ptr == 0) 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc135
;		{ 
;	/***	ol("  ;+; callfunction push Prim_Tgt.."); ***/ 
;		sa_push();  /** to call Primary **/ 
	CALL sa_push
;		} 
;	while (streq(line + lptr,")") == 0) 
cc135:
cc136:
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+331
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc137
;		{ 
;		if (endst()) break; 
	CALL endst
	CMP  AX,0
	JNE  $+5
	JMP  cc138
	JMP  cc137
;		expression();  /* get an argument */ 
cc138:
	CALL expression
;		if (ptr == 0)  sa_swapstk(); /* don't push addr */ 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc139
	CALL sa_swapstk
;                      /** swaps each loop to keep on TOS **/ 
; 
;	/***	ol("  ;+; callfunction push arg.."); ***/ 
;		sa_push();  /* push argument */ 
cc139:
	CALL sa_push
;		nargs = nargs + 2;  /* count args*2 */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;		if (match(",") == 0) break; 
	MOV  AX,cc1+333
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc140
	JMP  cc137
;		} 
cc140:
	JMP  cc136
cc137:
;	needbrack(")"); 
	MOV  AX,cc1+335
	PUSH AX
	CALL needbrack
	ADD  SP,2
;	if (ptr) sa_call(ptr); /** sematic action, call fn **/ 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc141
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL sa_call
	ADD  SP,2
;	else  sa_callstk(); /** sematic action, call stack fn **/ 
	JMP  cc142
cc141:
	CALL sa_callstk
cc142:
;	c_sp = sa_modstk(c_sp + nargs);  /* clean up arguments */ 
	MOV  AX,[c_sp]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL sa_modstk
	ADD  SP,2
	MOV  [c_sp],AX
;} 
	ADD  SP,2
	RET
; 
;/************************************************/ 
;junk() 
junk:
;{ 
;	if(an(inbyte())) 
	CALL inbyte
	PUSH AX
	CALL an
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc143
;		while(an(chr()))  gchr(); 
cc144:
	CALL chr
	PUSH AX
	CALL an
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc145
	CALL gchr
	JMP  cc144
cc145:
;	else while(an(chr()) == 0) 
	JMP  cc146
cc143:
cc147:
	CALL chr
	PUSH AX
	CALL an
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc148
;		{ 
;		if(chr() == 0)break; 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc149
	JMP  cc148
;		gchr(); 
cc149:
	CALL gchr
;		} 
	JMP  cc147
cc148:
cc146:
;	blanks(); 
	CALL blanks
;} 
	RET
; 
;/************************************************/ 
;endst() 
endst:
;{ 
;	blanks(); 
	CALL blanks
;	return ((streq(line + lptr,";") | (chr() == 0))); 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+337
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	RET
;} 
;/************************************************/ 
; 
;/** ch > chr, and > m_and, pop > sa_pop    **/ 
;/** push > sa_push, or > m_or, xor > m_xor **/ 
; 
;/** The hierarchical recursive descent steps have  **/ 
;/** the pattern of, on entry, call the next higher **/ 
;/** precedence level, and then at return, filter   **/ 
;/** for lexeme operators for its level.  If false, **/ 
;/** returns control to the lower precedence level. **/ 
;/** If true, select for matching lexeme for its    **/ 
;/** precedence level and perform the production    **/ 
;/** actions to generate code.                      **/ 
;/** expression() forms a control array: eval[2] to **/ 
;/** which rdvalue(eval) responds after primary(eval)*/ 
;/** has made its determinations on the nature of   **/ 
;/** the identifier parsed in a statement held in a **/ 
;/** line buffer.  Two symbol tables are maintained **/ 
;/** one for Local Symbols (auto storage class) and **/ 
;/** one for Global Symbols (static storage class). **/ 
;/** operations on auto variables take place on the **/ 
;/** Stack, static variable operations involve their**/ 
;/** storage in the Data Segment.  Symbol record    **/ 
;/** structure, and the possible field values are   **/ 
;/** defined at the begining of the source through  **/ 
;/** #define statements.  This C subset language    **/ 
;/** hasn't structures, unions, switch statements,  **/ 
;/** etc., but has enough to bootstrap those elements*/ 
;/** in later editions.  The primary(eval) sets eval**/ 
;/** fields as a control mechanism on identifiers for*/ 
;/** rdvalue and the rest of the expression analyzer */ 
;/** as well, it sets a return value of zero or one **/ 
;/** as an additional control flag.  Consequently,  **/ 
;/** the following control table develops:          **/ 
;/**    ob_cl    eval[0]  [1]  ret_val              **/ 
;/**      .IF. AUTO                                 **/ 
;/**    const      0       0      0                 **/ 
;/**    funct     ptr     typ     1                 **/ 
;/**   ob_array   ptr     typ     0                 **/ 
;/**   ob_ptr     ptr     typ     1                 **/ 
;/**   ob_var     ptr     typ     1                 **/ 
;/**      .IF. STATIC                               **/ 
;/**    const      0       0      0                 **/ 
;/**    funct     ptr      0      0                 **/ 
;/**   ob_array   ptr      0      0                 **/ 
;/**   ob_ptr     ptr      0      1                 **/ 
;/**   ob_var     ptr      0      1                 **/ 
;/** such that.. ptr is identifier location in symbol*/ 
;/**  table and typ for array is one of cchar.1 or  **/ 
;/**  ccint.2, and an identifier of pointer or var  **/ 
;/** return(1), array and function identifiers      **/ 
;/** return(0).                                     **/ 
; 
;/************************************************/ 
;/** Evaluate an expression statement.          **/ 
;/** Callers: statement(); do_return();         **/ 
;/** callfunction(); heir11(); m_test();        **/ 
;/************************************************/ 
; 
;/** eval[2], eval2[2], are two operand attribute arrays **/ 
; 
;expression() 
expression:
;{ 
;	int eval[2];  /** array of 2 integer sized elements **/ 
	PUSH 0
	PUSH 0
; 
;	if (heir1(eval)) rdvalue(eval); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir1
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc150
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;} 
cc150:
	ADD  SP,4
	RET
; 
;heir1(eval) int eval[]; 
heir1:
;{ 
;	int k,eval2[2]; /** second operand attribute array **/ 
	PUSH 0
	PUSH 0
	PUSH 0
; 
;	k = heir2(eval); 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL heir2
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
; 
;	if (match("="))   /** ck next chr as 'assignment' **/ 
	MOV  AX,cc1+339
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc151
;		{ 
;		if (k == 0) 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc152
;			{ 
;			needlval();   /** err not an lvalue **/ 
	CALL needlval
;			return 0; 
	MOV  AX,0
	ADD  SP,6
	RET
;			} 
;		if (eval[1]) /** sc_auto **/ 
cc152:
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc153
;			{ 
;		/***	ol("  ;+; heir1 push arg.."); ***/ 
;			sa_push(); /** auto val **/ 
	CALL sa_push
;			} 
;		if (heir1(eval2)) rdvalue(eval2); 
cc153:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir1
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc154
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;	/***	ol("  ;+; heir1 stor_sc`eval.."); ***/ 
; 
;		stor_sc(eval); 
cc154:
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL stor_sc
	ADD  SP,2
;		return 0; 
	MOV  AX,0
	ADD  SP,6
	RET
;		} 
;	else return k; 
	JMP  cc155
cc151:
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,6
	RET
cc155:
;} 
	ADD  SP,6
	RET
; 
;heir2(eval) int eval[]; 
heir2:
;{ 
;	int k,eval2[2]; 
	PUSH 0
	PUSH 0
	PUSH 0
; 
;	k = heir3(eval); 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL heir3
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
; 
;	blanks(); 
	CALL blanks
;	if (chr() != '|') return k;  /** ck next chr as 'or' **/ 
	CALL chr
	PUSH AX
	MOV  AX,124
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc156
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,6
	RET
;	if (k) rdvalue(eval); 
cc156:
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc157
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;	while(1) 
cc157:
cc158:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc159
;		{ 
;		if (match("|")) 
	MOV  AX,cc1+341
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc160
;			{ 
;			sa_push(); 
	CALL sa_push
;			if (heir3(eval2)) rdvalue(eval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir3
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc161
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;			sa_pop(); 
cc161:
	CALL sa_pop
;			m_or(); 
	CALL m_or
;			} 
;		else return 0; 
	JMP  cc162
cc160:
	MOV  AX,0
	ADD  SP,6
	RET
cc162:
;		} 
	JMP  cc158
cc159:
;} 
	ADD  SP,6
	RET
; 
;heir3(eval) int eval[]; 
heir3:
;{ 
;	int k,eval2[2]; 
	PUSH 0
	PUSH 0
	PUSH 0
; 
;	k = heir4(eval); 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL heir4
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
; 
;	blanks(); 
	CALL blanks
;	if (chr() != '^') return k;  /** ck next chr as 'xor' **/ 
	CALL chr
	PUSH AX
	MOV  AX,94
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc163
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,6
	RET
;	if (k) rdvalue(eval); 
cc163:
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc164
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;	while(1) 
cc164:
cc165:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc166
;		{ 
;		if (match("^")) 
	MOV  AX,cc1+343
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc167
;			{ 
;			sa_push(); 
	CALL sa_push
;			if (heir4(eval2)) rdvalue(eval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir4
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc168
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;			sa_pop(); 
cc168:
	CALL sa_pop
;			m_xor(); 
	CALL m_xor
;			} 
;		else return 0; 
	JMP  cc169
cc167:
	MOV  AX,0
	ADD  SP,6
	RET
cc169:
;		} 
	JMP  cc165
cc166:
;} 
	ADD  SP,6
	RET
; 
;heir4(eval) int eval[]; 
heir4:
;{ 
;	int k,eval2[2]; 
	PUSH 0
	PUSH 0
	PUSH 0
; 
;	k = heir5(eval); 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL heir5
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
; 
;	blanks(); 
	CALL blanks
;	if (chr() != '&') return k;  /** ck next chr as 'and' **/ 
	CALL chr
	PUSH AX
	MOV  AX,38
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc170
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,6
	RET
;	if (k) rdvalue(eval); 
cc170:
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc171
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;	while(1) 
cc171:
cc172:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc173
;		{ 
;		if (match("&")) 
	MOV  AX,cc1+345
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc174
;			{ 
;			sa_push(); 
	CALL sa_push
;			if (heir5(eval2)) rdvalue(eval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir5
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc175
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;			sa_pop(); 
cc175:
	CALL sa_pop
;			m_and(); 
	CALL m_and
;			} 
;		else return 0; 
	JMP  cc176
cc174:
	MOV  AX,0
	ADD  SP,6
	RET
cc176:
;		} 
	JMP  cc172
cc173:
;} 
	ADD  SP,6
	RET
; 
;heir5(eval) int eval[]; 
heir5:
;{ 
;	int k,eval2[2]; 
	PUSH 0
	PUSH 0
	PUSH 0
; 
;	k = heir6(eval); 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL heir6
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
; 
;	blanks(); 
	CALL blanks
;	  /** ck next chr as 'equivalent' or 'not equal' **/ 
;	if ((streq(line + lptr,"==") == 0) & 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+347
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
;		(streq(line + lptr,"!=") == 0)) return k; 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+350
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc177
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,6
	RET
;	if (k) rdvalue(eval); 
cc177:
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc178
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;	while(1) 
cc178:
cc179:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc180
;		{ 
;		if (match("==")) 
	MOV  AX,cc1+353
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc181
;			{ 
;			sa_push(); 
	CALL sa_push
;			if (heir6(eval2)) rdvalue(eval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir6
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc182
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;			sa_pop(); 
cc182:
	CALL sa_pop
;		/** cmp Secd. to Prim. ret1 in Prim. if TRUE **/ 
;			eq();  
	CALL eq
;			} 
;		else if (match("!=")) 
	JMP  cc183
cc181:
	MOV  AX,cc1+356
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc184
;			{ 
;			sa_push(); 
	CALL sa_push
;			if (heir6(eval2)) rdvalue(eval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir6
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc185
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;			sa_pop(); 
cc185:
	CALL sa_pop
;			ne(); 
	CALL ne
;			} 
;		else return 0; 
	JMP  cc186
cc184:
	MOV  AX,0
	ADD  SP,6
	RET
cc186:
cc183:
;		} 
	JMP  cc179
cc180:
;} 
	ADD  SP,6
	RET
; 
;heir6(eval) int eval[]; /** ck next chr pr as 'relational op' **/ 
heir6:
;{ 
;	int k,eval2[2]; 
	PUSH 0
	PUSH 0
	PUSH 0
; 
;	k = heir7(eval); 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL heir7
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
; 
;	blanks(); 
	CALL blanks
;	if ((streq(line + lptr,"<") == 0) & 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+359
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
;		(streq(line + lptr,">") == 0) & 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+361
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	PUSH AX
;		(streq(line + lptr,"<=") == 0) & 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+363
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	PUSH AX
;		(streq(line + lptr,">=") == 0)) return k; 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+366
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc187
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,6
	RET
;	if (streq(line + lptr,">>")) return k; 
cc187:
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+369
	PUSH AX
	CALL streq
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc188
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,6
	RET
;	if (streq(line + lptr,"<<")) return k; 
cc188:
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+372
	PUSH AX
	CALL streq
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc189
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,6
	RET
;	if (k) rdvalue(eval); 
cc189:
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc190
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;	while(1) 
cc190:
cc191:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc192
;		{ 
;		if (match("<=")) 
	MOV  AX,cc1+375
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc193
;			{ 
;			sa_push(); 
	CALL sa_push
;			if (heir7(eval2)) rdvalue(eval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir7
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc194
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;			sa_pop(); 
cc194:
	CALL sa_pop
;			if (cptr = eval[0]) 
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  [cptr],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc195
;				if (cptr[ob_cl] == ob_ptr) 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc196
;				{ 
;				ule(); 
	CALL ule
;				continue; 
	JMP  cc191
;				} 
;			le(); 
cc196:
cc195:
	CALL le
;			} 
;		else if (match(">=")) 
	JMP  cc197
cc193:
	MOV  AX,cc1+378
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc198
;			{ 
;			sa_push(); 
	CALL sa_push
;			if (heir7(eval2)) rdvalue(eval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir7
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc199
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;			sa_pop(); 
cc199:
	CALL sa_pop
;			if (cptr = eval[0]) 
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  [cptr],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc200
;				if (cptr[ob_cl] == ob_ptr) 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc201
;				{ 
;				uge(); 
	CALL uge
;				continue; 
	JMP  cc191
;				} 
;			if(cptr = eval2[0]) 
cc201:
cc200:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  [cptr],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc202
;				if(cptr[ob_cl] == ob_ptr) 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc203
;				{ 
;				uge(); 
	CALL uge
;				continue; 
	JMP  cc191
;				} 
;			ge(); 
cc203:
cc202:
	CALL ge
;			} 
;		else if ((streq(line + lptr,"<")) & 
	JMP  cc204
cc198:
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+381
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
;			(streq(line + lptr,"<<") == 0)) 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+383
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc205
;			{ 
;			inbyte(); 
	CALL inbyte
;			sa_push(); 
	CALL sa_push
;			if (heir7(eval2)) rdvalue(eval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir7
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc206
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;			sa_pop(); 
cc206:
	CALL sa_pop
;			if (cptr = eval[0]) 
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  [cptr],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc207
;				if (cptr[ob_cl] == ob_ptr) 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc208
;				{ 
;				ult(); 
	CALL ult
;				continue; 
	JMP  cc191
;				} 
;			if (cptr = eval2[0]) 
cc208:
cc207:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  [cptr],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc209
;				if (cptr[ob_cl] == ob_ptr) 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc210
;				{ 
;				ult(); 
	CALL ult
;				continue; 
	JMP  cc191
;				} 
;			lt(); 
cc210:
cc209:
	CALL lt
;			} 
;		else if ((streq(line + lptr,">")) & 
	JMP  cc211
cc205:
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+386
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
;			(streq(line + lptr,">>") == 0)) 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+388
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc212
;			{ 
;			inbyte(); 
	CALL inbyte
;			sa_push(); 
	CALL sa_push
;			if (heir7(eval2)) rdvalue(eval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir7
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc213
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;			sa_pop(); 
cc213:
	CALL sa_pop
;			if (cptr = eval[0]) 
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  [cptr],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc214
;				if (cptr[ob_cl] == ob_ptr) 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc215
;				{ 
;				ugt(); 
	CALL ugt
;				continue; 
	JMP  cc191
;				} 
;			if (cptr = eval2[0]) 
cc215:
cc214:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  [cptr],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc216
;				if(cptr[ob_cl] == ob_ptr) 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc217
;				{ 
;				ugt(); 
	CALL ugt
;				continue; 
	JMP  cc191
;				} 
;			gt(); 
cc217:
cc216:
	CALL gt
;			} 
;		else return 0; 
	JMP  cc218
cc212:
	MOV  AX,0
	ADD  SP,6
	RET
cc218:
cc211:
cc204:
cc197:
;		} 
	JMP  cc191
cc192:
;} 
	ADD  SP,6
	RET
; 
;/** ch > chr, div > m_div, push > sa_push **/ 
;/** add > m_add, sub > m_sub, mult > m_mult **/ 
;/** inc > m_inc, dec > m_dec, neg > m_neg **/ 
; 
;heir7(eval) int eval[];  /** ck next chr as 'shift ops' **/ 
heir7:
;{ 
;	int k,eval2[2]; 
	PUSH 0
	PUSH 0
	PUSH 0
; 
;	k = heir8(eval); /** recursive descent **/ 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL heir8
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
; 
;	blanks(); 
	CALL blanks
;	if ((streq(line + lptr,">>") == 0) & 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+391
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
;		(streq(line + lptr,"<<") == 0)) return k; 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+394
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc219
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,6
	RET
;		/** trap for >> << **/ 
;	if (k) rdvalue(eval); 
cc219:
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc220
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;	while(1) 
cc220:
cc221:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc222
;		{ 
;		if (match(">>")) 
	MOV  AX,cc1+397
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc223
;			{ 
;			sa_push(); 
	CALL sa_push
;			if (heir8(eval2)) rdvalue(eval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir8
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc224
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;			sa_pop(); 
cc224:
	CALL sa_pop
;			asr(); 
	CALL asr
;			} 
;		else if (match("<<")) 
	JMP  cc225
cc223:
	MOV  AX,cc1+400
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc226
;			{ 
;			sa_push(); 
	CALL sa_push
;			if(heir8(eval2)) rdvalue(eval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir8
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc227
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;			sa_pop(); 
cc227:
	CALL sa_pop
;			asl(); 
	CALL asl
;			} 
;		else return 0; 
	JMP  cc228
cc226:
	MOV  AX,0
	ADD  SP,6
	RET
cc228:
cc225:
;		} 
	JMP  cc221
cc222:
;} 
	ADD  SP,6
	RET
; 
;heir8(eval) int eval[];  /** ck next chr as 'plus or minus op' **/ 
heir8:
;{ 
;	int k,eval2[2]; 
	PUSH 0
	PUSH 0
	PUSH 0
; 
;	k = heir9(eval); 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL heir9
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
; 
;	blanks(); 
	CALL blanks
;	if ((chr() != '+') & (chr() != '-')) return k; 
	CALL chr
	PUSH AX
	MOV  AX,43
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	PUSH AX
	CALL chr
	PUSH AX
	MOV  AX,45
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc229
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,6
	RET
;	if (k) rdvalue(eval); 
cc229:
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc230
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;	while(1) 
cc230:
cc231:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc232
;		{ 
;		if (match("+")) 
	MOV  AX,cc1+403
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc233
;			{ 
;			sa_push(); 
	CALL sa_push
;			if (heir9(eval2)) rdvalue(eval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir9
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc234
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;			if (cptr = eval[0]) 
cc234:
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  [cptr],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc235
;				if ((cptr[ob_cl] == ob_ptr) & 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
;					(cptr[type] == cint)) 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc236
;					doublereg(); 
	CALL doublereg
;			sa_pop(); 
cc236:
cc235:
	CALL sa_pop
;			m_add(); 
	CALL m_add
;			} 
;		else if (match("-")) 
	JMP  cc237
cc233:
	MOV  AX,cc1+405
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc238
;			{ 
;			sa_push(); 
	CALL sa_push
;			if (heir9(eval2)) rdvalue(eval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir9
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc239
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;			if (cptr = eval[0]) 
cc239:
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  [cptr],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc240
;				if ((cptr[ob_cl] == ob_ptr) & 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
;					(cptr[type] == cint)) 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc241
;					doublereg(); 
	CALL doublereg
;			sa_pop(); 
cc241:
cc240:
	CALL sa_pop
;			m_sub(); 
	CALL m_sub
;			} 
;		else return 0; 
	JMP  cc242
cc238:
	MOV  AX,0
	ADD  SP,6
	RET
cc242:
cc237:
;		} 
	JMP  cc231
cc232:
;} 
	ADD  SP,6
	RET
; 
;heir9(eval) int eval[];  /** ck next chr as 'mult, div or mod op' **/ 
heir9:
;{ 
;	int k,eval2[2]; 
	PUSH 0
	PUSH 0
	PUSH 0
; 
;	k = heir10(eval); 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL heir10
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
; 
;	blanks(); 
	CALL blanks
;	if((chr() != '*') & (chr() != '/') & 
	CALL chr
	PUSH AX
	MOV  AX,42
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	PUSH AX
	CALL chr
	PUSH AX
	MOV  AX,47
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	PUSH AX
;		(chr() != '%')) return k; 
	CALL chr
	PUSH AX
	MOV  AX,37
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc243
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,6
	RET
;	if (k) rdvalue(eval); 
cc243:
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc244
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;	while(1) 
cc244:
cc245:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc246
;		{ 
;		if (match("*")) 
	MOV  AX,cc1+407
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc247
;			{ 
;			sa_push(); 
	CALL sa_push
;			if (heir9(eval2)) rdvalue(eval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir9
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc248
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;			sa_pop(); 
cc248:
	CALL sa_pop
;			m_mult(); 
	CALL m_mult
;			} 
;		else if (match("/")) 
	JMP  cc249
cc247:
	MOV  AX,cc1+409
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc250
;			{ 
;			sa_push(); 
	CALL sa_push
;			if (heir10(eval2)) rdvalue(eval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir10
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc251
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;			sa_pop(); 
cc251:
	CALL sa_pop
;			m_div(); 
	CALL m_div
;			} 
;		else if (match("%")) 
	JMP  cc252
cc250:
	MOV  AX,cc1+411
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc253
;			{ 
;			sa_push(); 
	CALL sa_push
;			if (heir10(eval2)) rdvalue(eval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir10
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc254
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;			sa_pop(); 
cc254:
	CALL sa_pop
;			mod(); 
	CALL mod
;			} 
;		else return 0; 
	JMP  cc255
cc253:
	MOV  AX,0
	ADD  SP,6
	RET
cc255:
cc252:
cc249:
;		} 
	JMP  cc245
cc246:
;} 
	ADD  SP,6
	RET
; 
;heir10(eval) int eval[]; 
heir10:
;{       /** ck next chr as 'prefix unary op' **/ 
;	int k; char *ptr; 
	PUSH 0
	PUSH 0
; 
;	if (match("++")) 
	MOV  AX,cc1+413
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc256
;		{ 
;		if ((k = heir10(eval)) == 0)  /** recurse **/ 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL heir10
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc257
;			{ 
;			needlval();   /** err not an lvalue **/ 
	CALL needlval
;			return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;			} 
;		if (eval[1]) sa_push(); /** auto **/ 
cc257:
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc258
	CALL sa_push
;		rdvalue(eval); 
cc258:
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;		m_inc();          /** incr by ob_sz char **/ 
	CALL m_inc
;		ptr = eval[0]; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;					/** incr by ob_sz int **/ 
;		if ((ptr[ob_cl] == ob_ptr) & (ptr[type] == cint))  m_inc(); 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc259
	CALL m_inc
;	/***	ol("  ;+; heir10 ++a stor_sc`eval.."); ***/ 
;		stor_sc(eval); 
cc259:
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL stor_sc
	ADD  SP,2
;		return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;		} 
;	else if (match("--")) 
	JMP  cc260
cc256:
	MOV  AX,cc1+416
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc261
;		{ 
;		if((k=heir10(eval)) == 0)  /** recurse **/ 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL heir10
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc262
;			{ 
;			needlval();   /** err not an lvalue **/ 
	CALL needlval
;			return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;			} 
;		if (eval[1]) sa_push(); /** auto **/ 
cc262:
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc263
	CALL sa_push
;		rdvalue(eval); 
cc263:
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;		m_dec();		/** decr by ob_sz char **/ 
	CALL m_dec
;		ptr = eval[0]; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;					/** decr by ob_sz int **/ 
;		if ((ptr[ob_cl]==ob_ptr) & (ptr[type]==cint))  m_dec(); 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc264
	CALL m_dec
;		stor_sc(eval); 
cc264:
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL stor_sc
	ADD  SP,2
;		return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;		} 
;	else if (match("-")) 
	JMP  cc265
cc261:
	MOV  AX,cc1+419
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc266
;		{ 
;		k = heir10(eval);  /** recurse **/ 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL heir10
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
; 
;		if (k) rdvalue(eval); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc267
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;		m_neg(); 
cc267:
	CALL m_neg
;		return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;		} 
;	else if (match("*")) 
	JMP  cc268
cc266:
	MOV  AX,cc1+421
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc269
;		{ 
;		k = heir10(eval);  /** recurse **/ 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL heir10
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
; 
;		if (k) rdvalue(eval); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc270
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;		if (ptr = eval[0]) 
cc270:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc271
;			eval[1] = ptr[type]; /** auto int or char **/ 
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AX
;		 
;		eval[0] = 0; 
cc271:
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;		return 1;    /** flag to cont. ck of str '***' **/ 
	MOV  AX,1
	ADD  SP,4
	RET
;		} 
;	else if (match("&")) 
	JMP  cc272
cc269:
	MOV  AX,cc1+423
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc273
;		{ 
;		k = heir10(eval);  /** recurse **/ 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL heir10
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
; 
;		if (k == 0) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc274
;			{ 
;			error("illegal address"); 
	MOV  AX,cc1+425
	PUSH AX
	CALL error
	ADD  SP,2
;			return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;			} 
;		else if (eval[1]) return 0; 
	JMP  cc275
cc274:
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc276
	MOV  AX,0
	ADD  SP,4
	RET
;		else	{ 
	JMP  cc277
cc276:
;			mn_ldi_prim();  /** mnem LD Imm Primary **/ 
	CALL mn_ldi_pri
;			outstr(ptr = eval[0]); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
	PUSH AX
	CALL outstr
	ADD  SP,2
;			nl(); 
	CALL nl
;			eval[1] = ptr[type]; 
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AX
;			return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;			} 
cc277:
cc275:
;		} 
; 
;  /** .else. ck next chr as 'postfix unary op' **/ 
;	else	{ 
	JMP  cc278
cc273:
;		k = heir11(eval); 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL heir11
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
; 
;		if (match("++")) 
	MOV  AX,cc1+441
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc279
;			{ 
;			if (k == 0) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc280
;				{ 
;				needlval();  /** err not an lvalue **/ 
	CALL needlval
;				return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;				} 
;			if (eval[1]) sa_push(); /** auto **/ 
cc280:
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc281
	CALL sa_push
;			rdvalue(eval); 
cc281:
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;			m_inc(); 
	CALL m_inc
;			ptr = eval[0]; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;			if ((ptr[ob_cl] == ob_ptr) & (ptr[type] == cint)) 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc282
;					m_inc(); 
	CALL m_inc
;		/***	ol("  ;+; heir10 a++ stor_sc`eval.."); ***/ 
;			stor_sc(eval); 
cc282:
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL stor_sc
	ADD  SP,2
;			m_dec(); 
	CALL m_dec
;			if ((ptr[ob_cl] == ob_ptr) & (ptr[type] == cint)) 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc283
;				m_dec(); 
	CALL m_dec
;			return 0; 
cc283:
	MOV  AX,0
	ADD  SP,4
	RET
;			} 
;		else if (match("--")) 
	JMP  cc284
cc279:
	MOV  AX,cc1+444
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc285
;			{ 
;			if (k == 0) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc286
;				{ 
;				needlval(); /** err not an lvalue **/ 
	CALL needlval
;				return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;				} 
;			if (eval[1]) sa_push(); /** auto **/ 
cc286:
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc287
	CALL sa_push
;			rdvalue(eval); 
cc287:
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;			m_dec(); 
	CALL m_dec
;			if ((ptr[ob_cl] == ob_ptr) & (ptr[type] == cint)) 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc288
;				m_dec(); 
	CALL m_dec
; 
;			stor_sc(eval); 
cc288:
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL stor_sc
	ADD  SP,2
;			m_inc(); 
	CALL m_inc
;			if ((ptr[ob_cl] == ob_ptr) & (ptr[type] == cint)) 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc289
;				m_inc(); 
	CALL m_inc
;			return 0; 
cc289:
	MOV  AX,0
	ADD  SP,4
	RET
;			} 
;		else return k; 
	JMP  cc290
cc285:
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,4
	RET
cc290:
cc284:
;		} 
cc278:
cc272:
cc268:
cc265:
cc260:
;} 
	ADD  SP,4
	RET
; 
;/************************************************/ 
;/** ch > chr, gch > gchr, add > m_add.         **/ 
;/** push > sa_push, pop > sa_pop,          **/ 
;/** test > m_test                              **/ 
; 
;/** ck next token as 'left bracket or left parenthesis terminal' **/ 
;/** L-Brkt indicates array, L-Paren indicates a function call.   **/ 
; 
;heir11(eval) int *eval; 
heir11:
;{ 
;	int k; char *ptr; 
	PUSH 0
	PUSH 0
; 
;	k = primary(eval); /** Ck Lexeme as static, auto or number **/ 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL primary
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
;				/** or New Fn, const or error.           **/ 
; 
;	ptr = eval[0];  /** ck nonterminal kind **/ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;	blanks(); 
	CALL blanks
;	if ((chr() == '[')|(chr() == '(')) 
	CALL chr
	PUSH AX
	MOV  AX,91
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	CALL chr
	PUSH AX
	MOV  AX,40
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc291
;		while (1) 
cc292:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc293
;		{ 
;		if (match("["))  /*** Array Form ***/ 
	MOV  AX,cc1+447
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc294
;			{ 
;			if (ptr == 0) 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc295
;				{ 
;				error("can't subscript"); 
	MOV  AX,cc1+449
	PUSH AX
	CALL error
	ADD  SP,2
;				junk(); 
	CALL junk
;				needbrack("]"); 
	MOV  AX,cc1+465
	PUSH AX
	CALL needbrack
	ADD  SP,2
;				return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;				} 
;			else if (ptr[ob_cl] == ob_ptr) rdvalue(eval); 
	JMP  cc296
cc295:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc297
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;			else if (ptr[ob_cl] != ob_array) 
	JMP  cc298
cc297:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc299
;				{ 
;				error("can't subscript"); 
	MOV  AX,cc1+467
	PUSH AX
	CALL error
	ADD  SP,2
;				k = 0;   /** err not an lvalue **/ 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;				} 
;			sa_push(); 
cc299:
cc298:
cc296:
	CALL sa_push
;			expression();  /** recursive call to itself **/ 
	CALL expression
;			needbrack("]"); 
	MOV  AX,cc1+483
	PUSH AX
	CALL needbrack
	ADD  SP,2
;			if (ptr[type] == cint) doublereg(); 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc300
	CALL doublereg
;			sa_pop(); 
cc300:
	CALL sa_pop
;			m_add(); 
	CALL m_add
;			eval[0] = 0; 
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;			eval[1] = ptr[type]; 
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AX
;			k = 1; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	POP  BP
	MOV  [BP],AX
;			} 
;		else if (match("("))  /*** Function Form ***/ 
	JMP  cc301
cc294:
	MOV  AX,cc1+485
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc302
;			{  /** Parse Fn indicator -Ident followed by '(' **/ 
;			if (ptr == 0) 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc303
;				{ 
;				callfunction(0); /** lvalue on stack **/ 
	MOV  AX,0
	PUSH AX
	CALL callfuncti
	ADD  SP,2
;				} 
;			else if (ptr[ob_cl] != ob_fn) 
	JMP  cc304
cc303:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,4
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc305
;				{ 
;				rdvalue(eval); 
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL rdvalue
	ADD  SP,2
;				callfunction(0); /** lvalue on stack **/ 
	MOV  AX,0
	PUSH AX
	CALL callfuncti
	ADD  SP,2
;				} 
;			  /** otherwise lvalue of ob_fn is in the **/ 
;			  /** symbol table as 'offset' value.     **/ 
;			else callfunction(ptr); 
	JMP  cc306
cc305:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL callfuncti
	ADD  SP,2
cc306:
cc304:
;			k = eval[0] = 0;   /** err not an lvalue **/ 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
	POP  BP
	MOV  [BP],AX
;			} 
;		else return k; 
	JMP  cc307
cc302:
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,4
	RET
cc307:
cc301:
;		} 
	JMP  cc292
cc293:
;	if (ptr == 0) return k; 
cc291:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc308
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,4
	RET
;	if (ptr[ob_cl] == ob_fn) 
cc308:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,4
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc309
;		{ 
;		mn_ldi_prim();	/** mnem LD Imm Primary **/ 
	CALL mn_ldi_pri
;		outstr(ptr); 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL outstr
	ADD  SP,2
;		nl(); 
	CALL nl
;		return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;		} 
;	return k; 
cc309:
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,4
	RET
;} 
; 
;/** Primary Checks for Lexeme as static, auto or number... **/ 
;/**  also perform Syntatic Action for Code Generation.     **/ 
;/** The return value is part of the signal of expression() **/ 
;/** Map these signals...**/ 
; 
;primary(eval) int *eval;  /** token typing **/ 
primary:
;{ 
;	char *ptr,sname[namesize]; int num[1]; int k; 
	PUSH 0
	ADD  SP,-11
	PUSH 0
	PUSH 0
; 
;	if (match("(")) /** is it a parenthesis expression? **/ 
	MOV  AX,cc1+487
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc310
;		{ 
;		k = heir1(eval); /** suspend eval, recurse next depth **/ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,21
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL heir1
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
; 
;		needbrack(")"); 
	MOV  AX,cc1+489
	PUSH AX
	CALL needbrack
	ADD  SP,2
;		return k; /** Note: if k == 0, err not an lvalue **/ 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,17
	RET
;		} 
;	if (symbform(sname)) /** check valid symbol name **/ 
cc310:
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	CALL symbform
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc311
;		{ 
;		if (ptr = findauto(sname)) /** search auto symtbl **/ 
	MOV  AX,15
	ADD  AX,SP
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	CALL findauto
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc312
;			{  /** already auto, fill eval[] array **/ 
;			get_auto(ptr);  /** Syntatic Action -> codegen **/ 
	MOV  AX,15
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL get_auto
	ADD  SP,2
; 
;			eval[0] = ptr;  /** SymTbl`sym_index`0 is lexeme **/ 
	MOV  AX,19
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,17
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;			eval[1] = ptr[type]; /** assign SymTbl .type **/ 
	MOV  AX,19
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,17
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AX
;			if (ptr[ob_cl] == ob_ptr) eval[1] = cint; 
	MOV  AX,15
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc313
	MOV  AX,19
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,2
	POP  BP
	MOV  [BP],AX
;			if (ptr[ob_cl] == ob_array) return 0; 
cc313:
	MOV  AX,15
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc314
	MOV  AX,0
	ADD  SP,17
	RET
;			else return 1; 
	JMP  cc315
cc314:
	MOV  AX,1
	ADD  SP,17
	RET
cc315:
;			} 
;/** so if identifier is sc_auto, ret`1, except if ob_array ret`0 **/ 
; 
;		if (ptr = findstatic(sname)) /** search static symtbl **/ 
cc312:
	MOV  AX,15
	ADD  AX,SP
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	CALL findstatic
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc316
;			if (ptr[ob_cl] != ob_fn) /** Except Function..**/ 
	MOV  AX,15
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,4
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc317
;				{ 
;				eval[0] = ptr; 
	MOV  AX,19
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,17
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;				eval[1] = 0; 
	MOV  AX,19
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;				if (ptr[ob_cl] != ob_array) return 1; 
	MOV  AX,15
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc318
	MOV  AX,1
	ADD  SP,17
	RET
; 
;			/** .else. ob_ is static array **/ 
;				/** Syntatic Action -> codegen **/ 
;				mn_ldi_prim();  /** mnem LD Imm Primary **/ 
cc318:
	CALL mn_ldi_pri
;				outstr(ptr); nl(); /*outname*/ 
	MOV  AX,15
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL outstr
	ADD  SP,2
	CALL nl
;				  /** finish parsing state for static array **/ 
;				eval[1] = ptr[type]; 
	MOV  AX,19
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,17
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AX
;				return 0; 
	MOV  AX,0
	ADD  SP,17
	RET
;				} 
;/** so if identifier is sc_static but not a ob_function, **/ 
;/** then also ret`1 except if ob_array ret`0 **/ 
; 
;	/** .if. here, then not previously in any symbol table **/ 
;	/** add to static symbol table as Fn, set parse array. **/ 
;		ptr = addstatic(sname,ob_fn,cint,0); 
cc317:
cc316:
	MOV  AX,15
	ADD  AX,SP
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	MOV  AX,4
	PUSH AX
	MOV  AX,2
	PUSH AX
	MOV  AX,0
	PUSH AX
	CALL addstatic
	ADD  SP,8
	POP  BP
	MOV  [BP],AX
;		eval[0] = ptr; 
	MOV  AX,19
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,17
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;		eval[1] = 0; 
	MOV  AX,19
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;		return 0; 
	MOV  AX,0
	ADD  SP,17
	RET
;		}  /** end symbol name check **/ 
; 
;/** .if. here, not a parenthesis, nor name, is it a number ? **/ 
; 
;	if (constant(num)) return (eval[0] = eval[1] = 0); 
cc311:
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	CALL constant
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc319
	MOV  AX,19
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,21
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
	POP  BP
	MOV  [BP],AX
	ADD  SP,17
	RET
; 
;	else	{ 
	JMP  cc320
cc319:
;		error("invalid expression"); 
	MOV  AX,cc1+491
	PUSH AX
	CALL error
	ADD  SP,2
;		mn_ldi_prim();  /** mnem LD Imm Primary **/ 
	CALL mn_ldi_pri
;		outdec(0); 
	MOV  AX,0
	PUSH AX
	CALL outdec
	ADD  SP,2
;		nl(); 
	CALL nl
;		junk(); 
	CALL junk
;		return 0; 
	MOV  AX,0
	ADD  SP,17
	RET
;		} 
cc320:
;}  /** end Primary expression ck **/ 
	ADD  SP,17
	RET
; 
; 
;/**--------------------------------------------**/ 
; 
;stor_sc(eval) int *eval; 
stor_sc:
;{ 
;	if (eval[1]==0) put_static(eval[0]); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc321
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL put_static
	ADD  SP,2
;		/***	else putstk(eval[1]);  ***/ 
;	else putssstk(eval[1]); 
	JMP  cc322
cc321:
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL putssstk
	ADD  SP,2
cc322:
;} 
	RET
; 
;rdvalue(eval) int *eval; 
rdvalue:
;{ 
;	if ((eval[0] != 0) & (eval[1] == 0)) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc323
;		get_static(eval[0]); /** static; fn, ptr, or var **/ 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL get_static
	ADD  SP,2
;/**	else indirect(eval[1]); ** auto; array or const **/ 
;	else stk_indi(eval[1]); /** auto; array or const **/ 
	JMP  cc324
cc323:
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL stk_indi
	ADD  SP,2
cc324:
;} 
	RET
; 
;m_test(label) int label; 
m_test:
;{ 
;	needbrack("("); 
	MOV  AX,cc1+510
	PUSH AX
	CALL needbrack
	ADD  SP,2
;	expression(); 
	CALL expression
;	needbrack(")"); 
	MOV  AX,cc1+512
	PUSH AX
	CALL needbrack
	ADD  SP,2
;	testjump(label); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL testjump
	ADD  SP,2
;} 
	RET
; 
;constant(val) int val[]; 
constant:
;{		/** is it a number constant? **/ 
;	if (number(val))  mn_ldi_prim();  /** mnem LD Imm Primary **/ 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL number
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc325
	CALL mn_ldi_pri
; 
;		/** is it a char constant? **/ 
;	else if (pstr(val))  mn_ldi_prim(); 
	JMP  cc326
cc325:
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL pstr
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc327
	CALL mn_ldi_pri
; 
;		/** is it a string constant? **/ 
;	else if (qstr(val))  /** static quoted str of char **/ 
	JMP  cc328
cc327:
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL qstr
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc329
;		{ 
;		mn_ldi_prim();  /** mnem LD Imm Primary **/ 
	CALL mn_ldi_pri
;		printlabel(litlab); 
	MOV  AX,[litlab]
	PUSH AX
	CALL printlabel
	ADD  SP,2
;		outbyte('+'); 
	MOV  AX,43
	PUSH AX
	CALL outbyte
	ADD  SP,2
;		} 
;	else return 0;	 
	JMP  cc330
cc329:
	MOV  AX,0
	RET
cc330:
cc328:
cc326:
;	outdec(val[0]); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL outdec
	ADD  SP,2
;	nl(); 
	CALL nl
;	return 1; 
	MOV  AX,1
	RET
;} 
; 
;number(val) int val[]; 
number:
;{ 
;	int k,minus; char c; 
	PUSH 0
	PUSH 0
	DEC  SP
; 
;	k = minus = 1; 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	POP  BP
	MOV  [BP],AX
	POP  BP
	MOV  [BP],AX
;	while (k)  /** handle signs **/ 
cc331:
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc332
;		{ 
;		k = 0; 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;		if (match("+")) k = 1; 
	MOV  AX,cc1+514
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc333
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	POP  BP
	MOV  [BP],AX
;		if (match("-")) 
cc333:
	MOV  AX,cc1+516
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc334
;			{ 
;			minus = (-minus); 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	NEG  AX
	POP  BP
	MOV  [BP],AX
;			k = 1; 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	POP  BP
	MOV  [BP],AX
;			} 
;		} 
cc334:
	JMP  cc331
cc332:
;	if (numeric(chr()) == 0) return 0;  
	CALL chr
	PUSH AX
	CALL numeric
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc335
	MOV  AX,0
	ADD  SP,5
	RET
;		/** failed, next char from ln buff isn't a digit **/ 
; 
;	while (numeric(chr())) /** conv ascii digit str to value **/ 
cc335:
cc336:
	CALL chr
	PUSH AX
	CALL numeric
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc337
;		{ 
;		c = inbyte(); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL inbyte
	POP  BP
	MOV  [BP],AL
;		k = k*10+(c-'0'); 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,5
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,10
	POP  BX
	MUL  BX
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,48
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;		} 
	JMP  cc336
cc337:
;	if (minus<0) k = (-k); 
	MOV  AX,1
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc338
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,5
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	NEG  AX
	POP  BP
	MOV  [BP],AX
;	val[0] = k; 
cc338:
	MOV  AX,7
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,5
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;	return 1; 
	MOV  AX,1
	ADD  SP,5
	RET
;} 
; 
;pstr(val) int val[]; 
pstr:
;{		/** check for character constant **/ 
;	int k; char c; 
	PUSH 0
	DEC  SP
; 
;	k = 0; 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;	if (match("'") == 0) return 0; /** not a char const **/ 
	MOV  AX,cc1+518
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc339
	MOV  AX,0
	ADD  SP,3
	RET
;	while ((c = gchr()) != 39)    /** single quote **/ 
cc339:
cc340:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL gchr
	POP  BP
	MOV  [BP],AL
	PUSH AX
	MOV  AX,39
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc341
;		k = (k&255) * 256 + (c&127); 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,255
	POP  BX
	AND  AX,BX
	PUSH AX
	MOV  AX,256
	POP  BX
	MUL  BX
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,127
	POP  BX
	AND  AX,BX
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
	JMP  cc340
cc341:
;	val[0] = k; 
	MOV  AX,5
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;	return 1; 
	MOV  AX,1
	ADD  SP,3
	RET
;} 
; 
;/** 2.5 Strings, are a sequence of characters surrounded by **/ 
;/** double quotes, has type 'array of char', and storage    **/ 
;/** class _static_                                          **/ 
; 
;qstr(val) int val[]; 
qstr:
;{ 
;	char c; 
	DEC  SP
; 
;	if (match(quote) == 0) return 0; 
	MOV  AX,quote
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc342
	MOV  AX,0
	ADD  SP,1
	RET
;	val[0] = litptr; 
cc342:
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,[litptr]
	POP  BP
	MOV  [BP],AX
;	while (chr() != '"') 
cc343:
	CALL chr
	PUSH AX
	MOV  AX,34
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc344
;		{ 
;		if (chr() == 0) break; 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc345
	JMP  cc344
;		if (litptr >= litmax) 
cc345:
	MOV  AX,[litptr]
	PUSH AX
	MOV  AX,4000
	PUSH AX
	MOV  AX,1
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc346
;			{ 
;			error("string space exhausted"); 
	MOV  AX,cc1+520
	PUSH AX
	CALL error
	ADD  SP,2
;			while (match(quote) == 0) 
cc347:
	MOV  AX,quote
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc348
;				if( gchr() == 0) break; 
	CALL gchr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc349
	JMP  cc348
;			return 1; 
cc349:
	JMP  cc347
cc348:
	MOV  AX,1
	ADD  SP,1
	RET
;			} 
;		litq[litptr++] = gchr(); 
cc346:
	MOV  AX,litq
	PUSH AX
	MOV  AX,[litptr]
	INC  AX
	MOV  [litptr],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL gchr
	POP  BP
	MOV  [BP],AL
;		} 
	JMP  cc343
cc344:
;	gchr(); 
	CALL gchr
;	litq[litptr++] = 0; 
	MOV  AX,litq
	PUSH AX
	MOV  AX,[litptr]
	INC  AX
	MOV  [litptr],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AL
;	return 1; 
	MOV  AX,1
	ADD  SP,1
	RET
;} 
; 
;/****************************************/ 
;/**  SCN_II.C 			       **/ 
;/** Next is SCN_III.C 		       **/ 
;/************************************************/ 
;/** Re-Codified roughly as:                    **/ 
;/**     I.   Static Storage Defn, main()       **/ 
;/**     II.  Recursive Descent Parser          **/ 
;/**     III. Utility Functions                 **/ 
;/**     IV.  U.I. & I/O                        **/ 
;/**     V.   Backend, NASM Object Output       **/ 
;/************************************************/ 
;/************************************************/ 
;/*          small-c compiler                    */ 
;/*              rev. 1.1                        */ 
;/*            by Ron Cain                       */ 
;/*              (1980)                          */ 
;/************************************************/ 
; 
;/** Symbol Lookup in Static Table, ret`0 if not found, **/ 
;/** .else. address of symbol matched in static table   **/ 
; 
;findstatic(sname) char *sname; 
findstatic:
;{ 
;	char *ptr; 
	PUSH 0
; 
;	ptr = startstatic; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,symtab
	POP  BP
	MOV  [BP],AX
;	while (ptr != staticptr) 
cc350:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,[staticptr]
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc351
;		{ 
;		if (astreq(sname,ptr,namemax)) return ptr; 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,10
	PUSH AX
	CALL astreq
	ADD  SP,6
	CMP  AX,0
	JNE  $+5
	JMP  cc352
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,2
	RET
;		ptr = ptr + symsiz; 
cc352:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,16
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;		} 
	JMP  cc350
cc351:
;	return 0; 
	MOV  AX,0
	ADD  SP,2
	RET
;} 
; 
;/** Symbol Lookup in Auto Table, ret`0 if not found, **/ 
;/** .else. address of symbol matched in auto table   **/ 
; 
;findauto(sname) char *sname; 
findauto:
;{ 
;	char *ptr; 
	PUSH 0
; 
;	ptr = startauto; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,symtab
	PUSH AX
	MOV  AX,300
	PUSH AX
	MOV  AX,16
	POP  BX
	MUL  BX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,16
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;	while (ptr != autoptr) 
cc353:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,[autoptr]
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc354
;		{ 
;		if (astreq(sname,ptr,namemax)) return ptr; 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,10
	PUSH AX
	CALL astreq
	ADD  SP,6
	CMP  AX,0
	JNE  $+5
	JMP  cc355
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,2
	RET
;		ptr = ptr + symsiz; 
cc355:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,16
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;		} 
	JMP  cc353
cc354:
;	return 0; 
	MOV  AX,0
	ADD  SP,2
	RET
;} 
; 
;addstatic(sname,id,typ,value) char *sname,id,typ; int value; 
addstatic:
;{ 
;	char *ptr; 
	PUSH 0
; 
;		/** return cptr of sym if already defined **/ 
;	if (cptr = findstatic(sname)) return cptr; 
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL findstatic
	ADD  SP,2
	MOV  [cptr],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc356
	MOV  AX,[cptr]
	ADD  SP,2
	RET
;	if (staticptr >= endstatic) 
cc356:
	MOV  AX,[staticptr]
	PUSH AX
	MOV  AX,symtab
	PUSH AX
	MOV  AX,300
	PUSH AX
	MOV  AX,16
	POP  BX
	MUL  BX
	POP  BX
	ADD  AX,BX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JAE  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc357
;		{ 
;		error("global symbol table overflow"); 
	MOV  AX,cc1+543
	PUSH AX
	CALL error
	ADD  SP,2
;		return 0; 
	MOV  AX,0
	ADD  SP,2
	RET
;		} 
;	cptr = ptr = staticptr; 
cc357:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,[staticptr]
	POP  BP
	MOV  [BP],AX
	MOV  [cptr],AX
;	while (an(*ptr++ = *sname++));	/* copy name */ 
cc358:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	PUSH AX
	MOV  AX,12
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
	PUSH AX
	CALL an
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc359
	JMP  cc358
cc359:
;	cptr[ob_cl] = id; 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;	cptr[type] = typ; 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;	cptr[stor_cl] = sc_static; 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,13
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,1
	POP  BP
	MOV  [BP],AL
;	cptr[offset] = value; 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,14
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AL
;	cptr[offset+1] = value >> 8; 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,14
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,8
	POP  BX
	MOV  CL,AL
	MOV  AX,BX
	SAR  AX,CL
	POP  BP
	MOV  [BP],AL
;	staticptr = staticptr + symsiz; /** structure increment **/ 
	MOV  AX,[staticptr]
	PUSH AX
	MOV  AX,16
	POP  BX
	ADD  AX,BX
	MOV  [staticptr],AX
;	return cptr; 
	MOV  AX,[cptr]
	ADD  SP,2
	RET
;} 
; 
;addauto(sname,id,typ,value) char *sname,id,typ; int value; 
addauto:
;{ 
;	char *ptr; 
	PUSH 0
; 
;		/** return cptr of sym if already defined **/ 
;	if (cptr = findauto(sname)) return cptr; 
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL findauto
	ADD  SP,2
	MOV  [cptr],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc360
	MOV  AX,[cptr]
	ADD  SP,2
	RET
;	if (autoptr >= endauto) 
cc360:
	MOV  AX,[autoptr]
	PUSH AX
	MOV  AX,symtab
	PUSH AX
	MOV  AX,5760
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,16
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JAE  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc361
;		{ 
;		error("auto, symbol table overflow"); 
	MOV  AX,cc1+572
	PUSH AX
	CALL error
	ADD  SP,2
;		return 0; 
	MOV  AX,0
	ADD  SP,2
	RET
;		} 
;	cptr = ptr = autoptr; 
cc361:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,[autoptr]
	POP  BP
	MOV  [BP],AX
	MOV  [cptr],AX
;	while (an(*ptr++ = *sname++));	/* copy name */ 
cc362:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	PUSH AX
	MOV  AX,12
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
	PUSH AX
	CALL an
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc363
	JMP  cc362
cc363:
;	cptr[ob_cl] = id; 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;	cptr[type] = typ; 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;	cptr[stor_cl] = sc_auto; 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,13
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,2
	POP  BP
	MOV  [BP],AL
;	cptr[offset] = value; 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,14
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AL
;	cptr[offset+1] = value >> 8; 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,14
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,8
	POP  BX
	MOV  CL,AL
	MOV  AX,BX
	SAR  AX,CL
	POP  BP
	MOV  [BP],AL
;	autoptr = autoptr + symsiz; 
	MOV  AX,[autoptr]
	PUSH AX
	MOV  AX,16
	POP  BX
	ADD  AX,BX
	MOV  [autoptr],AX
;	return cptr; 
	MOV  AX,[cptr]
	ADD  SP,2
	RET
;} 
; 
;/* Test if next input string is legal symbol name */ 
;/** symname -> symbform **/ 
;symbform(sname) char *sname; 
symbform:
;{ 
;	int k; char c; 
	PUSH 0
	DEC  SP
; 
;	blanks(); 
	CALL blanks
;	if (alpha(chr()) == 0) return 0; 
	CALL chr
	PUSH AX
	CALL alpha
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc364
	MOV  AX,0
	ADD  SP,3
	RET
;	k = 0; 
cc364:
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;	while (an(chr())) sname[k++] = gchr(); 
cc365:
	CALL chr
	PUSH AX
	CALL an
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc366
	MOV  AX,5
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL gchr
	POP  BP
	MOV  [BP],AL
	JMP  cc365
cc366:
;	sname[k] = 0; 
	MOV  AX,5
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AL
;	return 1; 
	MOV  AX,1
	ADD  SP,3
	RET
;} 
; 
;/* Return next avail internal label number */ 
;getlabel() 
getlabel:
;{ 
;	return (++nxtlab); 
	MOV  AX,[nxtlab]
	INC  AX
	MOV  [nxtlab],AX
	RET
;} 
; 
;/* Print specified number as label */ 
;printlabel(label) int label; 
printlabel:
;{ 
;	outstr("cc"); 
	MOV  AX,cc1+600
	PUSH AX
	CALL outstr
	ADD  SP,2
;	outdec(label); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL outdec
	ADD  SP,2
;} 
	RET
; 
;/* Test if given character is alpha */ 
;alpha(c) char c; 
alpha:
;{ 
;	c = c & 127; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,127
	POP  BX
	AND  AX,BX
	POP  BP
	MOV  [BP],AL
;	return (((c >= 'a') & (c <= 'z')) | 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,97
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,122
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JLE  $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	PUSH AX
;		((c >= 'A') & (c <= 'Z')) | 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,65
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,90
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JLE  $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	POP  BX
	OR   AX,BX
	PUSH AX
;		(c == '_')); 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,95
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	RET
;} 
; 
;/* Test if given character is numeric */ 
;numeric(c) char c; 
numeric:
;{ 
;	c = c & 127; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,127
	POP  BX
	AND  AX,BX
	POP  BP
	MOV  [BP],AL
;	return ((c >= '0') & (c <= '9')); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,48
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,57
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JLE  $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	RET
;} 
; 
;/* Test if given character is alphanumeric */ 
;an(c) char c; 
an:
;{ 
;	return ((alpha(c)) | (numeric(c))); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL alpha
	ADD  SP,2
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL numeric
	ADD  SP,2
	POP  BX
	OR   AX,BX
	RET
;} 
; 
;/*** 'While' Method Primitives ***/ 
; 
;addwhile(ptr) int ptr[]; 
addwhile:
;{ 
;	int k; 
	PUSH 0
; 
;	if (wqptr == wqmax) 
	MOV  AX,[wqptr]
	PUSH AX
	MOV  AX,wq
	PUSH AX
	MOV  AX,100
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,4
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc367
;		{ 
;		error("too many active whiles"); 
	MOV  AX,cc1+603
	PUSH AX
	CALL error
	ADD  SP,2
;		return; 
	ADD  SP,2
	RET
;		} 
;	k = 0; 
cc367:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;	while (k < wqsiz) 
cc368:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,4
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc369
;		{ 
;		*wqptr++ = ptr[k++]; 
	MOV  AX,[wqptr]
	INC  AX
	INC  AX
	MOV  [wqptr],AX
	DEC  AX
	DEC  AX
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;		} 
	JMP  cc368
cc369:
;} 
	ADD  SP,2
	RET
; 
;delwhile() 
delwhile:
;{ 
;	if (readwhile()) wqptr = wqptr - wqsiz; 
	CALL readwhile
	CMP  AX,0
	JNE  $+5
	JMP  cc370
	MOV  AX,[wqptr]
	PUSH AX
	MOV  AX,4
	ADD  AX,AX
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	MOV  [wqptr],AX
;} 
cc370:
	RET
; 
;readwhile() 
readwhile:
;{ 
;	if (wqptr == wq) 
	MOV  AX,[wqptr]
	PUSH AX
	MOV  AX,wq
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc371
;		{ 
;		error("no active whiles"); 
	MOV  AX,cc1+626
	PUSH AX
	CALL error
	ADD  SP,2
;		return 0; 
	MOV  AX,0
	RET
;		} 
;	else return (wqptr - wqsiz); 
	JMP  cc372
cc371:
	MOV  AX,[wqptr]
	PUSH AX
	MOV  AX,4
	ADD  AX,AX
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	RET
cc372:
;} 
	RET
; 
;/**--------------------------------------------**/ 
;/** input line buffer functions.               **/ 
;/**--------------------------------------------**/ 
; 
;chr() /** fetch 7-bit char from line buffer **/ 
chr:
;{ 
;	return (line[lptr] & 127); 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,127
	POP  BX
	AND  AX,BX
	RET
;} 
; 
;nchr() /** look_ahead to next char in line buffer **/ 
nchr:
;{ 
;	if (chr() == 0) return 0; 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc373
	MOV  AX,0
	RET
;	else return (line[lptr+1] & 127); 
	JMP  cc374
cc373:
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,127
	POP  BX
	AND  AX,BX
	RET
cc374:
;} 
	RET
; 
;gchr() /** fetch 7-bit char from line buffer, inc ptr **/ 
gchr:
;{ 
;	if (chr() == 0) return 0; 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc375
	MOV  AX,0
	RET
;	else return (line[lptr++] & 127); 
	JMP  cc376
cc375:
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	INC  AX
	MOV  [lptr],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,127
	POP  BX
	AND  AX,BX
	RET
cc376:
;} 
	RET
; 
;/** reset (to erase) linebuffer, callers: ask();**/ 
;/** openout(); openin(); doinclude();addmac();  **/ 
;/** newfunc(); doasm(); inline();               **/ 
;/** set ln ptr to zero offset and poke location w/null **/ 
; 
;kill_ln() 
kill_ln:
;{ 
;	lptr = 0; 
	MOV  AX,0
	MOV  [lptr],AX
;	line[lptr] = 0; 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AL
;} 
	RET
; 
;inbyte() 
inbyte:
;{ 
;	while (chr() == 0) 
cc377:
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc378
;		{ 
;		if (eof_flg) return 0; 
	MOV  AX,[eof_flg]
	CMP  AX,0
	JNE  $+5
	JMP  cc379
	MOV  AX,0
	RET
;		inline(); 
cc379:
	CALL inline
;		prepline(); 
	CALL prepline
;		} 
	JMP  cc377
cc378:
;	/** fetch 7-bit char from line buffer, inc ptr **/ 
;	return gchr();  
	CALL gchr
	RET
;} 
; 
;inchar() /** see kill_ln, fill inline buffer, ret char **/ 
inchar:
;{ 
;	if (chr() == 0) inline(); 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc380
	CALL inline
;	if (eof_flg) return 0; 
cc380:
	MOV  AX,[eof_flg]
	CMP  AX,0
	JNE  $+5
	JMP  cc381
	MOV  AX,0
	RET
;		/** fetch 7-bit char from line buffer, inc ptr **/ 
;	return (gchr()); 
cc381:
	CALL gchr
	RET
;} 
; 
;inline() /** Read infile, char by char, to fill line buffer **/ 
inline:
;{ 
;	int k,unit; 
	PUSH 0
	PUSH 0
; 
;	while (1) 
cc382:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc383
;		{ 
;		if (fp_in == 0) openin(); 
	MOV  AX,[fp_in]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc384
	CALL openin
;		if (eof_flg) return; 
cc384:
	MOV  AX,[eof_flg]
	CMP  AX,0
	JNE  $+5
	JMP  cc385
	ADD  SP,4
	RET
;		if ((unit = fp_in2) == 0) unit = fp_in; 
cc385:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,[fp_in2]
	POP  BP
	MOV  [BP],AX
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc386
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,[fp_in]
	POP  BP
	MOV  [BP],AX
;		kill_ln(); 
cc386:
	CALL kill_ln
;		while ((k = getc(unit)) > 0) 
cc387:
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL getc
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JG   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc388
;			{ 
;			if ((k == eol) | (lptr >= linemax)) break; 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,10
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,[lptr]
	PUSH AX
	MOV  AX,80
	PUSH AX
	MOV  AX,1
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc389
	JMP  cc388
;			line[lptr++] = k; 
cc389:
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	INC  AX
	MOV  [lptr],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AL
;			} 
	JMP  cc387
cc388:
;		line[lptr] = 0;	/* append null */ 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AL
;		if (k <= 0) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JLE  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc390
;			{ 
;			fclose(unit); 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL fclose
	ADD  SP,2
;			if (fp_in2) fp_in2 = 0; 
	MOV  AX,[fp_in2]
	CMP  AX,0
	JNE  $+5
	JMP  cc391
	MOV  AX,0
	MOV  [fp_in2],AX
;				else fp_in = 0; 
	JMP  cc392
cc391:
	MOV  AX,0
	MOV  [fp_in],AX
cc392:
;			} 
;		if (lptr) 
cc390:
	MOV  AX,[lptr]
	CMP  AX,0
	JNE  $+5
	JMP  cc393
;			{  /* cmode==0 means mode is "asm" */ 
;			if ((ctext) & (cmode)) 
	MOV  AX,[ctext]
	PUSH AX
	MOV  AX,[cmode]
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc394
;				{ 
;				comment(); 
	CALL comment
;				outstr(line); 
	MOV  AX,line
	PUSH AX
	CALL outstr
	ADD  SP,2
;				nl(); 
	CALL nl
;				} 
;			lptr = 0; 
cc394:
	MOV  AX,0
	MOV  [lptr],AX
;			return; 
	ADD  SP,4
	RET
;			} 
;		} 
cc393:
	JMP  cc382
cc383:
;} 
	ADD  SP,4
	RET
; 
;/** ch > chr, gch > gchr, nch > nchr           **/ 
;/** method uses the macro line buffer as a temp store **/ 
; 
;keepch(c) char c; 
keepch:
;{ 
;	mline[mptr] = c; 
	MOV  AX,mline
	PUSH AX
	MOV  AX,[mptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;	if (mptr < mpmax) mptr++; 
	MOV  AX,[mptr]
	PUSH AX
	MOV  AX,80
	PUSH AX
	MOV  AX,1
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc395
	MOV  AX,[mptr]
	INC  AX
	MOV  [mptr],AX
	DEC  AX
;	return c; 
cc395:
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	RET
;} 
; 
;/* Preprocess input lines by removing 
; * comments and excess white space, 
; * checking strings and char constants, 
; * & applying #define macros to the rest 
; */ 
;prepline() /* Process Line in LineBuffer line[k] */ 
prepline:
;{ 
;	int k; char c, sname[namesize]; /** identifier **/ 
	PUSH 0
	DEC  SP
	ADD  SP,-11
; 
;		/* cmode==0 means mark mode as "asm" */ 
;	if (cmode == 0) return; 
	MOV  AX,[cmode]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc396
	ADD  SP,14
	RET
;	mptr = lptr = 0; 
cc396:
	MOV  AX,0
	MOV  [lptr],AX
	MOV  [mptr],AX
;	while (chr()) 
cc397:
	CALL chr
	CMP  AX,0
	JNE  $+5
	JMP  cc398
;		{ 
;		if ((chr()==' ')|(chr() == 9)) /* filter sp, tab */ 
	CALL chr
	PUSH AX
	MOV  AX,32
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	CALL chr
	PUSH AX
	MOV  AX,9
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc399
;			{ 
;			keepch(' '); 
	MOV  AX,32
	PUSH AX
	CALL keepch
	ADD  SP,2
;			while ((chr() == ' ') | (chr() == 9)) gchr(); 
cc400:
	CALL chr
	PUSH AX
	MOV  AX,32
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	CALL chr
	PUSH AX
	MOV  AX,9
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc401
	CALL gchr
	JMP  cc400
cc401:
;			} 
;		else if (chr() == '"')         /* filter double quote */ 
	JMP  cc402
cc399:
	CALL chr
	PUSH AX
	MOV  AX,34
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc403
;			{ 
;			keepch(chr()); 
	CALL chr
	PUSH AX
	CALL keepch
	ADD  SP,2
;			gchr(); 
	CALL gchr
;			while (chr() != '"') 
cc404:
	CALL chr
	PUSH AX
	MOV  AX,34
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc405
;				{ 
;				if(chr() == 0) 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc406
;					{ 
;					error("missing quote"); 
	MOV  AX,cc1+643
	PUSH AX
	CALL error
	ADD  SP,2
;				  	break; 
	JMP  cc405
;					} 
;				keepch(gchr()); 
cc406:
	CALL gchr
	PUSH AX
	CALL keepch
	ADD  SP,2
;				} 
	JMP  cc404
cc405:
;			gchr(); 
	CALL gchr
;			keepch('"'); 
	MOV  AX,34
	PUSH AX
	CALL keepch
	ADD  SP,2
;			} 
;		else if (chr() == 39)          /* filter single quote */ 
	JMP  cc407
cc403:
	CALL chr
	PUSH AX
	MOV  AX,39
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc408
;			{ 
;			keepch(39); 
	MOV  AX,39
	PUSH AX
	CALL keepch
	ADD  SP,2
;			gchr(); 
	CALL gchr
;			while (chr() != 39) 
cc409:
	CALL chr
	PUSH AX
	MOV  AX,39
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc410
;				{ 
;				if(chr() == 0) 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc411
;					{ 
;					error("missing apostrophe"); 
	MOV  AX,cc1+657
	PUSH AX
	CALL error
	ADD  SP,2
;					break; 
	JMP  cc410
;					} 
;				keepch(gchr()); 
cc411:
	CALL gchr
	PUSH AX
	CALL keepch
	ADD  SP,2
;				} 
	JMP  cc409
cc410:
;			gchr(); 
	CALL gchr
;			keepch(39); 
	MOV  AX,39
	PUSH AX
	CALL keepch
	ADD  SP,2
;			} 
;		else if ((chr() == '/') & (nchr() == '*')) 
	JMP  cc412
cc408:
	CALL chr
	PUSH AX
	MOV  AX,47
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	CALL nchr
	PUSH AX
	MOV  AX,42
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc413
;			{	/* filter bi-glyph, comment start */ 
;			inchar(); 
	CALL inchar
;			inchar(); 
	CALL inchar
;			while (((chr() == '*') & (nchr() == '/')) == 0) 
cc414:
	CALL chr
	PUSH AX
	MOV  AX,42
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	CALL nchr
	PUSH AX
	MOV  AX,47
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc415
;				{ 
;				if(chr() == 0) inline(); 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc416
	CALL inline
;				else inchar(); 
	JMP  cc417
cc416:
	CALL inchar
cc417:
;				if (eof_flg) break; 
	MOV  AX,[eof_flg]
	CMP  AX,0
	JNE  $+5
	JMP  cc418
	JMP  cc415
;				} 
cc418:
	JMP  cc414
cc415:
;			inchar(); 
	CALL inchar
;			inchar(); 
	CALL inchar
;			} 
;		else if (an(chr()))  /* CK alpha..numeric + '_' */ 
	JMP  cc419
cc413:
	CALL chr
	PUSH AX
	CALL an
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc420
;			{ 
;			k = 0; 
	MOV  AX,12
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;			while (an(chr())) 
cc421:
	CALL chr
	PUSH AX
	CALL an
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc422
;				{ 
;				if (k < namemax) sname[k++] = chr(); 
	MOV  AX,12
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,10
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc423
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,14
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL chr
	POP  BP
	MOV  [BP],AL
;				gchr(); 
cc423:
	CALL gchr
;				} 
	JMP  cc421
cc422:
;			sname[k] = 0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,14
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AL
;			if (k = findmac(sname)) 
	MOV  AX,12
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	CALL findmac
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc424
;				while (c = macq[k++]) keepch(c); 
cc425:
	MOV  AX,11
	ADD  AX,SP
	PUSH AX
	MOV  AX,macq
	PUSH AX
	MOV  AX,16
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
	CMP  AX,0
	JNE  $+5
	JMP  cc426
	MOV  AX,11
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL keepch
	ADD  SP,2
	JMP  cc425
cc426:
;			else	{ 
	JMP  cc427
cc424:
;				k = 0; 
	MOV  AX,12
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;				while (c = sname[k++]) keepch(c); 
cc428:
	MOV  AX,11
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,16
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
	CMP  AX,0
	JNE  $+5
	JMP  cc429
	MOV  AX,11
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL keepch
	ADD  SP,2
	JMP  cc428
cc429:
;				} 
cc427:
;			} 
;		else keepch(gchr()); 
	JMP  cc430
cc420:
	CALL gchr
	PUSH AX
	CALL keepch
	ADD  SP,2
cc430:
cc419:
cc412:
cc407:
cc402:
;		} 
	JMP  cc397
cc398:
;	keepch(0); 
	MOV  AX,0
	PUSH AX
	CALL keepch
	ADD  SP,2
;	if (mptr >= mpmax) error("line too long"); 
	MOV  AX,[mptr]
	PUSH AX
	MOV  AX,80
	PUSH AX
	MOV  AX,1
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc431
	MOV  AX,cc1+676
	PUSH AX
	CALL error
	ADD  SP,2
;	lptr = mptr = 0; 
cc431:
	MOV  AX,0
	MOV  [mptr],AX
	MOV  [lptr],AX
;	while (line[lptr++] = mline[mptr++]); 
cc432:
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	INC  AX
	MOV  [lptr],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,mline
	PUSH AX
	MOV  AX,[mptr]
	INC  AX
	MOV  [mptr],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
	CMP  AX,0
	JNE  $+5
	JMP  cc433
	JMP  cc432
cc433:
;	lptr = 0; 
	MOV  AX,0
	MOV  [lptr],AX
;} 
	ADD  SP,14
	RET
; 
;/************************************************/ 
;streq(str1,str2) char str1[], str2[]; 
streq:
;{ 
;	int k; 
	PUSH 0
; 
;	k = 0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;	while (str2[k]) /** callers str **/ 
cc434:
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc435
;		{ 
;		if ((str1[k]) != (str2[k])) return 0; 
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc436
	MOV  AX,0
	ADD  SP,2
	RET
;		k++; 
cc436:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
;		} 
	JMP  cc434
cc435:
;	return k;  /** number of char matched **/ 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,2
	RET
;} 
; 
;/** ascii strings equate **/ 
; 
;astreq(str1,str2,len) char str1[],str2[]; int len; 
astreq:
;{ 
;	int k; 
	PUSH 0
; 
;	k = 0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;	while (k < len) 
cc437:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc438
;		{ 
;		if ((str1[k]) != (str2[k])) break; 
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc439
	JMP  cc438
;		if (str1[k] == 0) break; 
cc439:
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc440
	JMP  cc438
;		if (str2[k] == 0) break; 
cc440:
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc441
	JMP  cc438
;		k++; 
cc441:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
;		} 
	JMP  cc437
cc438:
;	if (an(str1[k])) return 0; 
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL an
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc442
	MOV  AX,0
	ADD  SP,2
	RET
;	if (an(str2[k])) return 0; 
cc442:
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL an
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc443
	MOV  AX,0
	ADD  SP,2
	RET
;	return k; 
cc443:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,2
	RET
;} 
; 
;/** Bool= Ret`1 if matched, .else.`0 **/ 
; 
;match(lit) char *lit; 
match:
;{ 
;	int k; 
	PUSH 0
; 
;	blanks(); 
	CALL blanks
;		/** streq rets`0 if not matched **/ 
;	if (k = streq(line+lptr,lit)) 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL streq
	ADD  SP,4
	POP  BP
	MOV  [BP],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc444
;		{ 
;		lptr = lptr + k;  /** advance ln ptr **/ 
	MOV  AX,[lptr]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	MOV  [lptr],AX
;		return 1; 
	MOV  AX,1
	ADD  SP,2
	RET
;		} 
; 	return 0; 
cc444:
	MOV  AX,0
	ADD  SP,2
	RET
;} 
; 
;/** Bool= Ret`1 if matched str by length, .else.`0 **/ 
; 
;amatch(lit,len) char *lit; int len; 
amatch:
;{ 
;	int k; 
	PUSH 0
; 
;	blanks(); 
	CALL blanks
;	if (k = astreq(line+lptr,lit,len)) 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL astreq
	ADD  SP,6
	POP  BP
	MOV  [BP],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc445
;		{ 
;		lptr = lptr + k; 
	MOV  AX,[lptr]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	MOV  [lptr],AX
;		while (an(chr())) inbyte(); 
cc446:
	CALL chr
	PUSH AX
	CALL an
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc447
	CALL inbyte
	JMP  cc446
cc447:
;		return 1; 
	MOV  AX,1
	ADD  SP,2
	RET
;		} 
;	return 0; 
cc445:
	MOV  AX,0
	ADD  SP,2
	RET
;} 
; 
;blanks() 
blanks:
;{ 
;	while(1) 
cc448:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc449
;		{ 
;		while (chr() == 0) 
cc450:
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc451
;			{ 
;			inline(); 
	CALL inline
;			prepline(); 
	CALL prepline
;			if (eof_flg) break; 
	MOV  AX,[eof_flg]
	CMP  AX,0
	JNE  $+5
	JMP  cc452
	JMP  cc451
;			} 
cc452:
	JMP  cc450
cc451:
;		if (chr() == ' ') gchr(); 
	CALL chr
	PUSH AX
	MOV  AX,32
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc453
	CALL gchr
;		else if (chr() == 9) gchr(); 
	JMP  cc454
cc453:
	CALL chr
	PUSH AX
	MOV  AX,9
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc455
	CALL gchr
;		else return; 
	JMP  cc456
cc455:
	RET
cc456:
cc454:
;		} 
	JMP  cc448
cc449:
;} 
	RET
; 
;/**  SCN_III.C **/ 
;/** Next is SCN_IV.C **/ 
;/************************************************/ 
;/** Re-Codified roughly as:                    **/ 
;/**     I.   Static Storage Defn, main()       **/ 
;/**     II.  Recursive Descent Parser          **/ 
;/**     III. Utility Functions                 **/ 
;/**     IV.  U.I. & I/O                        **/ 
;/**     V.   Backend, NASM Object Output       **/ 
;/************************************************/ 
;/************************************************/ 
;/*          small-c compiler                    */ 
;/*              rev. 1.1                        */ 
;/*            by Ron Cain                       */ 
;/*              (1980)                          */ 
;/************************************************/ 
; 
;/** Fn's in this file **/ 
;/**	ask();		* get user options */ 
;/**	openout();	* get an output file */ 
;/**	openin();	* and initial input file */ 
;/**	header();	* intro code */ 
;/** Logically Parse is here **/ 
;/**	dumplits();	* then dump literal pool */ 
;/** dump global static defs. to output source,  **/ 
;/**  required **/ 
;/**	dumpstatics();	* and all static memory  */ 
;/** original place, added back in **/ 
;/**	errorsummary();	* summarize errors */ 
;/**	trailer();	* follow-up code */ 
;/**	closeout();	* close the output (if any) */ 
;/**	return;		* then exit to system */ 
;/************************************************/ 
;/** doinclude() **/ 
;/************************************************/ 
; 
;/************************************************/ 
;/*      Get options from user                   */ 
;/************************************************/ 
;ask() 
ask:
;{ 
;	int k,num[1]; 
	PUSH 0
	PUSH 0
; 
;	kill_ln();			/* clear input line */ 
	CALL kill_ln
;	nl();nl();nl();		/* print banner */ 
	CALL nl
	CALL nl
	CALL nl
;	pl("     * * *  small-c compiler  * * *"); 
	MOV  AX,cc1+690
	PUSH AX
	CALL pl
	ADD  SP,2
;	nl(); 
	CALL nl
;	pl("              by Ron Cain"); 
	MOV  AX,cc1+726
	PUSH AX
	CALL pl
	ADD  SP,2
;	nl(); 
	CALL nl
;	pl("* NASM Vers c0.2.7, Feb. 2009, s_dubrovich@yahoo.com *"); 
	MOV  AX,cc1+752
	PUSH AX
	CALL pl
	ADD  SP,2
;	nl(); 
	CALL nl
;	/* see if user wants to interleave the c-text */ 
;	/*	in form of comments (for clarity) */ 
;	pl("Do you want the c-text to appear? (hint: y) "); 
	MOV  AX,cc1+807
	PUSH AX
	CALL pl
	ADD  SP,2
;	gets(line);  /* get answer */ 
	MOV  AX,line
	PUSH AX
	CALL gets
	ADD  SP,2
;	ctext = 0;  /* assume no */ 
	MOV  AX,0
	MOV  [ctext],AX
;	if((chr()=='Y')|(chr()=='y')) 
	CALL chr
	PUSH AX
	MOV  AX,89
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	CALL chr
	PUSH AX
	MOV  AX,121
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc457
;		ctext = 1;  /* user said yes */ 
	MOV  AX,1
	MOV  [ctext],AX
; 	/* see if user wants us to allocate static */ 
; 	/*  variables by name in this module	*/ 
; 	/*	(pseudo external capability)	*/ 
; 	pl("Do you wish the globals to be defined? (hint: y) "); 
cc457:
	MOV  AX,cc1+852
	PUSH AX
	CALL pl
	ADD  SP,2
; 	gets(line); 
	MOV  AX,line
	PUSH AX
	CALL gets
	ADD  SP,2
; 	staticflag = 0; 
	MOV  AX,0
	MOV  [staticflag],AX
; 	if ((chr()=='Y')|(chr()=='y')) 
	CALL chr
	PUSH AX
	MOV  AX,89
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	CALL chr
	PUSH AX
	MOV  AX,121
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc458
; 		staticflag = 1;  /* user said yes */ 
	MOV  AX,1
	MOV  [staticflag],AX
;	/* get first allowable number for compiler-generated */ 
; 	/*	labels (in case user will append modules) */ 
; 	while(1) 
cc458:
cc459:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc460
;		{ 
; 		pl("Starting number for labels? (hint: 0) "); 
	MOV  AX,cc1+902
	PUSH AX
	CALL pl
	ADD  SP,2
; 		gets(line); 
	MOV  AX,line
	PUSH AX
	CALL gets
	ADD  SP,2
; 		if (chr() == 0)  /** empty ln buf **/ 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc461
;			{ 
;			num[0] = 0; /** defaults to label_0 **/ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;			break; 
	JMP  cc460
;			} 
;		if (k = number(num)) break; 
cc461:
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	CALL number
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc462
	JMP  cc460
;		} 
cc462:
	JMP  cc459
cc460:
;	nxtlab = num[0]; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  [nxtlab],AX
;	litlab = getlabel();	/* first label=literal pool */  
	CALL getlabel
	MOV  [litlab],AX
;	kill_ln();			/* erase line */ 
	CALL kill_ln
;} 
	ADD  SP,4
	RET
; 
;/************************************************/ 
;/*      Get output filename                     */ 
;/************************************************/ 
;openout() 
openout:
;{ 
;/**	char *tmpp, *fnp, chr; ** fname buf ptr **/ 
; 
;/**	fnp = &fnamebuf[0]; **/ 
;	kill_ln();		/* erase line */ 
	CALL kill_ln
;	fp_out = 0;		/* start with none */ 
	MOV  AX,0
	MOV  [fp_out],AX
;	pl("Output filename? "); /* ask...*/ 
	MOV  AX,cc1+941
	PUSH AX
	CALL pl
	ADD  SP,2
;	gets(line);              /* get a filename */ 
	MOV  AX,line
	PUSH AX
	CALL gets
	ADD  SP,2
;	if (chr() == 0) return; /* none given... */ 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc463
	RET
; 
;/***	tmpp = line; 
;	while (*fnp != 0)  ** fname zr termination ** 
;		{  ** copy file name to stor ** 
;			chr = *tmpp++; 
;			*fnp++ = chr; 
;		} ***/ 
; 
;	if ((fp_out=fopen(line,"w")) == NULL) /* if given, open */ 
cc463:
	MOV  AX,line
	PUSH AX
	MOV  AX,cc1+959
	PUSH AX
	CALL fopen
	ADD  SP,4
	MOV  [fp_out],AX
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc464
;		{ 
;		fp_out = 0;     /* can't open */ 
	MOV  AX,0
	MOV  [fp_out],AX
;		error("Open failure!"); 
	MOV  AX,cc1+961
	PUSH AX
	CALL error
	ADD  SP,2
;		} 
;	kill_ln();			/* erase line */ 
cc464:
	CALL kill_ln
;} 
	RET
; 
;/************************************************/ 
;/*      Get (next) input file                   */ 
;/************************************************/ 
;openin() 
openin:
;{ 
;	fp_in = 0;       /* none to start with */ 
	MOV  AX,0
	MOV  [fp_in],AX
;	while (fp_in == 0) /* any above 1 allowed */ 
cc465:
	MOV  AX,[fp_in]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc466
;		{ 
;		kill_ln();  /* clear line */ 
	CALL kill_ln
;		if (eof_flg) break; /* if user said none */ 
	MOV  AX,[eof_flg]
	CMP  AX,0
	JNE  $+5
	JMP  cc467
	JMP  cc466
;		pl("Input filename? "); 
cc467:
	MOV  AX,cc1+975
	PUSH AX
	CALL pl
	ADD  SP,2
;		gets(line);  /* get a name */ 
	MOV  AX,line
	PUSH AX
	CALL gets
	ADD  SP,2
;		if (chr() == 0) 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc468
;			{ /* none given... */ 
;			eof_flg = 1; 
	MOV  AX,1
	MOV  [eof_flg],AX
;			break; 
	JMP  cc466
;			} 
;		if ((fp_in = fopen(line,"r")) == NULL) 
cc468:
	MOV  AX,line
	PUSH AX
	MOV  AX,cc1+992
	PUSH AX
	CALL fopen
	ADD  SP,4
	MOV  [fp_in],AX
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc469
;			{  /* can't open it */ 
;			fp_in = 0; 
	MOV  AX,0
	MOV  [fp_in],AX
;			pl("Open failure"); 
	MOV  AX,cc1+994
	PUSH AX
	CALL pl
	ADD  SP,2
;			} 
;		} 
cc469:
	JMP  cc465
cc466:
;	kill_ln();		/* erase line */ 
	CALL kill_ln
;	} 
	RET
; 
;/************************************************/ 
;/*      Report errors for user                  */ 
;/************************************************/ 
;errorsummary() 
errorsumma:
;{  	/* see if anything left hanging... */ 
;	if (ncmp) error("missing closing bracket"); 
	MOV  AX,[ncmp]
	CMP  AX,0
	JNE  $+5
	JMP  cc470
	MOV  AX,cc1+1007
	PUSH AX
	CALL error
	ADD  SP,2
;		/* open compound statement ... */ 
;	nl(); 
cc470:
	CALL nl
;	comment(); 
	CALL comment
;	outdec(errcnt);	/* total # errors */ 
	MOV  AX,[errcnt]
	PUSH AX
	CALL outdec
	ADD  SP,2
;	outstr(" errors in compilation."); 
	MOV  AX,cc1+1031
	PUSH AX
	CALL outstr
	ADD  SP,2
;	nl(); 
	CALL nl
;} 
	RET
; 
;/************************************************/ 
;/*      Close the output file                   */ 
;/************************************************/ 
;closeout() 
closeout:
;{ 
;	if (fp_out) fclose(fp_out); /* if open, close it */ 
	MOV  AX,[fp_out]
	CMP  AX,0
	JNE  $+5
	JMP  cc471
	MOV  AX,[fp_out]
	PUSH AX
	CALL fclose
	ADD  SP,2
;	fp_out = 0;  /* mark as closed */ 
cc471:
	MOV  AX,0
	MOV  [fp_out],AX
;} 
	RET
; 
;/************************************************/ 
;/*      Dump the literal pool                   */ 
;/************************************************/ 
;dumplits() 
dumplits:
;{ 
;	int j,k; 
	PUSH 0
	PUSH 0
; 
;	if (litptr == 0) return; /* if nothing there, exit...*/ 
	MOV  AX,[litptr]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc472
	ADD  SP,4
	RET
; 
;	do_dseg(); /** in SCN_V.C for section .dseg **/ 
cc472:
	CALL do_dseg
; 
;	nl(); 
	CALL nl
; 
;	printlabel(litlab); colon(); /* print literal label */ 
	MOV  AX,[litlab]
	PUSH AX
	CALL printlabel
	ADD  SP,2
	CALL colon
;	k = 0;             /* init an index... */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;	while (k < litptr) /*  to loop with */ 
cc473:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,[litptr]
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc474
;		{ 
;		defbyte();  /* pseudo-op to define byte */ 
	CALL defbyte
;		j = 10;     /* max bytes per line */ 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,10
	POP  BP
	MOV  [BP],AX
;		while(j--) 
cc475:
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	DEC  AX
	POP  BP
	MOV  [BP],AX
	INC  AX
	CMP  AX,0
	JNE  $+5
	JMP  cc476
;			{ 
;			outdec((litq[k++] & 127)); 
	MOV  AX,litq
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,127
	POP  BX
	AND  AX,BX
	PUSH AX
	CALL outdec
	ADD  SP,2
;			if ((j == 0) | (k >= litptr)) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,[litptr]
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc477
;				{ 
;				nl(); /* need <cr> */ 
	CALL nl
;				break; 
	JMP  cc476
;				} 
;			outbyte(','); /* separate bytes */ 
cc477:
	MOV  AX,44
	PUSH AX
	CALL outbyte
	ADD  SP,2
;			} 
	JMP  cc475
cc476:
;		} 
	JMP  cc473
cc474:
;} 
	ADD  SP,4
	RET
; 
;/************************************************/ 
;/*      Dump all static variables               */ 
;/*                                              */ 
;/** these are put to outfile, required for nasm */ 
;/** DSegment data ref. defs.,                   */ 
;/** Form; {Name,TIMES,numb,DB 0}               **/ 
;/************************************************/ 
; 
;dumpstatics() 
dumpstatic:
;{ 
;	int j; 
	PUSH 0
; 
;	if (staticflag == 0) return;  /* don't if user said no */ 
	MOV  AX,[staticflag]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc478
	ADD  SP,2
	RET
;/** do SECTION here as well, there may not be lits, above **/ 
;	do_dseg();  /** in SCN_V.C for section .dseg **/ 
cc478:
	CALL do_dseg
;	nl();       /** do in dumplits, it is first **/ 
	CALL nl
;	cptr = startstatic; 
	MOV  AX,symtab
	MOV  [cptr],AX
;	while (cptr < staticptr) 
cc479:
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,[staticptr]
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JB   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc480
;		{ 
;		if (cptr[ob_cl] != ob_fn) 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,4
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc481
;			{  /* do if anything but function */ 
;			   /* output name as label... */ 
;			outstr(cptr); colon(); 
	MOV  AX,[cptr]
	PUSH AX
	CALL outstr
	ADD  SP,2
	CALL colon
;			defstorage();  /* define storage, Times */ 
	CALL defstorage
;				/* calc # bytes lo,hi */ 
;			j = ((cptr[offset]&255) + ((cptr[offset+1]&255) << 8)); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,14
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,255
	POP  BX
	AND  AX,BX
	PUSH AX
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,14
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,255
	POP  BX
	AND  AX,BX
	PUSH AX
	MOV  AX,8
	POP  BX
	MOV  CL,AL
	MOV  AX,BX
	SAL  AX,CL
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
; 
;			outdec(j);	/* need that many */ 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL outdec
	ADD  SP,2
;			if ((cptr[type] == cint) | (cptr[ob_cl] == ob_ptr)) 
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc482
;				defword(); 
	CALL defword
;				else defbyte(); 
	JMP  cc483
cc482:
	CALL defbyte
cc483:
;			ot("0"); /** filler value **/ 
	MOV  AX,cc1+1055
	PUSH AX
	CALL ot
	ADD  SP,2
;			nl(); 
	CALL nl
;			} 
;		cptr = cptr + symsiz;  /** inc thru table **/ 
cc481:
	MOV  AX,[cptr]
	PUSH AX
	MOV  AX,16
	POP  BX
	ADD  AX,BX
	MOV  [cptr],AX
;		} 
	JMP  cc479
cc480:
;} 
	ADD  SP,2
	RET
; 
;/************************************************/ 
;/*      Open an include file                    */ 
;/************************************************/ 
;doinclude() 
doinclude:
;{ 
;	blanks();	/* skip over to name */ 
	CALL blanks
;	if ((fp_in2 = fopen(line+lptr,"r")) == NULL) 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+1057
	PUSH AX
	CALL fopen
	ADD  SP,4
	MOV  [fp_in2],AX
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc484
;		{ 
;		fp_in2 = 0; 
	MOV  AX,0
	MOV  [fp_in2],AX
;		error("Open failure on include file"); 
	MOV  AX,cc1+1059
	PUSH AX
	CALL error
	ADD  SP,2
;		} 
;	kill_ln();		/* clear rest of line */ 
cc484:
	CALL kill_ln
;			/* so next read will come from */ 
;			/* new file (if open */ 
;} 
	RET
; 
;/************************************************/ 
; 
;illname() 
illname:
;{ 
;	error("illegal symbol name"); 
	MOV  AX,cc1+1088
	PUSH AX
	CALL error
	ADD  SP,2
;	junk(); 
	CALL junk
;} 
	RET
; 
;multidef(sname) char *sname; 
multidef:
;{ 
;	error("already defined"); 
	MOV  AX,cc1+1108
	PUSH AX
	CALL error
	ADD  SP,2
;	comment(); 
	CALL comment
;	outstr(sname); nl(); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL outstr
	ADD  SP,2
	CALL nl
;} 
	RET
; 
;needbrack(str) char *str; 
needbrack:
;{ 
;	if (match(str) == 0) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc485
;		{ 
;		error("missing bracket"); 
	MOV  AX,cc1+1124
	PUSH AX
	CALL error
	ADD  SP,2
;		comment(); 
	CALL comment
;		outstr(str); nl(); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL outstr
	ADD  SP,2
	CALL nl
;		} 
;} 
cc485:
	RET
; 
;/** error - not an lvalue **/ 
;needlval()  
needlval:
;{ 
;	error("must be lvalue"); 
	MOV  AX,cc1+1140
	PUSH AX
	CALL error
	ADD  SP,2
;} 
	RET
; 
;/************************************************/ 
;/* Console Output a carriage return and a string*/ 
;/************************************************/ 
;pl(str) char *str; 
pl:
;{ 
;	int k; 
	PUSH 0
; 
;	k = 0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;	putchar(eol); 
	MOV  AX,10
	PUSH AX
	CALL putchar
	ADD  SP,2
;	while (str[k]) putchar(str[k++]); 
cc486:
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc487
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL putchar
	ADD  SP,2
	JMP  cc486
cc487:
;} 
	ADD  SP,2
	RET
; 
; 
;/************************************************/ 
;/** putc <- outbyte <- nl, outstr <- ol        **/ 
;/** Note: null, eof_flg, cause closeout.       **/ 
;/************************************************/ 
; 
;/** Note usage: outbyte must return null or chr **/ 
;outbyte(c) char c; 
outbyte:
;{	/** don't pass null terminator in **/ 
;	if (c == 0) return 0; 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc488
	MOV  AX,0
	RET
;	if (fp_out)  /** output is file fp_out **/ 
cc488:
	MOV  AX,[fp_out]
	CMP  AX,0
	JNE  $+5
	JMP  cc489
;		{ 
;		if ((putc(c,fp_out)) <= 0) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,[fp_out]
	PUSH AX
	CALL putc
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JLE  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc490
;			{ 
;			closeout(); 
	CALL closeout
;			error("Output file error"); 
	MOV  AX,cc1+1155
	PUSH AX
	CALL error
	ADD  SP,2
;			} 
;		} 
cc490:
;	else putchar(c); 
	JMP  cc491
cc489:
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL putchar
	ADD  SP,2
cc491:
;	return c; 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	RET
;} 
; 
;outstr(ptr) char ptr[]; 
outstr:
;{ 
;	int k; 
	PUSH 0
; 
;	k = 0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;  /** Note usage: outbyte must return null or chr **/ 
;	while (outbyte(ptr[k++])); 
cc492:
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL outbyte
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc493
	JMP  cc492
cc493:
;} 
	ADD  SP,2
	RET
; 
;/************************************************/ 
;/** outfname put file name to text out to file **/ 
;/************************************************/ 
;outfname(ptr) char ptr[]; 
outfname:
;{ 
;	int k; 
	PUSH 0
; 
;	k = 0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;	while (ptr[k]) 
cc494:
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc495
;		{  /** not null **/ 
;		if (ptr[k] == '.') break; 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,46
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc496
	JMP  cc495
;		outbyte(ptr[k++]); 
cc496:
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL outbyte
	ADD  SP,2
;		} 
	JMP  cc494
cc495:
;} 
	ADD  SP,2
	RET
; 
;/** was nl() {outbyte(eol);} **/ 
;nl()	{ outbyte(13); outbyte(10); } 
nl:
	MOV  AX,13
	PUSH AX
	CALL outbyte
	ADD  SP,2
	MOV  AX,10
	PUSH AX
	CALL outbyte
	ADD  SP,2
	RET
; 
;tab()	{ outbyte(9); } 
tab:
	MOV  AX,9
	PUSH AX
	CALL outbyte
	ADD  SP,2
	RET
; 
;colon() { outbyte(58); } 
colon:
	MOV  AX,58
	PUSH AX
	CALL outbyte
	ADD  SP,2
	RET
; 
;error(ptr) char ptr[]; 
error:
;{ 
;	int k; 
	PUSH 0
; 
;	comment(); 
	CALL comment
;	outstr(line); 
	MOV  AX,line
	PUSH AX
	CALL outstr
	ADD  SP,2
;	nl(); 
	CALL nl
;	comment(); 
	CALL comment
;	k = 0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;	while (k < lptr) 
cc497:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,[lptr]
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc498
;		{ 
;		if (line[k] == 9) tab(); 
	MOV  AX,line
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,9
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc499
	CALL tab
;		else outbyte(' '); 
	JMP  cc500
cc499:
	MOV  AX,32
	PUSH AX
	CALL outbyte
	ADD  SP,2
cc500:
;		++k; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
;		} 
	JMP  cc497
cc498:
;	outbyte('^'); 
	MOV  AX,94
	PUSH AX
	CALL outbyte
	ADD  SP,2
;	nl(); 
	CALL nl
;	comment(); 
	CALL comment
;	outstr("******  "); 
	MOV  AX,cc1+1173
	PUSH AX
	CALL outstr
	ADD  SP,2
;	outstr(ptr); 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL outstr
	ADD  SP,2
;	outstr("  ******"); 
	MOV  AX,cc1+1182
	PUSH AX
	CALL outstr
	ADD  SP,2
;	nl(); 
	CALL nl
;	++errcnt; 
	MOV  AX,[errcnt]
	INC  AX
	MOV  [errcnt],AX
;} 
	ADD  SP,2
	RET
; 
;ol(ptr) char ptr[]; 
ol:
;{ 
;	ot(ptr); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL ot
	ADD  SP,2
;	nl(); 
	CALL nl
;} 
	RET
; 
;ot(ptr) char ptr[]; 
ot:
;{ 
;	tab(); 
	CALL tab
;	outstr(ptr);	/*outasm*/ 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL outstr
	ADD  SP,2
;} 
	RET
; 
;/************************************************/ 
; 
;outdec(number) int number; 
outdec:
; { 
;	int k,zs; char c; 
	PUSH 0
	PUSH 0
	DEC  SP
; 
;	zs = 0; 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;	k = 10000; 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,10000
	POP  BP
	MOV  [BP],AX
;	if (number < 0) 
	MOV  AX,7
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc501
;		{ 
;		number = (-number); 
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  AX,9
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	NEG  AX
	POP  BP
	MOV  [BP],AX
;		outbyte('-'); 
	MOV  AX,45
	PUSH AX
	CALL outbyte
	ADD  SP,2
;		} 
;	while (k >= 1) 
cc501:
cc502:
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc503
;		{ 
;		c = number / k + '0'; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,9
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,7
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	XCHG AX,BX
	MOV  DX,0
	DIV  BX
	MOV  BX,DX
	PUSH AX
	MOV  AX,48
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AL
;		if ((c != '0') | (k == 1) | (zs)) 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,48
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,5
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc504
;			{ 
;			zs = 1; 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	POP  BP
	MOV  [BP],AX
;			outbyte(c); 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL outbyte
	ADD  SP,2
;			} 
;		number = number % k; 
cc504:
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  AX,9
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,7
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	XCHG AX,BX
	MOV  DX,0
	DIV  BX
	MOV  BX,DX
	XCHG AX,BX
	POP  BP
	MOV  [BP],AX
;		k = k / 10; 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,5
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,10
	POP  BX
	XCHG AX,BX
	MOV  DX,0
	DIV  BX
	MOV  BX,DX
	POP  BP
	MOV  [BP],AX
;		} 
	JMP  cc502
cc503:
; } 
	ADD  SP,5
	RET
; 
; 
;/**  SCN_IV.C **/ 
;/** Next is SCN_V.C **/ 
;/************************************************/ 
;/** Re-Codified roughly as:                    **/ 
;/**     I.   Static Storage Defn, main()       **/ 
;/**     II.  Recursive Descent Parser          **/ 
;/**     III. Utility Functions                 **/ 
;/**     IV.  U.I. & I/O                        **/ 
;/**     V.   Backend, NASM Object Output       **/ 
;/************************************************/ 
;/************************************************/ 
;/*          small-c compiler                    */ 
;/*              rev. 1.1                        */ 
;/*            by Ron Cain                       */ 
;/*              (1980)                          */ 
;/************************************************/ 
;/************************************************/ 
;/** Functions in this file: comment, header,   **/ 
;/** outhexb, trailer, get_static, get_auto     **/ 
;/** put_static, putstk, indirect, swap,        **/ 
;/** mn_ldi_prim, m_push, sa_push_zr, m_pop,    **/ 
;/** sa_swapstk, m_call, m_ret, callstk, jump,  **/ 
;/** testjump, do_seg, defbyte, defstorage,     **/ 
;/** defword, modstk, doublereg, m_add, m_sub,  **/ 
;/** m_mult, m_div, mod, m_or, m_xor, m_and,    **/ 
;/** asr, asl, m_neg, com, m_inc, m_dec, eq, ne,**/ 
;/** lt, le, gt, ult, ule, ugt, uge             **/ 
;/**  SCN_V.C                                   **/ 
;/*   >>>>>> start of cc8 <<<<<<<                */ 
;/************************************************/ 
;/** Nasm Text Output Begins in This Module     **/ 
;/** Primary: 8080.HL 8086.BX,                  **/ 
;/** Static Cell is DSEG                        **/ 
;/** Secondary: 8080.DE 8086.DX                 **/ 
;/**  -made 2 versions, SCCN8.C & SCCNT8.C test **/ 
;/** - appx A 6.1 char are conv to ints, which  **/ 
;/**   are signed values. K&R C.                **/ 
;/** 8:47 PM 7/27/2007 -Changes Primary = AX,   **/ 
;/** Secondary = BX, chg due to sign extend AL  **/ 
;/** 10:34 PM 12/23/2007 --                     **/ 
;/** -Fixed 'indirect' mov prim,[prim]          **/ 
; 
;/************************************************/ 
;/* Begin a comment line for the assembler */ 
;/************************************************/ 
;comment() 
comment:
;{ 
;	outbyte(';'); 
	MOV  AX,59
	PUSH AX
	CALL outbyte
	ADD  SP,2
;} 
	RET
; 
;/************************************************/ 
;/* Print all assembler info before any code     */ 
;/*  is generated.                               */ 
;/************************************************/ 
;header() 
header:
;{ 
;	comment(); 
	CALL comment
;	outstr("Small-c Compiler rev 1.1 re:NASM c0.2.7 Feb. 2009"); 
	MOV  AX,cc1+1191
	PUSH AX
	CALL outstr
	ADD  SP,2
;	nl(); 
	CALL nl
;	ol("[MAP ALL NCCR1.MAP]"); 
	MOV  AX,cc1+1241
	PUSH AX
	CALL ol
	ADD  SP,2
;/**	ol("SECTION .cseg vstart=0");	**/ 
;	ol("SECTION .text vstart=0100h"); /*** .com vers. ***/ 
	MOV  AX,cc1+1261
	PUSH AX
	CALL ol
	ADD  SP,2
;	nl(); 
	CALL nl
;} 
	RET
; 
;/***------------------------------------------***/ 
;/***------------------------------------------***/ 
; 
;outhexw(number) int number; 
outhexw:
; { 
;	leaderx(); 
	CALL leaderx
;	hex(number); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL hex
	ADD  SP,2
; } 
	RET
; 
;hex(x) int x; 
hex:
;{ 
;	hexb(x >> 8); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,8
	POP  BX
	MOV  CL,AL
	MOV  AX,BX
	SAR  AX,CL
	PUSH AX
	CALL hexb
	ADD  SP,2
;	hexb(x); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL hexb
	ADD  SP,2
;} 
	RET
; 
;hexb(x) int x; 
hexb:
;{ 
;	hexn(x >> 4); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,4
	POP  BX
	MOV  CL,AL
	MOV  AX,BX
	SAR  AX,CL
	PUSH AX
	CALL hexn
	ADD  SP,2
;	hexn(x); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL hexn
	ADD  SP,2
;} 
	RET
; 
;hexn(x) int x; 
hexn:
;{ 
;	x = x & 15; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,15
	POP  BX
	AND  AX,BX
	POP  BP
	MOV  [BP],AX
;	if (x < 10) putchar(x + '0'); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,10
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc505
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,48
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL putchar
	ADD  SP,2
;	else putchar(x - 10 + 'A'); 
	JMP  cc506
cc505:
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,10
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	PUSH AX
	MOV  AX,65
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL putchar
	ADD  SP,2
cc506:
;} /** EO outhexw **/ 
	RET
; 
;/***------------------------------------------***/ 
; 
;outhexb(number) int number; 
outhexb:
;{ 
;	leaderx(); 
	CALL leaderx
;	hexb(number & 255); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,255
	POP  BX
	AND  AX,BX
	PUSH AX
	CALL hexb
	ADD  SP,2
;} /** EO outhexb **/ 
	RET
; 
;/***------------------------------------------***/ 
; 
;leaderx() 
leaderx:
;{ 
;/**	ot("0x"); **/ 
;	putchar('0'); 
	MOV  AX,48
	PUSH AX
	CALL putchar
	ADD  SP,2
;	putchar('x'); 
	MOV  AX,120
	PUSH AX
	CALL putchar
	ADD  SP,2
;}  /** EO leaderx() **/ 
	RET
; 
;/***------------------------------------------***/ 
;/**--------------------------------------------**/ 
; 
;/***------------------------------------------***/ 
;/* Print any assembler stuff needed after all code */ 
;trailer() 
trailer:
;{ 
;	comment(); 
	CALL comment
;	ol("-= END =-"); 
	MOV  AX,cc1+1288
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/***--------------------------------------------------***/ 
;/* Fetch a static memory cell into the primary register */ 
;/** Primary 8080.HL 8086.AX, Static Cell is DSEG       **/ 
;/** If byte, then affirm it is sign extended to wordsz **/ 
; 
;get_static(sym) char *sym; 
get_static:
;{ 
;/***	ol("  ;+; get_static DS tag..");  ***/ 
;	if ((sym[ob_cl] != ob_ptr) & (sym[type] == cchar)) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,1
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc507
;		{ 
;		ot("MOV  AL,["); 
	MOV  AX,cc1+1298
	PUSH AX
	CALL ot
	ADD  SP,2
;		outstr(sym + name); /** symbol tbl + offset **/ 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL outstr
	ADD  SP,2
;		outstr("]"); 
	MOV  AX,cc1+1308
	PUSH AX
	CALL outstr
	ADD  SP,2
;		nl(); 
	CALL nl
;		  /** sign extension **/ 
;		ol("CBW"); 
	MOV  AX,cc1+1310
	PUSH AX
	CALL ol
	ADD  SP,2
;		} 
;	else	{ 
	JMP  cc508
cc507:
;		ot("MOV  AX,["); 
	MOV  AX,cc1+1314
	PUSH AX
	CALL ot
	ADD  SP,2
;		outstr(sym + name); /** symbol tbl + offset **/ 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL outstr
	ADD  SP,2
;		outstr("]"); 
	MOV  AX,cc1+1324
	PUSH AX
	CALL outstr
	ADD  SP,2
;		nl(); 
	CALL nl
;		} 
cc508:
;} 
	RET
; 
;/* Fetch the address of the specified symbol */ 
;/** the Stack Address of the passed Parameter, **/ 
;/** place that reference into the Primary Cell **/ 
; 
;get_auto(sym) char *sym; 
get_auto:
;{ 
;/***	ol("  ;+; get_auto SP.."); ***/ 
;	mn_ldi_prim();  /** mnem LD Imm Primary **/ 
	CALL mn_ldi_pri
;	outdec(((sym[offset] & 255) + 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,14
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,255
	POP  BX
	AND  AX,BX
	PUSH AX
;		((sym[offset+1] & 255) << 8)) - c_sp); 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,14
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,255
	POP  BX
	AND  AX,BX
	PUSH AX
	MOV  AX,8
	POP  BX
	MOV  CL,AL
	MOV  AX,BX
	SAL  AX,CL
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,[c_sp]
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	PUSH AX
	CALL outdec
	ADD  SP,2
;	nl(); 
	CALL nl
;	ol("ADD  AX,SP"); 
	MOV  AX,cc1+1326
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Store the primary register into the specified */ 
;/*  static memory cell                           */ 
; 
;put_static(sym) char *sym; 
put_static:
;{ 
;/***	ol("  ;+; put_static DS.."); ***/ 
;	if ((sym[ob_cl] != ob_ptr) & (sym[type] == cchar)) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,1
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc509
;		{ 
;		ot("MOV  ["); 
	MOV  AX,cc1+1337
	PUSH AX
	CALL ot
	ADD  SP,2
;		outstr(sym + name); /** symbol tbl + offset **/ 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL outstr
	ADD  SP,2
;		outstr("],AL"); 
	MOV  AX,cc1+1344
	PUSH AX
	CALL outstr
	ADD  SP,2
;		nl(); 
	CALL nl
;		} 
;	else	{ 
	JMP  cc510
cc509:
;		ot("MOV  ["); 
	MOV  AX,cc1+1349
	PUSH AX
	CALL ot
	ADD  SP,2
;		outstr(sym + name); /** symbol tbl + offset **/ 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL outstr
	ADD  SP,2
;		outstr("],AX"); 
	MOV  AX,cc1+1356
	PUSH AX
	CALL outstr
	ADD  SP,2
;		nl(); 
	CALL nl
;		} 
cc510:
;} 
	RET
; 
;/* Store the specified object type in the primary register */ 
;/*  at the address on the top of the stack                 */ 
; 
;putstk(typeobj) char typeobj; 
putstk:
;/**{pop();if(typeobj==cchar)call("ccpchar");else call("ccpint");}**/ 
;{ 
;/***	ol("  ;+; putstk DS:[tos].."); ***/ 
;	sa_pop();	/** BX <- Addr.TOS **/ 
	CALL sa_pop
;			/** Effective Address must be in BX **/ 
;	if (typeobj == cchar) ol("MOV  [BX],AL"); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,1
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc511
	MOV  AX,cc1+1361
	PUSH AX
	CALL ol
	ADD  SP,2
;	else ol("MOV  [BX],AX"); 
	JMP  cc512
cc511:
	MOV  AX,cc1+1374
	PUSH AX
	CALL ol
	ADD  SP,2
cc512:
;} 
	RET
; 
;/*** Store the specified object type in the primary register ***/ 
;/***  at the SS:address found currently on the top of the stack ***/ 
; 
;putssstk(typeobj) char typeobj; 
putssstk:
;/**{pop();if(typeobj==cchar)call("ccpchar");else call("ccpint");}**/ 
;{ 
;/***	ol("  ;+; putstk SS:[tos].."); ***/ 
;/**--	sa_pop();	-** BX <- Addr.TOS **/ 
;			/** Effective Address must be in BP **/ 
;	ol("POP  BP"); 
	MOV  AX,cc1+1387
	PUSH AX
	CALL ol
	ADD  SP,2
;	c_sp = c_sp + 2; 
	MOV  AX,[c_sp]
	PUSH AX
	MOV  AX,2
	POP  BX
	ADD  AX,BX
	MOV  [c_sp],AX
; 
;/**--	ol("MOV  BP,BX"); -**/ 
;	if (typeobj == cchar) ol("MOV  [BP],AL"); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,1
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc513
	MOV  AX,cc1+1395
	PUSH AX
	CALL ol
	ADD  SP,2
;	else ol("MOV  [BP],AX"); 
	JMP  cc514
cc513:
	MOV  AX,cc1+1408
	PUSH AX
	CALL ol
	ADD  SP,2
cc514:
;} 
	RET
; 
;/* Fetch the specified object type indirect through the */ 
;/*  primary register into the primary register          */ 
;/** one caller, rvalue, ie. rdvalue, replaced with stk_indi **/ 
; 
;/**--indirect(typeobj) char typeobj; --**/ 
;/**{if (typeobj==cchar)call("ccgchar");else call("ccgint");}**/ 
;/**-- {ol("  ;+; get DS:[primary]->primary, tag msg."); --**/ 
;/**-- if (typeobj==cchar){ol("MOV  BX,AX");ol("MOV  AL,[Byte BX]"); --**/ 
;/**-- ol("CBW");}else{ol("MOV  BX,AX");ol("MOV  AX,[BX]");}} --**/ 
; 
;/*** Primary indirect dereferencing Stack ***/ 
;stk_indi(typeobj) char typeobj; 
stk_indi:
;	/**{if (typeobj==cchar)call("ccgchar");else call("ccgint");}**/ 
;{ 
;/***	ol("  ;+; get SS:[primary]->primary,.."); ***/ 
;	if (typeobj==cchar)  
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,1
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc515
;		{ 
;		ol("MOV  BP,AX"); 
	MOV  AX,cc1+1421
	PUSH AX
	CALL ol
	ADD  SP,2
;		ol("MOV  AL,[Byte BP]"); 
	MOV  AX,cc1+1432
	PUSH AX
	CALL ol
	ADD  SP,2
;		ol("CBW"); 
	MOV  AX,cc1+1450
	PUSH AX
	CALL ol
	ADD  SP,2
;		} 
;	else	{ 
	JMP  cc516
cc515:
;		ol("MOV  BP,AX"); 
	MOV  AX,cc1+1454
	PUSH AX
	CALL ol
	ADD  SP,2
;		ol("MOV  AX,[BP]"); 
	MOV  AX,cc1+1465
	PUSH AX
	CALL ol
	ADD  SP,2
;		} 
cc516:
;} 
	RET
; 
;/* Swap the primary and secondary registers */ 
;swap() { ol("XCHG AX,BX"); } 
swap:
	MOV  AX,cc1+1478
	PUSH AX
	CALL ol
	ADD  SP,2
	RET
; 
;/* Print partial instruction to get an immediate value */ 
;/*	into the primary register */ 
;mn_ldi_prim() { ot("MOV  AX,"); } 
mn_ldi_pri:
	MOV  AX,cc1+1489
	PUSH AX
	CALL ot
	ADD  SP,2
	RET
; 
;/* Push the primary register onto the stack */ 
;/** 24 callers  sa_ means sematic action   **/ 
;sa_push() 
sa_push:
;{ 
;	ol("PUSH AX"); 
	MOV  AX,cc1+1498
	PUSH AX
	CALL ol
	ADD  SP,2
;	c_sp=c_sp-2; 
	MOV  AX,[c_sp]
	PUSH AX
	MOV  AX,2
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	MOV  [c_sp],AX
;} 
	RET
; 
;/** Push Zero onto the stack		**/ 
;/** 10:30 AM 8/5/2007			**/ 
;/** unlinked from callfunction() 11:54 AM 8/5/2007 **/ 
;/** sa_push_zr() { ol("PUSH 0"); c_sp = c_sp - 2; } **/ 
; 
;/* Pop the top of the stack into the secondary register */ 
;/** 17 callers **/ 
;sa_pop() 
sa_pop:
;{ 
;	ol("POP  BX"); 
	MOV  AX,cc1+1506
	PUSH AX
	CALL ol
	ADD  SP,2
;	c_sp = c_sp + 2; 
	MOV  AX,[c_sp]
	PUSH AX
	MOV  AX,2
	POP  BX
	ADD  AX,BX
	MOV  [c_sp],AX
;} 
	RET
; 
;/* Swap the primary register and the top of the stack */ 
;sa_swapstk() 
sa_swapstk:
;{ 
;	ol("XCHG [SP],AX"); 
	MOV  AX,cc1+1514
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Call the specified subroutine name */ 
;/** 1 caller **/ 
;sa_call(sname) char *sname; 
sa_call:
;{ 
;	ot("CALL "); 
	MOV  AX,cc1+1527
	PUSH AX
	CALL ot
	ADD  SP,2
;	outstr(sname); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL outstr
	ADD  SP,2
;	nl(); 
	CALL nl
;} 
	RET
; 
;/* Return from subroutine */ 
;/** 2 callers **/ 
;sa_ret() 
sa_ret:
;{ 
;	ol("RET"); 
	MOV  AX,cc1+1533
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Perform subroutine call to value on top of stack */ 
;/** one caller **/ 
;sa_callstk() 
sa_callstk:
;{ 
;	mn_ldi_prim();  /** mnem LD Imm Primary **/ 
	CALL mn_ldi_pri
;	outstr("$+5"); 
	MOV  AX,cc1+1537
	PUSH AX
	CALL outstr
	ADD  SP,2
;	nl(); 
	CALL nl
;	sa_swapstk(); 
	CALL sa_swapstk
;	ol("CALL [AX]"); 
	MOV  AX,cc1+1541
	PUSH AX
	CALL ol
	ADD  SP,2
;	c_sp = c_sp + 2; 
	MOV  AX,[c_sp]
	PUSH AX
	MOV  AX,2
	POP  BX
	ADD  AX,BX
	MOV  [c_sp],AX
;} 
	RET
; 
;/* Jump to specified internal label number */ 
;/** 4 Callers **/ 
;sa_jump(label) int label; 
sa_jump:
;{ 
;	ot("JMP  "); 
	MOV  AX,cc1+1551
	PUSH AX
	CALL ot
	ADD  SP,2
;	printlabel(label); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL printlabel
	ADD  SP,2
;	nl(); 
	CALL nl
;} 
	RET
; 
;/* Test the primary register and jump if false to label */ 
;/** Primary holds Bool on entry 1=TRUE, 0=FALSE the jump **/ 
;/** often is not short, so change this... **/ 
;/** testjump(label)int label;{ol("MOV  CX,AX"); **/ 
;/** ot("JCXZ ");printlabel(label);nl();} **/ 
; 
;testjump(label) int label; 
testjump:
;{ 
;	ol("CMP  AX,0"); /** ZF if equal **/ 
	MOV  AX,cc1+1557
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JNE  $+5"); /** next is past, jmp label **/ 
	MOV  AX,cc1+1567
	PUSH AX
	CALL ol
	ADD  SP,2
;	ot("JMP  "); 
	MOV  AX,cc1+1576
	PUSH AX
	CALL ot
	ADD  SP,2
;	printlabel(label); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL printlabel
	ADD  SP,2
;	nl(); 
	CALL nl
;} 
	RET
; 
;/** .dseg section **/ 
; 
;do_dseg() 
do_dseg:
;{ 
;  ot(";-; SECTION .dseg align=16 ;; commented out for .com version"); 
	MOV  AX,cc1+1582
	PUSH AX
	CALL ot
	ADD  SP,2
;} 
	RET
; 
; 
;/* Print pseduo-op to define a byte */ 
; 
;defbyte() 
defbyte:
;{ 
;	ot("DB "); 
	MOV  AX,cc1+1643
	PUSH AX
	CALL ot
	ADD  SP,2
;} 
	RET
; 
;/* Print psedo-op to define storage */ 
;/** Called by CC1 dumpstatics(), both will need modifications **/ 
;/**   form: times nn d_sz val **/ 
; 
;defstorage() 
defstorage:
;{ 
;	ot("TIMES "); /**ot("DS ");**/ 
	MOV  AX,cc1+1647
	PUSH AX
	CALL ot
	ADD  SP,2
;} 
	RET
; 
;/* Print pseudo-op to define a word */ 
; 
;defword() 
defword:
;{ 
;	ot("DW "); 
	MOV  AX,cc1+1654
	PUSH AX
	CALL ot
	ADD  SP,2
;} 
	RET
; 
;/* Modify the stack pointer to the new value indicated */ 
;/** 9 callers, pertains to storage class auto, stack index **/ 
; 
;sa_modstk(newsp) int newsp; 
sa_modstk:
;{ 
;	int k; 
	PUSH 0
; 
;	k = newsp - c_sp; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,[c_sp]
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	POP  BP
	MOV  [BP],AX
;	if (k == 0) return newsp; 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc517
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,2
	RET
;	if (k > +0) 
cc517:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JG   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc518
;		{ 
;		ot("ADD  SP,"); 
	MOV  AX,cc1+1658
	PUSH AX
	CALL ot
	ADD  SP,2
;		outdec(k); 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL outdec
	ADD  SP,2
;		nl(); 
	CALL nl
;		return newsp; 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,2
	RET
;		} 
;	if (k < 0) 
cc518:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc519
;		{ 
;		if (k > -7) 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,7
	NEG  AX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JG   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc520
;			{ 
;			if ( k & 1) 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc521
;				{ 
;				ol("DEC  SP"); 
	MOV  AX,cc1+1667
	PUSH AX
	CALL ol
	ADD  SP,2
;				k++; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
;				} 
;			while(k) 
cc521:
cc522:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc523
;				{ 
;			/**	ol("  ;+; sa_modstk.."); **/ 
;			/**	ol("PUSH AX");          **/ 
;				ol("PUSH 0"); 
	MOV  AX,cc1+1675
	PUSH AX
	CALL ol
	ADD  SP,2
;				k = k + 2; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;				} 
	JMP  cc522
cc523:
;			return newsp; 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,2
	RET
;			} 
;		} 
cc520:
; 
;/* Modify the stack pointer to the new value indicated */ 
;/** 9 callers, pertains to local stack index **/ 
;/* sa_modstk(newsp)int newsp;{int k;k=newsp-c_sp; **/ 
;/* if(k==0)return newsp;if(k>+0){if(k<7){if(k&1)**/ 
;/** handle odd alignment **/ 
;/* {ol("INC  SP");k--;}while(k)**/ 
;/** throw away **/ 
;/** without overwriting primary */ 
;/* {ol("POP  DX");k=k-2;}return newsp;}} **/ 
;/* if(k<0){if(k>-7){if(k&1){ol("DEC  SP");k++;}while(k){ol("PUSH AX"); **/ 
;/* k=k+2;}return newsp;}} **/ 
; 
;/* Modify the stack pointer to the new value indicated */ 
;/* modstk(newsp)int newsp;{int k;k=newsp-Zsp; **/ 
;/* if(k==0)return newsp;ot("ADD SP,");outdec(k); **/ 
;/* nl();return newsp;} **/ 
; 
;/** Have a closer look at the following for improvement **/ 
; /**	ol("  ;+; sa_modstk-b.."); **/ 
; /**	swap();         * Swap the primary and secondary registers */ 
; /**	mn_ldi_prim();  ** mnem LD Imm Primary **/ 
; /**	outdec(k); nl(); 
;	ol("ADD  AX,SP"); 
;	ol("MOV  SP,AX"); 
;	swap();         * Swap the primary and secondary registers * 
;	return newsp;  **/ 
;/*** 
;	ot("MOV  BP,"); 
;	outdec(k); nl(); 
;	ol("ADD  BP,SP"); 
;	ol("MOV  SP,BP");  ***/ 
; 
;	ot("ADD  SP,"); 
cc519:
	MOV  AX,cc1+1682
	PUSH AX
	CALL ot
	ADD  SP,2
;	outdec(k); nl(); 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL outdec
	ADD  SP,2
	CALL nl
;	return newsp; 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,2
	RET
;} 
; 
;/* Double the primary register */ 
; 
;doublereg() 
doublereg:
;{ 
;	ol("ADD  AX,AX"); 
	MOV  AX,cc1+1691
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Add the primary and secondary registers */ 
;/*	(results in primary) */ 
; 
;m_add() 
m_add:
;{ 
;	ol("ADD  AX,BX"); 
	MOV  AX,cc1+1702
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Substract the primary register from the secondary */ 
;/*	(results in the primary) */ 
;/** sub() {call("ccsub");} **/ 
; 
;m_sub() 
m_sub:
;{ 
;	ol("SUB  BX,AX"); /** BX-AX -> BX **/ 
	MOV  AX,cc1+1713
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,BX"); 
	MOV  AX,cc1+1724
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Multiply the primary and secondary registers */ 
;/*	(results in primary) */ 
;/** mult() {call("ccmult");} **/ 
;/** Unsigned Mult re:AX*BX -> DX:AX **/ 
; 
;m_mult() { ol("MUL  BX"); } 
m_mult:
	MOV  AX,cc1+1735
	PUSH AX
	CALL ol
	ADD  SP,2
	RET
; 
;/* Divide the secondary by the primary */ 
;/* (quotient in primary, remainder in secondary) */ 
;/*** 21-Jul-08 07:41:16 PM add signed integer divide ***/ 
;/**** 24-Jul-08 02:51:10 PM force DX := 0, prevent exception ****/ 
;/** div() {call("ccdiv");} **/ 
;/** swap Primary&Secondary **/ 
;/** Unsigned Div re:DX.0:AX/BX -> AX.quot DX.rem **/ 
;/** mov remainder into Secondary		**/ 
; 
;m_div() 
m_div:
;{ 
;	ol("XCHG AX,BX"); 
	MOV  AX,cc1+1743
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  DX,0"); /** clear extended reg DX **/ 
	MOV  AX,cc1+1754
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("DIV  BX");   /** DX has remainder **/ 
	MOV  AX,cc1+1764
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  BX,DX"); 
	MOV  AX,cc1+1772
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;m_sdiv() 
m_sdiv:
;{ 
;	ol("XCHG AX,BX"); 
	MOV  AX,cc1+1783
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("CWD");      /** sign extend into DX **/ 
	MOV  AX,cc1+1794
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("IDIV BX");  /** DX has remainder **/ 
	MOV  AX,cc1+1798
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  BX,DX"); 
	MOV  AX,cc1+1806
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Compute remainder (mod) of secondary register dividend */ 
;/*	by the primary */ 
;/*	(remainder in primary, quotient in secondary) */ 
; 
;mod() { m_div(); swap(); } 
mod:
	CALL m_div
	CALL swap
	RET
; 
;/* Inclusive 'or' the primary and secondary registers */ 
;/*	(results in the primary) */ 
;/** or() {call("ccor");} **/ 
; 
;m_or() { ol("OR   AX,BX"); } 
m_or:
	MOV  AX,cc1+1817
	PUSH AX
	CALL ol
	ADD  SP,2
	RET
; 
;/* Exclusive 'or' the primary and secondary registers */ 
;/*	(results in the primary) */ 
;/** xor() {call("ccxor");} **/ 
; 
;m_xor() { ol("XOR  AX,BX"); } 
m_xor:
	MOV  AX,cc1+1828
	PUSH AX
	CALL ol
	ADD  SP,2
	RET
; 
;/* 'And' the primary and secondary registers */ 
;/*	(results in primary) */ 
;/** and() {call("ccand");} **/ 
; 
;m_and() { ol("AND  AX,BX"); } 
m_and:
	MOV  AX,cc1+1839
	PUSH AX
	CALL ol
	ADD  SP,2
	RET
; 
;/* Arithmetic shift right the secondary register number of */ 
;/*	times in the primary (results in primary) */ 
;/** asr() {call("ccasr");} **/ 
; 
;asr() 
asr:
;{ 
;	ol("MOV  CL,AL"); /** BH is disregarded **/ 
	MOV  AX,cc1+1850
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,BX"); 
	MOV  AX,cc1+1861
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("SAR  AX,CL"); 
	MOV  AX,cc1+1872
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Arithmetic left shift the secondary register number of */ 
;/*	times in the primary (results in primary) */ 
;/** asl() {call("ccasl");} **/ 
; 
;asl() 
asl:
;{ 
;	ol("MOV  CL,AL"); /** BH is disregarded **/ 
	MOV  AX,cc1+1883
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,BX"); 
	MOV  AX,cc1+1894
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("SAL  AX,CL"); 
	MOV  AX,cc1+1905
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Form two's complement of primary register */ 
;/** neg() {call("ccneg");} **/ 
; 
;m_neg() { ol("NEG  AX"); } 
m_neg:
	MOV  AX,cc1+1916
	PUSH AX
	CALL ol
	ADD  SP,2
	RET
; 
;/* Form one's complement of primary register */ 
;/** com() {call("cccom");} **/ 
; 
;com() { ol("NOT  AX"); } 
com:
	MOV  AX,cc1+1924
	PUSH AX
	CALL ol
	ADD  SP,2
	RET
; 
;/* Increment the primary register by one */ 
;/** inc() {ol("INX H");} **/ 
; 
;m_inc() { ol("INC  AX"); } 
m_inc:
	MOV  AX,cc1+1932
	PUSH AX
	CALL ol
	ADD  SP,2
	RET
; 
;/* Decrement the primary register by one */ 
;/** dec() {ol("DCX H");} **/ 
; 
;m_dec() { ol("DEC  AX"); } 
m_dec:
	MOV  AX,cc1+1940
	PUSH AX
	CALL ol
	ADD  SP,2
	RET
; 
;/* Following are the conditional operators */ 
;/* They compare the secondary register against the primary */ 
;/* and put a literal 1 in the primary if the condition is */ 
;/* true, otherwise they clear the primary register */ 
;/** Here for NASM, I've inlined these fns instead of	**/ 
;/**  leaving them for an include *.* 			**/ 
; 
;/* Test for equal */ 
; 
;eq()	/** {call("cceq");} **/ 
eq:
;{ 
;	ol("CMP  BX,AX");  /** sets flags **/ 
	MOV  AX,cc1+1948
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,1");   /** assume true **/ 
	MOV  AX,cc1+1959
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JZ   $+5"); 
	MOV  AX,cc1+1969
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,0");   /** is false **/ 
	MOV  AX,cc1+1978
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Test for not equal */ 
; 
;ne()	/** {call("ccne");} **/ 
ne:
;{ 
;	ol("CMP  BX,AX");  /** sets flags **/ 
	MOV  AX,cc1+1988
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,1");   /** assume true **/ 
	MOV  AX,cc1+1999
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JNZ  $+5"); 
	MOV  AX,cc1+2009
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,0");   /** is false **/ 
	MOV  AX,cc1+2018
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Test for less than (signed) */ 
; 
;lt()	/** {call("cclt");} **/ 
lt:
;{ 
;	ol("CMP  BX,AX");  /** sets flags **/ 
	MOV  AX,cc1+2028
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,1");   /** assume true **/ 
	MOV  AX,cc1+2039
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JL   $+5"); 
	MOV  AX,cc1+2049
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,0");   /** is false **/ 
	MOV  AX,cc1+2058
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Test for less than or equal to (signed) */ 
; 
;le()	/** {call("ccle");} **/ 
le:
;{ 
;	ol("CMP  BX,AX");  /** sets flags **/ 
	MOV  AX,cc1+2068
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,1");   /** assume true **/ 
	MOV  AX,cc1+2079
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JLE  $+5"); 
	MOV  AX,cc1+2089
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,0");   /** is false **/ 
	MOV  AX,cc1+2098
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Test for greater than (signed) */ 
; 
;gt()	/** {call("ccgt");} **/ 
gt:
;{ 
;	ol("CMP  BX,AX");  /** sets flags **/ 
	MOV  AX,cc1+2108
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,1");   /** assume true **/ 
	MOV  AX,cc1+2119
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JG   $+5"); 
	MOV  AX,cc1+2129
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,0");   /** is false **/ 
	MOV  AX,cc1+2138
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Test for greater than or equal to (signed) */ 
; 
;ge()	/** {call("ccge");} **/ 
ge:
;{ 
;	ol("CMP  BX,AX");  /** sets flags **/ 
	MOV  AX,cc1+2148
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,1");   /** assume true **/ 
	MOV  AX,cc1+2159
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JGE  $+5"); 
	MOV  AX,cc1+2169
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,0");   /** is false **/ 
	MOV  AX,cc1+2178
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Test for less than (unsigned) */ 
; 
;ult()	/** {call("ccult");} **/ 
ult:
;{ 
;	ol("CMP  BX,AX");  /** sets flags **/ 
	MOV  AX,cc1+2188
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,1");   /** assume true **/ 
	MOV  AX,cc1+2199
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JB   $+5"); 
	MOV  AX,cc1+2209
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,0");   /** is false **/ 
	MOV  AX,cc1+2218
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Test for less than or equal to (unsigned) */ 
; 
;ule()	/** {call("ccule");} **/ 
ule:
;{ 
;	ol("CMP  BX,AX");  /** sets flags **/ 
	MOV  AX,cc1+2228
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,1");   /** assume true **/ 
	MOV  AX,cc1+2239
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JBE  $+5"); 
	MOV  AX,cc1+2249
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,0");   /** is false **/ 
	MOV  AX,cc1+2258
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Test for greater than (unsigned) */ 
; 
;ugt()	/** {call("ccugt");} **/ 
ugt:
;{ 
;	ol("CMP  BX,AX");  /** sets flags **/ 
	MOV  AX,cc1+2268
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,1");   /** assume true **/ 
	MOV  AX,cc1+2279
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JA   $+5"); 
	MOV  AX,cc1+2289
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,0");   /** is false **/ 
	MOV  AX,cc1+2298
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Test for greater than or equal to (unsigned) */ 
; 
;uge()	/** {call("ccuge");} **/ 
uge:
;{ 
;	ol("CMP  BX,AX");  /** sets flags **/ 
	MOV  AX,cc1+2308
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,1");   /** assume true **/ 
	MOV  AX,cc1+2319
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JAE  $+5"); 
	MOV  AX,cc1+2329
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,0");   /** is false **/ 
	MOV  AX,cc1+2338
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
;/***------------------------------------------***/ 
;/**-------------------------------------**/ 
;/** extern functions needed by small-c: **/ 
;/** fopen()				**/ 
;/** fclose()				**/ 
;/** putchar()				**/ 
;/** getc()				**/ 
;/** putc()				**/ 
;/** gets()				**/ 
;/**	Example..			**/ 
;/** CALL gets | gets(line);		**/ 
;/** CALL fopen | fopen(line,"w")	**/ 
;/** CALL fclose | fclose(fp_out);	**/ 
;/*	<<<<< End of Compiler >>>>>	 */ 
;/* #include IOC5.C * when self compiling */ 
;/* Otherwise, the PowerC pcdos io lib is */ 
;/* used: stdio.h			**/ 
;/** SCNXa.C is PowerC Level 1 Compile	**/ 
;/** SCNX.C is IOC5.C Level 2 Self-Compile*/ 
;/** #include IOC5.C ** for self-compile **/ 
;/** Name changed to...			**/ 
;#include C5LIB.C /** for self-compile	**/ 
;/*********************************************************/ 
;/** Module: C5LIB.C  By: s_dubrovich@yahoo.com		**/ 
;/** Last: 1:46 PM 8/15/2008				**/ 
;/** Vers: 0.2.3						**/ 
;/**  modified puts();					**/ 
;/*********************************************************/ 
;/** Module: C5LIB.C  By: s_dubrovich@yahoo.com		**/ 
;/** Last:  10:29 PM 8/14/2008				**/ 
;/** Vers: 0.2.2						**/ 
;/**  Chg to C5LIB.C for further development.  Added in	**/ 
;/**  mainmain() for initialization of user source.	**/ 
;/**  file Was IOC5.C					**/ 
;/**  Added PAUSE_YES Conditional exit			**/ 
;/**  Added puts();					**/ 
;/*********************************************************/ 
;/** IOC5.C -- stripped main for small-c include		**/ 
;/** Call 5 IO Interface Library				**/ 
;/*********************************************************/ 
;/** Last: 30-Jul-08 05:08:51 PM.			**/ 
;/** Prev: 08:15:42 AM 17-Jul-08				**/ 
;/** Vers: 0.1.7	modified re_ubuff()			**/ 
;/** chg index update for ol(ptr)			**/ 
;/*********************************************************/ 
;/** Last: 07:32:44 AM 15-Jul-08				**/ 
;/** Vers: 0.1.5 -filter 0Dh -> 20h for eol problem    ****/ 
;/**  chgd getc() to filter & 127, or, ret EOF         ****/ 
;/*********************************************************/ 
;/** Last: 05:23:25 AM 07/13/2008 01:31:05 PM 07/12/2008	**/ 
;/** Init: 11:18 PM 7/5/2008				**/ 
;/*********************************************************/ 
;/** CALL5_IO.C test file & IO Functions for small-c	**/ 
;/** Last: 11:44 AM 7/5/2008 :: 11:28 AM 7/4/2008	**/ 
;/** Init: 7:24 AM 5/31/2008				**/ 
;/** Vers: 0.1.0  By: s_dubrovich@yahoo.com		**/ 
;/** Goal: minimal IO to Call_5 interface to run small-c **/ 
;/** Note: Only Character, not binary Files.		**/ 
;/** -Cloned From SINKIO01.C as IO LIB base Fn's		**/ 
;/** -includes some testing code as main()		**/ 
;/*********************************************************/ 
;/** NOTE: for cmd.exe edit NASM src for vstart=0100h,   **/ 
;/** and comment out ';;' the two SECTION .dseg align=16 **/ 
;/** directives so that the pcdos 'small' model is used. **/ 
;/*********************************************************/ 
;/** Req'd IO Functions for Small-c			**/ 
;/**getc(){;} gets(){;} putc(){;}  			**/ 
;/**putchar(){;} fopen(){;} fclose(){;}			**/ 
; 
;/* 
;** STDIO.H -- Standard Small-C Definitions --  
;*/ 
;#define stdin    0 
;#define stdout   1 
;#define stderr   2 
;#define ERR   (-2) 
;#define EOF   (-1) 
;#define YES      1 
;#define NO       0 
;/** #define NULL     0 **/ 
;#define BAD	(-1) 
;#define CR      13 
;#define LF      10 
;#define BELL     7 
;#define SPACE  ' ' 
;#define NEWLINE LF 
; 
;#define EOL 10   /** LF **/ 
;#define NL  10 
;#define TAB  9 
;#define EOL2    13 /*;end-of-line character          */ 
;                   /*  (=carriage return,CR)         */ 
;#define CTRLZ	26 /** 1Ah, Ctrl-Z, cpm textfile EOF */ 
;/**-----------------------------------------------------**/ 
;#define MAX_IOD   6 /** Max Streams, incl stdin,out,err **/ 
;#define FILE  char /** Cain's C doesn't know struc FILE **/ 
;#define VERBOSE   1 /** debugging, report runtime state **/ 
;/**-----------------------------------------------------**/ 
;/** #define PCDOS 1 * IBM PC DOS, Same as CP/M-80   */ 
;/** #if PCDOS		*****************************/ 
;#define EXIT	   0	/* Exit to BDOS		    */ 
;#define CONIN	   1	/* direct echoing con input */ 
;#define CONOUT	   2	/* Direct console output    */ 
;#define LSTOUT	   5	/* Direct list device output*/ 
;#define CONIO	   6	/* Direct console I/O	    */ 
;#define C_WRITESTR 9	/* Console string output    */ 
;#define CONBUF	   10	/* Read console buffer	    */ 
;#define C_STAT	   11	/* Get console status	    */ 
;#define OPEN	   15	/* OPEN a disk file	    */ 
;#define CLOSE	   16	/* Close a disk file	    */ 
;#define SEARCHF	   17	/* Search for first	    */ 
;#define SEARCHN	   18	/* Search for next	    */ 
;#define DELETE	   19	/* Delete a disk file	    */ 
;#define SEQREAD    20	/* seq read		    */ 
;#define SEQWRITE   21	/* seq write		    */ 
;#define CREATE	   22	/* Create a disk file	    */ 
;#define F_RENAME   23	/* Rename a disk file	    */ 
;#define SETDMA	   26	/* Set DMA address	    */ 
;#define B_READ	   33	/* Read Random record	    */ 
;#define B_WRITE	   34	/* Write Random record	    */ 
;#define FILSIZ	   35	/* Compute File Size	    */ 
;/** #endif		*****************************/ 
; 
;/***	File State  bit definitions                       ***/ 
;#define STATE_FR 0	/* Available State, FREE CCB        */ 
;#define STATE_FO 1	/* else File Opened                 */ 
;#define STATE_DT 2	/* at least 1 rec put to file, ndx0 */ 
;#define STATE_PW 4	/* Pending Write, Flush before close*/ 
;#define STATE_EF 8	/* EOF state on last read	    */ 
;#define STATE_ER BAD	/* Error State                      */ 
; 
;/***	File Mode, Character String                         */ 
;#define MODE_RD	'R'	/* Read mode parameter for open     */ 
;#define MODE_WR	'W'	/* Write mode                       */ 
;#define MODE_NU	'N'	/* Null Mode for reuse              */  
; 
;/*	CP/M FCB definition - similar to PC Dos	*/ 
;#define EOFCHR	26	/* End of file character-^Z, 0x1a   */ 
;				/****************************/ 
;#define SECSIZ		128	/* size of CP/M sectorrecord*/ 
;#define _MAXSXFR	1	/* max # sectors xferrable  */ 
;#define _MAXSHFT	12	/* shift right BDOS rtn val */ 
;				/*   to obtain nsecs on err */ 
;				/****************************/ 
;#define BYTE	char 
;#define INT	int 
;#define WORD	int 
; 
;/******************************************************************** 
; *	Channel Control Block (CCB), _iod, I/O Descriptor. 
; *									     
; * One CCB is allocated (statically) for each of the possible open   
; * files under C (including STDIN, STDOUT, STDERR).  Permanent data     
; * regarding the channel is kept here.				     
; *	-= note: initially. use 6 CCB's, adequate for small-c =- 
; ********************************************************************/ 
;  /** Define File Descriptor Indexes - _IOD **/ 
;#define DRV	0 
;#define FNAME	1 
;#define FTYP	9 
;#define FBLK	12 /* current 16k Block */ 
;#define LRS	14 /* Logical Record Size, 0080h */ 
;#define FSZ	16 /* FileSize in bytes */ 
;#define FDATE	20 /* Date */ 
;#define FTCHG	22 /* Time of Last Change */ 
;#define FDCHG	24 /* Date of Last Change */ 
;#define FCLUS	26 /* First Cluster Number for FAT Entry */ 
;#define FSIZE	28 /* File Size 28..31 */ 
;#define FCREC	32 /* Current Record in current 16k Block */ 
;#define FR0	33 /* lo byte of Random Rec Number */ 
;#define FR1	34 /* mid byte of Random Rec Number */ 
;#define FR2	35 /* hi byte of Random Rec Number */ 
;#define FR3	36 /* Overflo byte under certain circumstances */ 
;  /** -= File Operational Elements of Struct =- **/ 
;#define IOTYP   37 /* TYPES: 'S'torage(file), 'M'emory(file) **/ 
;#define FMODE	38 /* File Mode Indication Bytes [3] ex.'wb+' **/ 
;#define FSTATE	41 /* Current Operational State Byte **/ 
;#define FBUFNDX 42 /* Buffer index DW to next free position, 0..127 **/ 
;#define FBUFFER	44 /* File Transfer Buffer **/  
;#define LENFDD	172 /* Next Position after FCB Structure, */ 
;		/** Length of File Descriptor Area **/ 
;#define LEN_Y	171 /** LENFDD - 1, for addressing f_units **/ 
;/**-------------------------------------------------------------*/ 
;/*** -= DECLARATIONS =- ***/ 
;/**-------------------------------------------------------------*/ 
; 
;/** FCB STUCTURES ARRAY AREA ***** CCB's	**/ 
;/** First three are STDIN, STDOUT, STDERR	**/ 
; 
;	int  *_iod[MAX_IOD]; /** holds addrs of f_units at runtime **/ 
; 
;  /** File Descriptor Area **/ 
;	char f_unit0;	/** Location is DRV in struct **/ 
;	char fdd_01[LEN_Y];  /** one less than LENFDD **/ 
; 
;	char f_unit1; 
;	char fdd_02[LEN_Y]; 
; 
;	char f_unit2; 
;	char fdd_03[LEN_Y]; 
; 
;	char f_unit3; 
;	char fdd_04[LEN_Y]; 
; 
;	char f_unit4; 
;	char fdd_05[LEN_Y]; 
; 
;	char f_unit5; 
;	char fdd_06[LEN_Y]; 
; 
; 
;	char fdta[128]; /** default fp buff **/ 
;  /** TBUFF Area for CONIO *********************/ 
;	char tbuff[257]; 
;	char ubuff[257]; 
;	char cp[]; 
; 
;/*       1         2         3         4         5   */ 
;/*****************************************************/ 
;/* Module: OSFN.C				     */ 
;/* Last:  12:10 PM 4/12/2008                         */ 
;/* Init:  9:28 PM 12/28/2007                         */ 
;/* By:  s_dubrovich@yahoo.com                        */ 
;/* Goal: test module for small-c & nasm              */ 
;/* testb.c -  to demo "SMALLC-NASM"                  */ 
;/* -f bin -l testb.lst -o testb.com testb.nsm        */ 
;/* #asm                                              */ 
;/* ;-;	org 0100h ;; for .com locate main()	     */ 
;/* ;-; Doesn't work, for pcDos, edit SECTION .text   */ 
;/* ;-;  to vstart=0100h                              */ 
;/* #endasm                                           */ 
; 
;/***-----------------------------------------------***/ 
;/***                   M A I N                     ***/ 
;/***-----------------------------------------------***/ 
;/*** Main Block, testing File I/O Functions.  Also, **/ 
;/** provides startup initialization for FCB's for   **/ 
;/** User codes' main() -this depends on including   **/ 
;/**  #include C5LIB.C ** first in users's source    **/ 
;/**  in order for mainmain() to execute first. If   **/ 
;/**  included elsewhere in user's source then this  **/ 
;/**  mainmain() doesn't execute, but the lib fn's   **/ 
;/**  are still available and the user must explicit- */ 
;/*   ly call initfcb() first before file operations. */ 
; 
;mainmain() 
mainmain:
;{ 
;	initfcb(); /** in this file **/ 
	CALL initfcb
;	main();    /** call users main **/ 
	CALL main
;	exit();	/** user's main returns, handle exit */ 
	CALL exit
;} 
	RET
;/** eo main **/ 
; 
;/***-----------------------------------------------***/ 
;/***             S U B R O U T I N E S             ***/ 
;/***-----------------------------------------------***/ 
; 
;/*** codify EOL sequence...			   ***/ 
;NLfn() 
NLfn:
;{ 
;	putchar(CR); putchar(LF); 
	MOV  AX,13
	PUSH AX
	CALL putchar
	ADD  SP,2
	MOV  AX,10
	PUSH AX
	CALL putchar
	ADD  SP,2
;} 
	RET
; 
;/* Test if given character is alpha - internal FN !? */ 
;/****---- alpha(c) 
;	char c; 
;{	c=c&127; 
;	return(((c>='a')&(c<='z'))| 
;		((c>='A')&(c<='Z'))| 
;		(c=='_')); 
;} ----****/ 
; 
; 
;/***-----------------------------------------------***/ 
;/** Test for Printable Character, EOF		---***/ 
;/**  ret bool := 1 if not a printable char, else 0 ***/ 
;/**  ret`0 .if. e|{' '..'~'} .else. 1		   ***/ 
; 
;isnprint(c) char c; 
isnprint:
;{ 
;	if ((c>=' ')&(c<='~')) return 0; 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,32
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,126
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JLE  $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc524
	MOV  AX,0
	RET
;	else return 1; 
	JMP  cc525
cc524:
	MOV  AX,1
	RET
cc525:
;} 
	RET
; 
;/***-----------------------------------------------***/ 
;toupper(c) char c; 
toupper:
;{ 
;	if (c) /** not null **/ 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc526
;		{ 
;		if ((c>='a')&(c<='z')) return (c-32); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,97
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,122
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JLE  $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc527
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,32
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	RET
;		else return (c); 
	JMP  cc528
cc527:
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	RET
cc528:
;		} 
;	return (c); 
cc526:
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	RET
;} 
; 
;/***-----------------------------------------------***/ 
;/*** put a char array of len length to conout.	---***/ 
;putchara(str,len) char str[]; int len; 
putchara:
;{ 
;	int cnt, ix; 
	PUSH 0
	PUSH 0
;	cnt = len; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;	ix  = 0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;	while (len) 
cc529:
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc530
;		{ 
;		putchar(str[ix++]); 
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL putchar
	ADD  SP,2
;		len--; 
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	DEC  AX
	POP  BP
	MOV  [BP],AX
	INC  AX
;		} 
	JMP  cc529
cc530:
;} 
	ADD  SP,4
	RET
; 
;/***-----------------------------------------------***/ 
;/*** to Upper Case conversion of string 'str$'     ***/ 
; 
;uc_str(pstr) char *pstr; 
uc_str:
;{ /** takes a ptr to a '$' terminated string **/ 
;	char chr, *ip; 
	DEC  SP
	PUSH 0
; 
;	while (*pstr != '$') 
cc531:
	MOV  AX,5
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,36
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc532
;		{ 
;		chr=toupper(*pstr++); 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL toupper
	ADD  SP,2
	POP  BP
	MOV  [BP],AL
;		putchar(chr); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL putchar
	ADD  SP,2
;		*ip++ = chr; /** ip++; **/ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;		} /** str conversion **/ 
	JMP  cc531
cc532:
;} 
	ADD  SP,3
	RET
; 
;/***-----------------------------------------------***/ 
;/*** to Upper Case conversion of string 'str\0'    ***/ 
; 
;uc_nstr(pstr) char *pstr; 
uc_nstr:
;{ /** takes a ptr to a null terminated string **/ 
;	char chr, *ip; 
	DEC  SP
	PUSH 0
; 
;	while (*pstr) 
cc533:
	MOV  AX,5
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc534
;		{ 
;		chr=toupper(*pstr++); 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL toupper
	ADD  SP,2
	POP  BP
	MOV  [BP],AL
;		putchar(chr); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL putchar
	ADD  SP,2
;		*ip++ = chr; /** ip++; **/ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;		} /** str conversion **/ 
	JMP  cc533
cc534:
;} 
	ADD  SP,3
	RET
; 
;/***-----------------------------------------------***/ 
;/*** NOTE- limited function, copy filespec 11 chars***/ 
; 
;copystr(str1, str2) char str1[], str2[];  
copystr:
;{ 
;	int i,cnt; 
	PUSH 0
	PUSH 0
;	cnt = 11; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	POP  BP
	MOV  [BP],AX
;	i   = 0; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;	while (cnt) 
cc535:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc536
;		{ 
;		str2[i] = str1[i]; 
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;		cnt--; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	DEC  AX
	POP  BP
	MOV  [BP],AX
	INC  AX
;		i++; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
;		} 
	JMP  cc535
cc536:
;} 
	ADD  SP,4
	RET
; 
;/***-----------------------------------------------***/ 
;copymem(blk1, blk2, ccnt) char blk1[], blk2[]; int ccnt;  
copymem:
;{ 
;	int i; 
	PUSH 0
;	i   = 0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;	while (ccnt) 
cc537:
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc538
;		{ 
;		blk2[i] = blk1[i]; 
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;		ccnt--; 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	DEC  AX
	POP  BP
	MOV  [BP],AX
	INC  AX
;		i++; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
;		} 
	JMP  cc537
cc538:
;} 
	ADD  SP,2
	RET
; 
;/***-----------------------------------------------***/ 
;/*** Div DW as DD`DX:AX -> AX`quot,DX`rem.  Word   ***/ 
;/** value is passed on the stack.                  ***/ 
;/** Use Division by Subtraction to avoid ovfl      ***/ 
;/*** Status: works ok, wordsz => 0..max`65535      ***/ 
; 
; 
;outdeci(number) int number; 
outdeci:
;{ 
;#asm 
;;outdeci(number)int number;{int k,zs;char c;zs = 0; 
;; k=10000;/**	if (number<0){number=(-number); 
;; outbyte('-');}***/while (k>=1){c=number/k + '0'; 
;; if ((c!='0')|(k==1)|(zs)){zs=1;putchar(c);} 
;; number=number%k;k=k/10;} } 
	mov  dx,0 
	pop  di		;; 0[ret]2[val] 
	pop  ax 
	push ax		;; caller cleans the stack 
	push di		;; restore return address. 
	pusha		;; save entry state... 
	mov  cx,0 
	mov  bx,10000 
	call Lnnd 
	mov  cx,0 
	mov  bx,1000 
	call Lnnd 
	mov  cx,0 
	mov  bx,100 
	call Lnnd 
	mov  cx,0 
	mov  bx,10 
	call Lnnd 
	mov  cx,0 
	mov  bx,1 
	call Lnnd 
  ;; Cleanup Stack, and return.. 
	popa 
	jmp  Cont 
Lnnd: 
	cmp  ax,bx 
	jb   .Lnxt1	;; less than 10k, else count. 
	sub  ax,bx 
	inc  cx 
	jmp  Lnnd 
.Lnxt1: 
	add  cx,30h ;; make ascii number 
	pusha 
	push cx 
	call putchar 
	pop  cx 
	popa 
	RET 
Cont: 
;} 
	RET
; 
;/***-----------------------------------------------***/ 
;/** ----------= S I M P L E   I / O =-------------- **/ 
;/***-----------------------------------------------***/ 
;/** define putchar() putc(c,stdout)                 **/ 
;/** -= Simple I/O =- **/ 
;putchar(c) 
putchar:
; char c; 
;{ 
;	OSfn_(CONOUT,c); 
	MOV  AX,2
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL OSfn_
	ADD  SP,4
;/**	if(c==CR)		**/ 
;/**	OSfn_(CONOUT,LF);	**/ 
;/**	return(c & 255);	**/ 
;} 
	RET
; 
;/***-----------------------------------------------***/ 
;/** get buffered input from stdin, CONBUF #10       **/ 
;/** 1st byte of tbuff on call holds max_len,1..255  **/ 
;/** 2nd byte is set to string length inc terminator **/ 
;/** byte CR`0Dh.  Buffer must be preset before call **/ 
;/** Users returned string begins at third byte.     **/ 
; 
;/** Call 5 interface for internal use. **/ 
;c5gets(ubuff) char *ubuff;   
c5gets:
;{  /** use temp buffer with copy to userbuffer **/ 
;	char *ip,*pb,chr; 
	PUSH 0
	PUSH 0
	DEC  SP
; 
;	tbuff[0]=255;  /** use default max **/ 
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,255
	POP  BP
	MOV  [BP],AL
;	ip = &tbuff[1]; 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;	pb = &tbuff[2]; 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,2
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;	OSfn_(CONBUF,&tbuff[0]); /** Fn 10, DS:DX **/ 
	MOV  AX,10
	PUSH AX
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL OSfn_
	ADD  SP,4
;  /** copy string part to users buffer **/ 
;	while (*pb != 13) 
cc539:
	MOV  AX,1
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,13
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc540
;		{ 
;		chr = *pb++; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;		*ubuff++ = chr; 
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;		} 
	JMP  cc539
cc540:
;  /* chgs termination from CR to '$' */ 
;	*ubuff = '$'; 
	MOV  AX,7
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,36
	POP  BP
	MOV  [BP],AL
;	return (*ip); 
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	ADD  SP,5
	RET
;} 
; 
;/***-----------------------------------------------***/ 
;/**** Note: gets() for C functionality, append null ****/ 
;/**** Rets- caller's buffer ptr, or NULL if eof or err */ 
; 
;gets(ubuff) char *ubuff;  /** CONIN Fn **/ 
gets:
;{  /** use temp buffer with copy to userbuffer **/ 
;	char *ip,*pb, *tmpp, chr; 
	PUSH 0
	PUSH 0
	PUSH 0
	DEC  SP
; 
;	tmpp = ubuff;  /** local copy **/ 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;	tbuff[0]=255;  /** use default max inbuffsz **/ 
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,255
	POP  BP
	MOV  [BP],AL
;	ip = &tbuff[1]; /** fn10 sets to strlen entered **/ 
	MOV  AX,5
	ADD  AX,SP
	PUSH AX
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;	pb = &tbuff[2]; /** entered str start **/ 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,2
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;	OSfn_(CONBUF,&tbuff[0]); /** Fn 10, DS:DX struct **/ 
	MOV  AX,10
	PUSH AX
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL OSfn_
	ADD  SP,4
; 
;	if (0 == *ip) return (NULL); /** empty line **/ 
	MOV  AX,0
	PUSH AX
	MOV  AX,7
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc541
	MOV  AX,0
	ADD  SP,7
	RET
;  /** copy string part to users buffer **/ 
;	while (*pb != 13) /** input CR terminated **/ 
cc541:
cc542:
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,13
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc543
;		{ 
;		chr = *pb++; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,5
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;		*tmpp++ = chr; 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;		} 
	JMP  cc542
cc543:
;  /* chgs termination from CR to C's '0' */ 
;	*tmpp = 0; 
	MOV  AX,1
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AL
;	return (ubuff); 
	MOV  AX,9
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,7
	RET
;} 
; 
;/***-----------------------------------------------***/ 
;getch() 
getch:
;{ /* rets AH.01,AL.CharIn, echos to console   ***/ 
;	OSfn_(CONIN,0);  
	MOV  AX,1
	PUSH AX
	MOV  AX,0
	PUSH AX
	CALL OSfn_
	ADD  SP,4
;} 
	RET
; 
;/***-----------------------------------------------***/ 
;putstr(prntstr) /** must be '$' terminated, conout  **/ 
putstr:
; int *prntstr; 
;{ 
;	OSfn_(C_WRITESTR,prntstr); /* Fn 9, DS:DX */ 
	MOV  AX,9
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL OSfn_
	ADD  SP,4
;} 
	RET
; 
;/***-----------------------------------------------***/ 
;/*** 8:35 PM 8/14/2008				---***/ 
;/*** int puts(char *string) ; rets 0`success .else.***/ 
;/***  non-zero.  C strings are null terminated.	   ***/ 
;puts(str) char str[]; 
puts:
;{ 
;	char pstr[],*ptb,*ip,*op,*mx,chr; 
	PUSH 0
	PUSH 0
	PUSH 0
	PUSH 0
	PUSH 0
	DEC  SP
;	int  ndx; 
	PUSH 0
; 
;	mx = &tbuff[0];  /** holds byte len of tbuff **/ 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;	ip = &tbuff[1];  /** returns len entered **/ 
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;	ptb = &tbuff[2]; /** buffer data area **/ 
	MOV  AX,9
	ADD  AX,SP
	PUSH AX
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,2
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;	op = ptb;	/** save start **/ 
	MOV  AX,5
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;	pstr = str; 
	MOV  AX,11
	ADD  AX,SP
	PUSH AX
	MOV  AX,17
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;	ndx = 0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
; 
;	*mx = 127; /** set max length for string 0..126 **/ 
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,127
	POP  BP
	MOV  [BP],AL
;	*ip = 0; 
	MOV  AX,7
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AL
;		 
; 
;	while (1) 
cc544:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc545
;		{ 
;		if (ndx == 127) 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,127
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc546
;			{ /** internal max str len **/ 
;			NLfn(); 
	CALL NLfn
;			putstr("-= String maxed error =-$"); 
	MOV  AX,cc1+2348
	PUSH AX
	CALL putstr
	ADD  SP,2
;			return (BAD); 
	MOV  AX,1
	NEG  AX
	ADD  SP,13
	RET
;			} 
;		if (pstr[ndx] == 0) 
cc546:
	MOV  AX,11
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc547
;			{	/** found null **/ 
;			*ptb = '$';   /** chg termination **/ 
	MOV  AX,9
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,36
	POP  BP
	MOV  [BP],AL
;			*ip = ndx;    /** length of str in tbuff **/ 
	MOV  AX,7
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AL
;			putstr(op); 
	MOV  AX,5
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL putstr
	ADD  SP,2
;			return (ndx); /** pass back numb of chrs **/ 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,13
	RET
;			} 
;		else	{  /** not EO string yet, copy chr **/ 
	JMP  cc548
cc547:
;			chr = pstr[ndx]; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,13
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;			*ptb++ = chr; 
	MOV  AX,9
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;			} 
cc548:
;		ndx++; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
;		} 
	JMP  cc544
cc545:
;} 
	ADD  SP,13
	RET
; 
;/***-----------------------------------------------***/ 
;/*** dump2cons(fp_); write DTA to console, primitive.*/ 
;dump2cons(fp_) int fp_; 
dump2cons:
;{	/** change index to _iod address **/ 
;	int *fptr, i, index; 
	PUSH 0
	PUSH 0
	PUSH 0
;	char fbuf[], byteval, *pccb; 
	PUSH 0
	DEC  SP
	PUSH 0
; 
;	pccb = _iod[fp_]; /** log address of CCB fcb **/ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,17
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;	fbuf = &pccb[FBUFFER]; 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,44
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;	i = 128; 
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  AX,128
	POP  BP
	MOV  [BP],AX
;	index = 0; 
	MOV  AX,5
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
;	while (i) 
cc549:
	MOV  AX,7
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc550
;		{ 
;		byteval = fbuf[index++]; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,5
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,9
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;		if (byteval == EOFCHR) break; 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,26
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc551
	JMP  cc550
;		if (isnprint (byteval))  
cc551:
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL isnprint
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc552
;			{ /** non printable substitution **/ 
;			putchar('^'); 
	MOV  AX,94
	PUSH AX
	CALL putchar
	ADD  SP,2
;			continue; 
	JMP  cc549
;			} 
;		putchar(byteval); 
cc552:
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL putchar
	ADD  SP,2
;		i--; 
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	DEC  AX
	POP  BP
	MOV  [BP],AX
	INC  AX
;		} 
	JMP  cc549
cc550:
;	return (index);	 
	MOV  AX,5
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,11
	RET
;} 
; 
;/***-----------------------------------------------***/ 
;/** ----------= F I L E   I / O =------------------ **/ 
;/***-----------------------------------------------***/ 
;/*** OS_ := direct OS calls which map to 'C' Fns.  ***/ 
;/***-----------------------------------------------***/ 
;/*** Program Terminate is Fn# 0, but use exit();   ***/ 
;/***-----------------------------------------------***/ 
;/** These minimal file io primitives req'd for sm-c **/ 
;/** int putc(int chr,FILE *fp); ret`chr`ok .else. EOF*/ 
;/** int getc(FILE *fp); ret`nxtchr`ok .else. EOF    **/ 
;/** fopen(name,mode) fclose(fp)			    **/ 
;/***-----------------------------------------------***/ 
;/** File Open 15 | On entry DS:DX := unopened FCB,  **/ 
;/** Ret: int fp_, index of iob structure assigned.  **/ 
;/** search thru CCB's, i.e. File Descriptors, for   **/ 
;/** free descriptor to use. Copy filename and mode  **/ 
;/** to descriptor fields.  OS Call 5 returns NULL if**/ 
;/** either open or create is successful, but fopen()**/ 
;/** returns fp#, or NULL if error opening the file. **/ 
; 
;fopen(filespec, mode) char *filespec, *mode;  
fopen:
;{ 
;	int result, fpi; 
	PUSH 0
	PUSH 0
;	char *ufdesc, *indx, *p_ccb, sval; 
	PUSH 0
	PUSH 0
	PUSH 0
	DEC  SP
;  /** available slot, first free _iod index is our **/ 
;  /** fp#, return this after further processing    **/ 
;	while (1)  
cc553:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc554
;		{ 
;		fpi = 3; 
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	POP  BP
	MOV  [BP],AX
;		p_ccb = _iod[fpi]; /** infile **/ 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;		sval = p_ccb[FSTATE]; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;		if ( sval == STATE_FR) {break;} 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc555
	JMP  cc554
; 
;		fpi = 4; 
cc555:
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  AX,4
	POP  BP
	MOV  [BP],AX
;		p_ccb = _iod[fpi]; /** outfile **/ 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;		sval = p_ccb[FSTATE]; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;		if ( sval == STATE_FR) {break;} 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc556
	JMP  cc554
; 
;		fpi = 5; 
cc556:
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  AX,5
	POP  BP
	MOV  [BP],AX
;		p_ccb = _iod[fpi]; /** temp **/ 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;		sval = p_ccb[FSTATE]; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;		if ( sval == STATE_FR) {break;} 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc557
	JMP  cc554
;	/** else none of the 3 CCB's are available **/ 
;		sval = STATE_ER; 
cc557:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	NEG  AX
	POP  BP
	MOV  [BP],AL
;		putstr("No Available IOD$"); 
	MOV  AX,cc1+2374
	PUSH AX
	CALL putstr
	ADD  SP,2
;		NLfn(); 
	CALL NLfn
;		break; 
	JMP  cc554
;		} 
	JMP  cc553
cc554:
;  /** catch error, return null  **/ 
;	if ( sval == STATE_ER ) 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,1
	NEG  AX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc558
;		{ 
;		putstr("fopen STATE_ER error.$"); 
	MOV  AX,cc1+2392
	PUSH AX
	CALL putstr
	ADD  SP,2
;		NLfn(); 
	CALL NLfn
;		return (NULL); 
	MOV  AX,0
	ADD  SP,11
	RET
;		} 
;  /** else presumed free descriptor **/ 
;  /** fpi holds index in _iod, which has addr of desc **/ 
;  /** p_ccb holds that addr. Copy it as ufdesc        **/ 
;	ufdesc = p_ccb; 
cc558:
	MOV  AX,5
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;  /** Set FMODE to mode **/ 
;	p_ccb[FMODE] = *mode; 
	MOV  AX,1
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,38
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,15
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;	p_ccb[DRV] = 0; /** current default drive **/ 
	MOV  AX,1
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AL
;				/** chg behavior in future version **/ 
; 
;  /** Copy Filefilespec as upper case to FNAME, FTYP **/ 
;	clearfcb(ufdesc); /** overwrite with spaces to clear **/ 
	MOV  AX,5
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL clearfcb
	ADD  SP,2
;	p_ccb = &p_ccb[FNAME]; 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;	indx = filespec; 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,17
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;	while (1) 
cc559:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc560
;		{ /** null terminated strings **/ 
;		if (*indx == 0) break; 
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc561
	JMP  cc560
;		if (*indx == '.') 
cc561:
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,46
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc562
;			{ 
;			p_ccb = &ufdesc[FTYP]; 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,7
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,9
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;			indx++; 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
;			} 
;		if (*indx)  
cc562:
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc563
;			{ 
;			*p_ccb = toupper(*indx); 
	MOV  AX,1
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,5
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	CALL toupper
	ADD  SP,2
	POP  BP
	MOV  [BP],AL
;			p_ccb++; indx++; 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
;			} 
;		else break; 
	JMP  cc564
cc563:
	JMP  cc560
cc564:
;		} 
	JMP  cc559
cc560:
; 
;  /** call OS_fo, pass user file descriptor ptr -------------**/ 
;	result = OS_fo(ufdesc); 
	MOV  AX,9
	ADD  AX,SP
	PUSH AX
	MOV  AX,7
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL OS_fo
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
; 
;  /** process low level fopen result **/ 
;	if (result == NULL) 
	MOV  AX,9
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc565
;		{ /** successful open from lower level **/ 
;		  /** conout state information **/ 
;		if (VERBOSE) 
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc566
;			{ 
;			putstr("CCB File Buffer assigned.$"); 
	MOV  AX,cc1+2415
	PUSH AX
	CALL putstr
	ADD  SP,2
;			NLfn(); 
	CALL NLfn
;			putstr ("fopen result reports not null.$"); 
	MOV  AX,cc1+2442
	PUSH AX
	CALL putstr
	ADD  SP,2
;			NLfn();outdeci(fpi);NLfn(); 
	CALL NLfn
	MOV  AX,7
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL outdeci
	ADD  SP,2
	CALL NLfn
;			} 
;		return fpi; 
cc566:
	MOV  AX,7
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,11
	RET
; 		} 
;	else 	{ /** unsuccessful open **/ 
	JMP  cc567
cc565:
;		if (VERBOSE) 
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc568
;			{ 
;			putstr ("fopen result reports null.$"); 
	MOV  AX,cc1+2474
	PUSH AX
	CALL putstr
	ADD  SP,2
;			NLfn(); 
	CALL NLfn
;			} 
;		return (NULL); 
cc568:
	MOV  AX,0
	ADD  SP,11
	RET
;		} 
cc567:
;} 
	ADD  SP,11
	RET
; 
;/***-----------------------------------------------***/ 
;/** File Open 15 | On entry DS:DX := unopened FCB,  **/ 
;/** the dir is searched searched for the named file **/ 
;/** and returns AL := FFh if not found, .else. AL:= **/ 
;/** 0, and the entry FCB is filled in, DRV:=current **/ 
;/** drv, Current Block :=0.  OS Call 5 returns NULL **/ 
;/** if either open or create is successful.         **/ 
; 
;OS_fo (ufdesc) char ufdesc[]; 
OS_fo:
;{ /** User File Descriptor*/ 
;	char cresult, *cbuff; 
	DEC  SP
	PUSH 0
;	int iresult, i; 
	PUSH 0
	PUSH 0
;	cresult = ufdesc[FMODE]; 
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,38
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
; 
;  /** if fmode := read, f must exist for std C **/ 
;	if ((cresult == 'r') | (cresult == 'R')) 
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,114
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,82
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc569
;		{ 
;		cresult = OSfn_(OPEN, ufdesc); 
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	MOV  AX,15
	PUSH AX
	MOV  AX,13
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL OSfn_
	ADD  SP,4
	POP  BP
	MOV  [BP],AL
; 
;	  /** OS Open op searches for f, returns FFh if not found **/ 
;		if (cresult == BAD) 
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,1
	NEG  AX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc570
;			{ 
;			putstr("File Not Found for reading, Error..$"); 
	MOV  AX,cc1+2502
	PUSH AX
	CALL putstr
	ADD  SP,2
;			NLfn(); 
	CALL NLfn
;			return (BAD); 
	MOV  AX,1
	NEG  AX
	ADD  SP,7
	RET
;			} 
;		else	{	/** Open Successful **/ 
	JMP  cc571
cc570:
;			putstr("File Found and Opened for Reading.$"); 
	MOV  AX,cc1+2539
	PUSH AX
	CALL putstr
	ADD  SP,2
;			NLfn(); 
	CALL NLfn
;			ufdesc[FSTATE] = STATE_FO; 
	MOV  AX,9
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,1
	POP  BP
	MOV  [BP],AL
;		/** assign DTA _and_ seed it from file **/ 
;			cbuff = &ufdesc[FBUFFER]; 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,44
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;			setdta(cbuff); 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL setdta
	ADD  SP,2
;			iresult = OS_sr(ufdesc); 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL OS_sr
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
;			if (iresult)	/** 0`ok, 1`EOF **/ 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc572
;				{  /** true if EOF, else null returned **/ 
;				ufdesc[FSTATE] = STATE_EF; 
	MOV  AX,9
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,8
	POP  BP
	MOV  [BP],AL
;				ufdesc[FBUFNDX] = 0; 
	MOV  AX,9
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,42
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AL
;				} 
;			else  { 
	JMP  cc573
cc572:
;				ufdesc[FBUFNDX] = 0; 
	MOV  AX,9
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,42
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AL
;				ufdesc[FSTATE] = STATE_DT; 
	MOV  AX,9
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,2
	POP  BP
	MOV  [BP],AL
;				} 
cc573:
;			return (cresult); 
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	ADD  SP,7
	RET
;			} 
cc571:
;		} 
;	  /** if fmode := write, f created or f overwritten for std C **/ 
; 
;	else if ((cresult == 'w') | (cresult == 'W')) 
	JMP  cc574
cc569:
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,119
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,87
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc575
;		{ /** fcb ptr to unopened fcb, FFh ret if no file, else ret 0 **/ 
;		cresult = OSfn_(OPEN, ufdesc); 
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	MOV  AX,15
	PUSH AX
	MOV  AX,13
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL OSfn_
	ADD  SP,4
	POP  BP
	MOV  [BP],AL
;	 
;		if (cresult == BAD) 
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,1
	NEG  AX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc576
;			{  /** fille not found in current directory **/ 
;			putstr("File Not Found for writing, Creating..$"); 
	MOV  AX,cc1+2575
	PUSH AX
	CALL putstr
	ADD  SP,2
;			NLfn(); 
	CALL NLfn
;			cresult = creatf(ufdesc); 
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL creatf
	ADD  SP,2
	POP  BP
	MOV  [BP],AL
;			if (cresult == BAD) return BAD; 
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,1
	NEG  AX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc577
	MOV  AX,1
	NEG  AX
	ADD  SP,7
	RET
;			else	{  /** Successful File Create for Writing **/ 
	JMP  cc578
cc577:
;				putstr(" -File Created for Writing- $"); 
	MOV  AX,cc1+2615
	PUSH AX
	CALL putstr
	ADD  SP,2
;				NLfn(); 
	CALL NLfn
;				ufdesc[FSTATE] = STATE_FO; 
	MOV  AX,9
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,1
	POP  BP
	MOV  [BP],AL
;				  /** assign DTA _and_ seed it with ^Z **/ 
;				cbuff = &ufdesc[FBUFFER]; 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,44
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;				setdta(cbuff); 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL setdta
	ADD  SP,2
;				i=127; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,127
	POP  BP
	MOV  [BP],AX
;				while (i) cbuff[i--] = CTRLZ; 
cc579:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc580
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	DEC  AX
	POP  BP
	MOV  [BP],AX
	INC  AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,26
	POP  BP
	MOV  [BP],AL
	JMP  cc579
cc580:
;				cbuff[i] = CTRLZ; /** position index 0 **/ 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,26
	POP  BP
	MOV  [BP],AL
;				return (NULL); 
	MOV  AX,0
	ADD  SP,7
	RET
;				} 
cc578:
;			} 
;		else	{  /** File Found and Successfully Opened for Writing. **/ 
	JMP  cc581
cc576:
;		  /** Note that file position is at the beginning of the file. **/ 
;		  /** seed buffer with ctl-z, eof marker **/ 
;			i=127; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,127
	POP  BP
	MOV  [BP],AX
;			cbuff = &ufdesc[FBUFFER]; 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,44
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;			while (i) cbuff[i--] = CTRLZ; 
cc582:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc583
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	DEC  AX
	POP  BP
	MOV  [BP],AX
	INC  AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,26
	POP  BP
	MOV  [BP],AL
	JMP  cc582
cc583:
;			cbuff[i] = CTRLZ; /** position index 0 **/ 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,26
	POP  BP
	MOV  [BP],AL
;			ufdesc[FSTATE] = STATE_FO; 
	MOV  AX,9
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,1
	POP  BP
	MOV  [BP],AL
;			return (cresult); 
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	ADD  SP,7
	RET
;			} 
cc581:
;		} 
;  /** else some major error **/ 
;	putstr(" -Major FMODE error- $"); 
cc575:
cc574:
	MOV  AX,cc1+2645
	PUSH AX
	CALL putstr
	ADD  SP,2
;	return BAD; 
	MOV  AX,1
	NEG  AX
	ADD  SP,7
	RET
;} 
; 
;/***-----------------------------------------------***/ 
;/** File Close 16 | Req'd to update dir info. DS:DX **/ 
;/*** fclose() ret NULL if successful, else nz err  ***/ 
;/*** Call 5 ret FFh, BAD, means err, NULL is ok    ***/ 
; 
;fclose(fp_) int fp_;  
fclose:
;{ 
;	int *fptr, result; 
	PUSH 0
	PUSH 0
;  /** don't close standard files **/ 
;	if ((fp_==stdin)|(fp_==stdout)|(fp_==stderr)) return NULL; 
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc584
	MOV  AX,0
	ADD  SP,4
	RET
;  /** convert fp_ index to CCB ptr, then call lower level **/ 
;	fptr = _iod[fp_]; 
cc584:
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;	result = OS_fc(fptr); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL OS_fc
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
;	if (VERBOSE) 
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc585
;		{ 
;		if (result == NULL) 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc586
;			{ 
;			putstr ("fclose result reports null, success.$"); 
	MOV  AX,cc1+2668
	PUSH AX
	CALL putstr
	ADD  SP,2
;			NLfn(); 
	CALL NLfn
;			} 
;		else	{ 
	JMP  cc587
cc586:
;			putstr ("fclose result reports not null, fail.$"); 
	MOV  AX,cc1+2706
	PUSH AX
	CALL putstr
	ADD  SP,2
;			NLfn();outdeci(fp_);NLfn(); 
	CALL NLfn
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL outdeci
	ADD  SP,2
	CALL NLfn
;			} 
cc587:
;		} 
;	return result; 
cc585:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,4
	RET
;} 
; 
;/***-----------------------------------------------***/ 
;/** File Close 16 | Req'd to update dir info. DS:DX **/ 
;/** := Close FCB, AL:=0 means ok, AL:=FFh means     **/ 
;/** error. (BAD).                                   **/ 
;/** at exit FCB must appear as unopened, clear FMODE */ 
;/**  FSTATE **/ 
; 
;OS_fc(ufdesc) char ufdesc[]; /** User File Descriptor*/ 
OS_fc:
;{ 
;	int result,cnt,idx; 
	PUSH 0
	PUSH 0
	PUSH 0
;	char stflg; 
	DEC  SP
; 
;  /** note default open read is STATE_FO **/ 
;  /** A Read changes FCB Block Values to current block **/ 
;  /** check for pending write before closing **/ 
;	stflg = ufdesc[FSTATE]; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
; 
;	if (stflg == STATE_PW) flushf(ufdesc); 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,4
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc588
	MOV  AX,9
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL flushf
	ADD  SP,2
;  /** ok, close. **/ 
;  /** successful close returns AL:=0, else FFh err  **/ 
;	result = OSfn_(CLOSE, ufdesc); 
cc588:
	MOV  AX,5
	ADD  AX,SP
	PUSH AX
	MOV  AX,16
	PUSH AX
	MOV  AX,13
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL OSfn_
	ADD  SP,4
	POP  BP
	MOV  [BP],AX
;	if (result == NULL) 
	MOV  AX,5
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc589
;		{ 
;		putstr ("OS_fc result reports null, success.$"); 
	MOV  AX,cc1+2745
	PUSH AX
	CALL putstr
	ADD  SP,2
;		NLfn(); 
	CALL NLfn
;		} 
;	else	{ 
	JMP  cc590
cc589:
;		putstr ("OS_fc result reports non-null, error.$"); 
	MOV  AX,cc1+2782
	PUSH AX
	CALL putstr
	ADD  SP,2
;		NLfn(); 
	CALL NLfn
;		} 
cc590:
;  /** Clear CCB, Free FMODE, FSTATE, fn **/ 
; 
;	ufdesc[FMODE] = 0; 
	MOV  AX,9
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,38
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AL
;	ufdesc[FSTATE] = ufdesc[DRV] = 0; 
	MOV  AX,9
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AL
	POP  BP
	MOV  [BP],AL
;/***	cnt = 171; idx = 0; while (cnt--) { ufdesc[idx++] = 0; } **/ 
;  /** Return reported result, note we clear CCB to **/ 
;  /** new, even on error. **/ 
;	if (result == BAD) return BAD; 
	MOV  AX,5
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	NEG  AX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc591
	MOV  AX,1
	NEG  AX
	ADD  SP,7
	RET
;	else return NULL; 
	JMP  cc592
cc591:
	MOV  AX,0
	ADD  SP,7
	RET
cc592:
;} 
	ADD  SP,7
	RET
; 
;/***--- Write Record according to current blk/rec  ***/ 
;/***--- settings in fcb                            ***/ 
;wr_rec() 
wr_rec:
;{ 
;} 
	RET
; 
;/***-----------------------------------------------***/ 
;/** int getc(FILE *fp); ret`nxtchr`ok .else. EOF    **/ 
;/**  init is fp_ index into _iob                    **/ 
; 
;getc(unit) int unit; 
getc:
;{ 
;	int ichr; 
	PUSH 0
;  /** fetch ascii character from file and return it **/ 
;	ichr = rd_ubuff(unit); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL rd_ubuff
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
;	if (ichr == EOF) return (EOF); 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	NEG  AX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc593
	MOV  AX,1
	NEG  AX
	ADD  SP,2
	RET
;	return (ichr & 127); 
cc593:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,127
	POP  BX
	AND  AX,BX
	ADD  SP,2
	RET
;} 
;/***-----------------------------------------------***/ 
;/** int puts(char *string); ret`0`ok .else. `NZ`err **/ 
;/**  takes a pointer value to target string, decom- **/ 
;/**  pose targets' characters and pass each one to  **/ 
;/**  putc() until NULL in string. CONOUT.           **/ 
; 
;/***-----------------------------------------------***/ 
;/** int fputs(char *string, FILE *fp);             ***/ 
;/**  ret`0`ok .else. `NZ`err                        **/ 
;/**  takes a pointer value to target string, decom- **/ 
;/**  pose targets' characters and pass each one to  **/ 
;/**  putc() until NULL in string.  Does not append  **/ 
;/**  the new-line character to the end of the string**/ 
;/** Target string is C string, null terminated.     **/ 
; 
;fputs(str,fp_) char str[]; int fp_; 
fputs:
;{ 
;	char chr; int i; 
	DEC  SP
	PUSH 0
; 
;	i=0; chr = str[0]; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,9
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;	if (chr == 0) return BAD; 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc594
	MOV  AX,1
	NEG  AX
	ADD  SP,3
	RET
;	while (chr) 
cc594:
cc595:
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc596
;		{ 
;		putc(chr,fp_); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,7
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL putc
	ADD  SP,4
;		chr = str[++i]; /** read chr from ds:str **/ 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,9
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
;		} 
	JMP  cc595
cc596:
;} 
	ADD  SP,3
	RET
; 
;/***-----------------------------------------------***/ 
;/** int putc(int chr,FILE *fp); ret`chr`ok .else. EOF*/ 
;/** note: only retun EOF on File Error, ret null or **/ 
;/** chr only.  (echo back chr means success)		*/ 
;/** _get ptr to CCB; //DTA is CCB[FBUFFER]; putc to **/ 
;/**  //[FBUFFER]+[FBUFNDX];                         **/ 
;/** _get FBUFNDX,				    **/ 
;/** .if. == 0, set FSTATE == STATE_PW		    **/ 
;/** .if. == 128, flush buffer to file, set FBUFNDX==0*/ 
;/**      set FSTATE == STATE_DT;		    **/ 
;/** .else. place chr to FBUFNDX and incr FBUFNDX    **/ 
;/** NOTE: small-c will close outfile if putc rets<=0**/ 
; 
;putc(chr,fp_) char chr; int fp_; 
putc:
;{ 
;	int *fptr, i, index; 
	PUSH 0
	PUSH 0
	PUSH 0
;	char fbuf[], byteret, *pccb; 
	PUSH 0
	DEC  SP
	PUSH 0
;  /** First off, test for printable character passed **/ 
;  /**  isnprint returns 1 if not printable           **/ 
;  /**	if (isnprint(chr)) return (BAD);	**/ 
; 
;  /** convert fp_ index to CCB ptr **/ 
;	pccb = _iod[fp_]; /** log address of CCB fcb **/ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,17
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;	fbuf = &pccb[FBUFFER]; /** get buffer location **/ 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,44
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;	setdta(fbuf); /** indicate current DTA for write **/ 
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL setdta
	ADD  SP,2
;	index = pccb[FBUFNDX]; 
	MOV  AX,5
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,42
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AX
; 
;  /** put char to buffer **/ 
;	fbuf = &pccb[FBUFFER]; /** get buffer location **/ 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,44
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;	fbuf = fbuf + index; /** base + index **/ 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,5
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,9
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;	*fbuf = chr; /** chr placed into current buffer **/ 
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,17
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AL
; 
;	if (index == 0) pccb[FSTATE] = STATE_PW; 
	MOV  AX,5
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc597
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,4
	POP  BP
	MOV  [BP],AL
; 
;  /** ck if index is maxed, if so wr buffer and reset index **/ 
;	if (index == 127) /** maxed, signed byte compare **/ 
cc597:
	MOV  AX,5
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,127
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc598
;		{ /** flushf full buffer **/ 
;		byteret = flushf(pccb); 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL flushf
	ADD  SP,2
	POP  BP
	MOV  [BP],AL
;		if (byteret)  /** 0`ok .else. err **/ 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc599
;			{ /** error state **/ 
;			pccb[FSTATE] = STATE_ER; 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,1
	NEG  AX
	POP  BP
	MOV  [BP],AL
;			return BAD; 
	MOV  AX,1
	NEG  AX
	ADD  SP,11
	RET
;			} 
;		else	{ /** flushed ok, purge buff upd index **/ 
	JMP  cc600
cc599:
;			fbuf = &pccb[FBUFFER]; /** reset to begin **/ 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,44
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;		 /** fill buffer with CTRLZ, EOF **/ 
;			i=127; 
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  AX,127
	POP  BP
	MOV  [BP],AX
;			while (i) fbuf[i--] = CTRLZ; 
cc601:
	MOV  AX,7
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc602
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,9
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	DEC  AX
	POP  BP
	MOV  [BP],AX
	INC  AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,26
	POP  BP
	MOV  [BP],AL
	JMP  cc601
cc602:
;			fbuf[i] = CTRLZ; /** position index 0 **/ 
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,9
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,26
	POP  BP
	MOV  [BP],AL
;			pccb[FSTATE] = STATE_DT; /** Closeable State **/ 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,2
	POP  BP
	MOV  [BP],AL
;			pccb[FBUFNDX] = 0; /** reset for next chr **/ 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,42
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AL
;			return (chr); 
	MOV  AX,15
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	ADD  SP,11
	RET
;			} 
cc600:
;		} /** sector written, chr or err has been returned **/ 
; 
;  /** update index return chr placed -echo- **/  
;  /**	pccb[FBUFNDX]++; ??questionable	**/ 
;	index++; 
cc598:
	MOV  AX,5
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	INC  AX
	POP  BP
	MOV  [BP],AX
	DEC  AX
;	pccb[FBUFNDX] = index; 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,42
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,7
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AL
;	return (chr); 
	MOV  AX,15
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	ADD  SP,11
	RET
;} 
; 
;/***-----------------------------------------------***/ 
;/*** set to spaces the fcb filename,typ		---***/ 
; 
;clearfcb(fcb) char fcb[]; 
clearfcb:
;{ 
;	int i; 
	PUSH 0
;	i=11; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	POP  BP
	MOV  [BP],AX
;	while (i) fcb[i--] = ' '; 
cc603:
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc604
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BP,AX
	MOV  AX,[BP]
	DEC  AX
	POP  BP
	MOV  [BP],AX
	INC  AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,32
	POP  BP
	MOV  [BP],AL
	JMP  cc603
cc604:
;} 
	ADD  SP,2
	RET
; 
;/***-----------------------------------------------***/ 
; 
;/***-----------------------------------------------***/ 
;/** Directory First Search 17**/ 
; 
;/***-----------------------------------------------***/ 
;/** Directory Subsequent Search 18 **/ 
; 
;/***-----------------------------------------------***/ 
;/** File Delete 19 **/ 
; 
;/***-----------------------------------------------***/ 
;/** File Sequential Read 20 | On Entry, DS:DX:=FCB **/ 
;/** The 128 byte record indicated by Current Block **/ 
;/** of 16k, and Current Record Fields, is loaded to**/ 
;/** the Disk Transfer Area, DTA, then the record   **/ 
;/** addressed by those fields is incremented. IF EOF*/ 
;/** THEN AL:=1, ELSE AL:=0.                        **/  
; 
;OS_sr(ufcb) char ufcb[]; 
OS_sr:
;{ 
;	int byte_result; 
	PUSH 0
; 
;	byte_result = OSfn_(SEQREAD,ufcb); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,20
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL OSfn_
	ADD  SP,4
	POP  BP
	MOV  [BP],AX
;	if (byte_result) return (EOF); 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc605
	MOV  AX,1
	NEG  AX
	ADD  SP,2
	RET
;	else return (0); 
	JMP  cc606
cc605:
	MOV  AX,0
	ADD  SP,2
	RET
cc606:
;} 
	ADD  SP,2
	RET
; 
;/***-----------------------------------------------***/ 
;/** rd_ubuff(int fp) read unit buffer, if last chr  **/ 
;/**  re index and fetch next file record.           **/ 
;/** Called by getc(fp_), so ret chr or EOF          **/ 
;/** Note: short sector files are null padded, catch **/ 
;/** partial buffer data.                            **/ 
;/** 30-Jul-08 05:08:51 PM. OS_sr returns 0 if ok,   **/ 
;/** .else. 1 if EOF. Fixed buffer clipping.         **/ 
; 
;rd_ubuff(fp_) int fp_; 
rd_ubuff:
;{	/** change fp_ index into _iod address **/ 
;	/** check _iod is read kind, else error **/ 
;	/** chr_ptr points to next_to_read **/ 
;	/** if chr_ptr == 0, ck STATE_EF for eof **/ 
;	/**  if EOF state return EOF **/ 
;	/** if chr_ptr == 127 retrieve chr, do seq **/ 
;	/** read to fill buffer, reindex chr_ptr =0 **/ 
;	/** if read_sq gives EOF, set state STATE_EF, **/ 
;	/** but return last chr to caller. **/ 
; 
;	int chr, index, result; 
	PUSH 0
	PUSH 0
	PUSH 0
;	char *p_ccb, *cdta, *cp; 
	PUSH 0
	PUSH 0
	PUSH 0
; 
;  /** Convert fp_ into addr of UFCB **/ 
;	p_ccb = _iod[fp_]; 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,18
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
; 
;  /** Also need to manage DTA for UFCB **/ 
;	cdta = &p_ccb[FBUFFER]; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,44
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;	cp = cdta; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;	setdta(cdta); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL setdta
	ADD  SP,2
; 
;  /** check _iod is read kind, else error **/ 
;	if (p_ccb[FMODE] != 'r') 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,38
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,114
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc607
;		{ /** mode error **/ 
;		putstr("File Mode Error, not opened for Reading$"); 
	MOV  AX,cc1+2821
	PUSH AX
	CALL putstr
	ADD  SP,2
;		NLfn(); return (EOF); 
	CALL NLfn
	MOV  AX,1
	NEG  AX
	ADD  SP,12
	RET
;		} 
;	if ((p_ccb[FSTATE] == STATE_EF) & (p_ccb[FBUFNDX] == 127)) 
cc607:
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,8
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,42
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,127
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc608
;		{  /** last low level read returned eof **/ 
;		putstr("-= End of File Reached =- $"); 
	MOV  AX,cc1+2862
	PUSH AX
	CALL putstr
	ADD  SP,2
;		NLfn(); return (EOF); 
	CALL NLfn
	MOV  AX,1
	NEG  AX
	ADD  SP,12
	RET
;		} 
;  /** fetch ascii character from file buffer and hold it **/   
;	index = p_ccb[FBUFNDX]; 
cc608:
	MOV  AX,8
	ADD  AX,SP
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,42
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AX
;	cp = cp + index;  /** base + index to chr in buffer **/ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,12
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BX
	ADD  AX,BX
	POP  BP
	MOV  [BP],AX
;	chr = *cp;		/** FBUFNDX points to next, got chr **/ 
	MOV  AX,10
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	POP  BP
	MOV  [BP],AX
;  /** change null to sp ' ' char, these are text files only. **/ 
;	if (chr == NULL) chr = ' '; 
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc609
	MOV  AX,10
	ADD  AX,SP
	PUSH AX
	MOV  AX,32
	POP  BP
	MOV  [BP],AX
;  /** !! Convert eol 0Dh,0Ah to 20h,0Ah for small-c parser. !! **/ 
;	if (chr == 13) chr = ' '; 
cc609:
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,13
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc610
	MOV  AX,10
	ADD  AX,SP
	PUSH AX
	MOV  AX,32
	POP  BP
	MOV  [BP],AX
; 
;  /** Warning: an unprimed buffer could hold nulls, handle this **/ 
;  /** by priming buffer on fopen(fp_,'r') for reading.          **/ 
;  /** Still, should check here for ^Z, eof, marker and ret EOF. **/ 
;  /** But NO, file can be exact byte length without terminators.**/ 
; 
;  /** ck if index is maxed, if so rd buffer and reset index **/ 
;	if (index == 127)      /** maxed, signed byte compare **/ 
cc610:
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,127
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc611
;		{  /** eo buffer read, fetch next from seq read **/ 
;		result = OS_sr(p_ccb); 
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL OS_sr
	ADD  SP,2
	POP  BP
	MOV  [BP],AX
;		if (result) 
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	CMP  AX,0
	JNE  $+5
	JMP  cc612
;			{  /** true if EOF, else null returned **/ 
;			p_ccb[FSTATE] = STATE_EF; 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,8
	POP  BP
	MOV  [BP],AL
;			p_ccb[FBUFNDX] = 0; 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,42
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AL
;			return (chr); 
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,12
	RET
;			} 
;		else  { 
	JMP  cc613
cc612:
;			p_ccb[FBUFNDX] = 0; 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,42
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BP
	MOV  [BP],AL
;			p_ccb[FSTATE] = STATE_DT; 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,2
	POP  BP
	MOV  [BP],AL
;			return (chr); /** added to fix clipping **/ 
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,12
	RET
;			} 
cc613:
;		} 
;	p_ccb[FBUFNDX]++; /** update for next chr fetch from buffer **/ 
cc611:
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,42
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	INC  AX
	POP  BP
	MOV  [BP],AL
	DEC  AX
;	return (chr); 
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	ADD  SP,12
	RET
;} 
; 
;/***-----------------------------------------------***/ 
;/** File Sequential Write 21 | On Entry, DS:DX:=FCB **/ 
;/** The 128 byte record indicated by Current Block  **/ 
;/** of 16k, and Current Record Fields, is written   **/ 
;/** from the Disk Transfer Area, DTA, to the file   **/ 
;/** then the record address is incremented. IF the  **/ 
;/** disk is too full, AL:=1, ELSE AL:=0.            **/ 
;/**	=	=	=	=	=	=   **/ 
;/*** write buffer, 80h long, to file sequentially. ***/ 
;/***  file fp_ must select open file. DTA must be  ***/ 
;/***  current to proper fp_.                       ***/ 
;/***  calls OSfn_ 21d Sequential Write, which rets ***/ 
;/*** al`0`ok .else. al`1`'disk full error'         ***/ 
;/***  flushf() rets`0`ok .else. `BAD`error         ***/ 
;/***-----------------------------------------------***/ 
; 
;flushf(pccb) char *pccb; 
flushf:
;{ 
;	char byte_result; 
	DEC  SP
;	if (pccb[FSTATE] == STATE_PW) 
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,4
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc614
;		{ 
;		byte_result = OSfn_(SEQWRITE,pccb); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,21
	PUSH AX
	MOV  AX,7
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL OSfn_
	ADD  SP,4
	POP  BP
	MOV  [BP],AL
;		if (byte_result) /** indicates err **/ 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc615
;			{ 
;			pccb[FSTATE] = STATE_ER; 
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,1
	NEG  AX
	POP  BP
	MOV  [BP],AL
;			return (BAD); 
	MOV  AX,1
	NEG  AX
	ADD  SP,1
	RET
;			} 
;		pccb[FSTATE] = STATE_FO; /** mark as file open **/ 
cc615:
	MOV  AX,3
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,1
	POP  BP
	MOV  [BP],AL
;		return byte_result; 
	MOV  AX,0
	ADD  AX,SP
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	ADD  SP,1
	RET
;		} 
;	else return (BAD); /** no pending write state **/ 
	JMP  cc616
cc614:
	MOV  AX,1
	NEG  AX
	ADD  SP,1
	RET
cc616:
;} 
	ADD  SP,1
	RET
; 
;/***-----------------------------------------------***/ 
;/** File Create 22 Rets: FFh if no dir space else   **/ 
;/**  null == successful create                      **/ 
; 
;creatf(ufcb) char *ufcb; 
creatf:
;{ 
;	OSfn_(CREATE, ufcb); 
	MOV  AX,22
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL OSfn_
	ADD  SP,4
;} 
	RET
; 
;/***-----------------------------------------------***/ 
;/** ReName File 23 **/ 
;OS_rn() 
OS_rn:
;{ 
;} 
	RET
;/***-----------------------------------------------***/ 
;/** non-existent fn# 24 **/ 
;/***-----------------------------------------------***/ 
;/** Current Default Drive 25, 0`A,1`B,etc. **/ 
; 
;/***-----------------------------------------------***/ 
;/** Set Disk Transfer Addr 26 **/ 
;setdta(dta) int *dta; 
setdta:
;{  /**  !MUST! Set DTA address prior to File I/O **/ 
;	OSfn_(26,dta); /** Fn Set DTA -> DS:DX **/ 
	MOV  AX,26
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	CALL OSfn_
	ADD  SP,4
;} 
	RET
;/***-----------------------------------------------***/ 
;/** Allocation Table Addr 27 ret: DS:BX, DX := # of..*/ 
;/**  alloc units, AL := # rec per Alloc Unit.       **/ 
;/***-----------------------------------------------***/ 
;/** non-existent fn# 28, 29, 30 **/ 
;/***-----------------------------------------------***/ 
;/** Get Disk Parameter Address 31 ret: DS:BX table  **/ 
;/**  of params for current default disk **/ 
;/***-----------------------------------------------***/ 
;/** non-existent fn# 32 **/ 
;/***-----------------------------------------------***/ 
;/** File Random Read 33 **/ 
;/***-----------------------------------------------***/ 
;/** File Random Write 34 **/ 
;/***-----------------------------------------------***/ 
;/** File Size 35 **/ 
;/***-----------------------------------------------***/ 
;/** File Set Random Record Field 36 **/ 
;/***-----------------------------------------------***/ 
;/** Interrupt Set Vector 37 **/ 
;/***-----------------------------------------------***/ 
;/** Alloc, Create New Program Segment 38 **/ 
;/***-----------------------------------------------***/ 
;/** File Random Block Read 39 **/ 
;/***-----------------------------------------------***/ 
;/** Random Block Write **/ 
; 
;/***-----------------------------------------------***/ 
;/** initialize the fcb structure fields at main    ***/ 
; 
;initfcb() 
initfcb:
;{	char *cptr, *p_stdin, *p_stdout, *p_stderr; 
	PUSH 0
	PUSH 0
	PUSH 0
	PUSH 0
;	char *p_infile, *p_outfile, *p_tempfile; 
	PUSH 0
	PUSH 0
	PUSH 0
;	int  cnt; 
	PUSH 0
; 
;	p_stdin    = "STDIN   IOB"; /** null term.. **/ 
	MOV  AX,12
	ADD  AX,SP
	PUSH AX
	MOV  AX,cc1+2890
	POP  BP
	MOV  [BP],AX
;	p_stdout   = "STDOUT  IOB"; /**  in dseg    **/ 
	MOV  AX,10
	ADD  AX,SP
	PUSH AX
	MOV  AX,cc1+2902
	POP  BP
	MOV  [BP],AX
;	p_stderr   = "STDERR  IOB"; 
	MOV  AX,8
	ADD  AX,SP
	PUSH AX
	MOV  AX,cc1+2914
	POP  BP
	MOV  [BP],AX
;	p_infile   = "INFILE  TXT"; 
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	MOV  AX,cc1+2926
	POP  BP
	MOV  [BP],AX
;	p_outfile  = "OUTFILE TXT"; 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,cc1+2938
	POP  BP
	MOV  [BP],AX
;	p_tempfile = "TEMP    TXT"; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,cc1+2950
	POP  BP
	MOV  [BP],AX
;	; 
;	setdta(fdta); /** default catch basin **/ 
	MOV  AX,fdta
	PUSH AX
	CALL setdta
	ADD  SP,2
;  /** setup _iod[] with addr of f_units **/ 
;	_iod[0] = &f_unit0; 
	MOV  AX,_iod
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,f_unit0
	POP  BP
	MOV  [BP],AX
;	_iod[1] = &f_unit1; 
	MOV  AX,_iod
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,f_unit1
	POP  BP
	MOV  [BP],AX
;	_iod[2] = &f_unit2; 
	MOV  AX,_iod
	PUSH AX
	MOV  AX,2
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,f_unit2
	POP  BP
	MOV  [BP],AX
;	_iod[3] = &f_unit3; 
	MOV  AX,_iod
	PUSH AX
	MOV  AX,3
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,f_unit3
	POP  BP
	MOV  [BP],AX
;	_iod[4] = &f_unit4; 
	MOV  AX,_iod
	PUSH AX
	MOV  AX,4
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,f_unit4
	POP  BP
	MOV  [BP],AX
;	_iod[5] = &f_unit5; 
	MOV  AX,_iod
	PUSH AX
	MOV  AX,5
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,f_unit5
	POP  BP
	MOV  [BP],AX
; 
;  /** copy char const to each f_unit **/ 
;  /***  Also, **/ 
;  /** mark stdin as R, stdout, stderr as W in fmode **/ 
;  /** mark infile, outfile, temp as 'N'ull for now. **/ 
;  /**  open these 3 default files in main if desired**/ 
; 
;	cptr = _iod[0]; 
	MOV  AX,14
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;	*cptr[FMODE] = "r"; 
	MOV  AX,14
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,38
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,cc1+2962
	POP  BP
	MOV  [BP],AL
;	copystr(p_stdin, cptr+1); 
	MOV  AX,12
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,16
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL copystr
	ADD  SP,4
; 
;	cptr = _iod[1]; 
	MOV  AX,14
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;	*cptr[FMODE] = "w"; 
	MOV  AX,14
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,38
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,cc1+2964
	POP  BP
	MOV  [BP],AL
;	copystr(p_stdout, cptr+1); 
	MOV  AX,10
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,16
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL copystr
	ADD  SP,4
; 
;	cptr = _iod[2]; 
	MOV  AX,14
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,2
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;	*cptr[FMODE] = "w"; 
	MOV  AX,14
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,38
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,cc1+2966
	POP  BP
	MOV  [BP],AL
;	copystr(p_stderr, cptr+1); 
	MOV  AX,8
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,16
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL copystr
	ADD  SP,4
; 
;	cptr = _iod[3]; 
	MOV  AX,14
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,3
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;	*cptr[FMODE] = "n"; 
	MOV  AX,14
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,38
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,cc1+2968
	POP  BP
	MOV  [BP],AL
;	copystr(p_infile, cptr+1); 
	MOV  AX,6
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,16
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL copystr
	ADD  SP,4
; 
;	cptr = _iod[4]; 
	MOV  AX,14
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,4
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;	*cptr[FMODE] = "n"; 
	MOV  AX,14
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,38
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,cc1+2970
	POP  BP
	MOV  [BP],AL
;	copystr(p_outfile, cptr+1); 
	MOV  AX,4
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,16
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL copystr
	ADD  SP,4
; 
;	cptr = _iod[5]; 
	MOV  AX,14
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,5
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AX,[BP]
	POP  BP
	MOV  [BP],AX
;	*cptr[FMODE] = "n"; 
	MOV  AX,14
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,38
	POP  BX
	ADD  AX,BX
	MOV  BP,AX
	MOV  AL,[Byte BP]
	CBW
	PUSH AX
	MOV  AX,cc1+2972
	POP  BP
	MOV  [BP],AL
;	copystr(p_tempfile, cptr+1); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,16
	ADD  AX,SP
	MOV  BP,AX
	MOV  AX,[BP]
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL copystr
	ADD  SP,4
; 
;  /*** otherwise, fields are init to null by nasm ***/ 
;} 
	ADD  SP,16
	RET
; 
; 
;/*****************************************************/ 
;/** Test OSfn_ Call 0005h Interface **/ 
;/*****************************************************/ 
;/* CP/M system call codes                            */ 
;/*     -also-                                        */ 
;/* pcDos .COM Call 5 Interface.                      */ 
; 
; #asm 
BDOS	EQU	5	;; call 5 INTERFACE as CALL BDOS. 
CTRLZ	EQU	26	;end-of-file mark for text files 
TBUFF	EQU	80H	;address of default I/O address 
;;/** OSfn_(Fn#,Value) -> tos 0[ret]2[Value]4[Fn#] **/ 
OSfn_:  ;; small-c, top of stack[ret][Val][Fn] 
	pop  bx   ;; 
        pop  dx   ;; 
        pop  cx   ;; 
	push cx   ;; [Fn#] 
	push dx   ;; [Value] 
        push bx   ;; [ret]  
        call BDOS ;; values passed in registers. 
;; Test AL`CBW returned value... 
	cbw 
	RET       ;; Caller cleans the stack. 
exit:  ;; pause for keypress before return. 
	mov  ah,0 
	int  16h  ;; RomBios wait for keypress. 
;;exit:		  ;; don't wait. 
	int  19h  ;; reboot-> enviornment gets control. 
	ret       ;; (actually, never executed) 
;/***-----------------------------------------------***/ 
;/*****************************************************/ 
;/*       1         2         3         4         5   */ 
;/***-----------------------------------------------***/ 
;/** EO C5LIB.C **/ 
;                                                
;/** -======== End of Compiler ========- **/ 
; 
;                                                                               
;                        
	;-; SECTION .dseg align=16 ;; commented out for .com version
cc1:	DB 99,104,97,114,0,105,110,116,0,35
	DB 97,115,109,0,35,105,110,99,108,117
	DB 100,101,0,35,100,101,102,105,110,101
	DB 0,42,0,91,0,44,0,42,0,91
	DB 0,44,0,109,97,99,114,111,32,116
	DB 97,98,108,101,32,102,117,108,108,0
	DB 93,0,109,117,115,116,32,98,101,32
	DB 99,111,110,115,116,97,110,116,0,110
	DB 101,103,97,116,105,118,101,32,115,105
	DB 122,101,32,105,108,108,101,103,97,108
	DB 0,93,0,105,108,108,101,103,97,108
	DB 32,102,117,110,99,116,105,111,110,32
	DB 111,114,32,100,101,99,108,97,114,97
	DB 116,105,111,110,0,40,0,109,105,115
	DB 115,105,110,103,32,111,112,101,110,32
	DB 112,97,114,101,110,0,41,0,105,108
	DB 108,101,103,97,108,32,97,114,103,117
	DB 109,101,110,116,32,110,97,109,101,0
	DB 41,0,44,0,101,120,112,101,99,116
	DB 101,100,32,99,111,109,109,97,0,99
	DB 104,97,114,0,105,110,116,0,119,114
	DB 111,110,103,32,110,117,109,98,101,114
	DB 32,97,114,103,115,0,42,0,91,0
	DB 44,0,101,120,112,101,99,116,101,100
	DB 32,99,111,109,109,97,0,99,104,97
	DB 114,0,105,110,116,0,123,0,105,102
	DB 0,119,104,105,108,101,0,114,101,116
	DB 117,114,110,0,98,114,101,97,107,0
	DB 99,111,110,116,105,110,117,101,0,59
	DB 0,35,97,115,109,0,59,0,109,105
	DB 115,115,105,110,103,32,115,101,109,105
	DB 99,111,108,111,110,0,125,0,101,108
	DB 115,101,0,35,101,110,100,97,115,109
	DB 0,41,0,44,0,41,0,59,0,61
	DB 0,124,0,94,0,38,0,61,61,0
	DB 33,61,0,61,61,0,33,61,0,60
	DB 0,62,0,60,61,0,62,61,0,62
	DB 62,0,60,60,0,60,61,0,62,61
	DB 0,60,0,60,60,0,62,0,62,62
	DB 0,62,62,0,60,60,0,62,62,0
	DB 60,60,0,43,0,45,0,42,0,47
	DB 0,37,0,43,43,0,45,45,0,45
	DB 0,42,0,38,0,105,108,108,101,103
	DB 97,108,32,97,100,100,114,101,115,115
	DB 0,43,43,0,45,45,0,91,0,99
	DB 97,110,39,116,32,115,117,98,115,99
	DB 114,105,112,116,0,93,0,99,97,110
	DB 39,116,32,115,117,98,115,99,114,105
	DB 112,116,0,93,0,40,0,40,0,41
	DB 0,105,110,118,97,108,105,100,32,101
	DB 120,112,114,101,115,115,105,111,110,0
	DB 40,0,41,0,43,0,45,0,39,0
	DB 115,116,114,105,110,103,32,115,112,97
	DB 99,101,32,101,120,104,97,117,115,116
	DB 101,100,0,103,108,111,98,97,108,32
	DB 115,121,109,98,111,108,32,116,97,98
	DB 108,101,32,111,118,101,114,102,108,111
	DB 119,0,97,117,116,111,44,32,115,121
	DB 109,98,111,108,32,116,97,98,108,101
	DB 32,111,118,101,114,102,108,111,119,0
	DB 99,99,0,116,111,111,32,109,97,110
	DB 121,32,97,99,116,105,118,101,32,119
	DB 104,105,108,101,115,0,110,111,32,97
	DB 99,116,105,118,101,32,119,104,105,108
	DB 101,115,0,109,105,115,115,105,110,103
	DB 32,113,117,111,116,101,0,109,105,115
	DB 115,105,110,103,32,97,112,111,115,116
	DB 114,111,112,104,101,0,108,105,110,101
	DB 32,116,111,111,32,108,111,110,103,0
	DB 32,32,32,32,32,42,32,42,32,42
	DB 32,32,115,109,97,108,108,45,99,32
	DB 99,111,109,112,105,108,101,114,32,32
	DB 42,32,42,32,42,0,32,32,32,32
	DB 32,32,32,32,32,32,32,32,32,32
	DB 98,121,32,82,111,110,32,67,97,105
	DB 110,0,42,32,78,65,83,77,32,86
	DB 101,114,115,32,99,48,46,50,46,55
	DB 44,32,70,101,98,46,32,50,48,48
	DB 57,44,32,115,95,100,117,98,114,111
	DB 118,105,99,104,64,121,97,104,111,111
	DB 46,99,111,109,32,42,0,68,111,32
	DB 121,111,117,32,119,97,110,116,32,116
	DB 104,101,32,99,45,116,101,120,116,32
	DB 116,111,32,97,112,112,101,97,114,63
	DB 32,40,104,105,110,116,58,32,121,41
	DB 32,0,68,111,32,121,111,117,32,119
	DB 105,115,104,32,116,104,101,32,103,108
	DB 111,98,97,108,115,32,116,111,32,98
	DB 101,32,100,101,102,105,110,101,100,63
	DB 32,40,104,105,110,116,58,32,121,41
	DB 32,0,83,116,97,114,116,105,110,103
	DB 32,110,117,109,98,101,114,32,102,111
	DB 114,32,108,97,98,101,108,115,63,32
	DB 40,104,105,110,116,58,32,48,41,32
	DB 0,79,117,116,112,117,116,32,102,105
	DB 108,101,110,97,109,101,63,32,0,119
	DB 0,79,112,101,110,32,102,97,105,108
	DB 117,114,101,33,0,73,110,112,117,116
	DB 32,102,105,108,101,110,97,109,101,63
	DB 32,0,114,0,79,112,101,110,32,102
	DB 97,105,108,117,114,101,0,109,105,115
	DB 115,105,110,103,32,99,108,111,115,105
	DB 110,103,32,98,114,97,99,107,101,116
	DB 0,32,101,114,114,111,114,115,32,105
	DB 110,32,99,111,109,112,105,108,97,116
	DB 105,111,110,46,0,48,0,114,0,79
	DB 112,101,110,32,102,97,105,108,117,114
	DB 101,32,111,110,32,105,110,99,108,117
	DB 100,101,32,102,105,108,101,0,105,108
	DB 108,101,103,97,108,32,115,121,109,98
	DB 111,108,32,110,97,109,101,0,97,108
	DB 114,101,97,100,121,32,100,101,102,105
	DB 110,101,100,0,109,105,115,115,105,110
	DB 103,32,98,114,97,99,107,101,116,0
	DB 109,117,115,116,32,98,101,32,108,118
	DB 97,108,117,101,0,79,117,116,112,117
	DB 116,32,102,105,108,101,32,101,114,114
	DB 111,114,0,42,42,42,42,42,42,32
	DB 32,0,32,32,42,42,42,42,42,42
	DB 0,83,109,97,108,108,45,99,32,67
	DB 111,109,112,105,108,101,114,32,114,101
	DB 118,32,49,46,49,32,114,101,58,78
	DB 65,83,77,32,99,48,46,50,46,55
	DB 32,70,101,98,46,32,50,48,48,57
	DB 0,91,77,65,80,32,65,76,76,32
	DB 78,67,67,82,49,46,77,65,80,93
	DB 0,83,69,67,84,73,79,78,32,46
	DB 116,101,120,116,32,118,115,116,97,114
	DB 116,61,48,49,48,48,104,0,45,61
	DB 32,69,78,68,32,61,45,0,77,79
	DB 86,32,32,65,76,44,91,0,93,0
	DB 67,66,87,0,77,79,86,32,32,65
	DB 88,44,91,0,93,0,65,68,68,32
	DB 32,65,88,44,83,80,0,77,79,86
	DB 32,32,91,0,93,44,65,76,0,77
	DB 79,86,32,32,91,0,93,44,65,88
	DB 0,77,79,86,32,32,91,66,88,93
	DB 44,65,76,0,77,79,86,32,32,91
	DB 66,88,93,44,65,88,0,80,79,80
	DB 32,32,66,80,0,77,79,86,32,32
	DB 91,66,80,93,44,65,76,0,77,79
	DB 86,32,32,91,66,80,93,44,65,88
	DB 0,77,79,86,32,32,66,80,44,65
	DB 88,0,77,79,86,32,32,65,76,44
	DB 91,66,121,116,101,32,66,80,93,0
	DB 67,66,87,0,77,79,86,32,32,66
	DB 80,44,65,88,0,77,79,86,32,32
	DB 65,88,44,91,66,80,93,0,88,67
	DB 72,71,32,65,88,44,66,88,0,77
	DB 79,86,32,32,65,88,44,0,80,85
	DB 83,72,32,65,88,0,80,79,80,32
	DB 32,66,88,0,88,67,72,71,32,91
	DB 83,80,93,44,65,88,0,67,65,76
	DB 76,32,0,82,69,84,0,36,43,53
	DB 0,67,65,76,76,32,91,65,88,93
	DB 0,74,77,80,32,32,0,67,77,80
	DB 32,32,65,88,44,48,0,74,78,69
	DB 32,32,36,43,53,0,74,77,80,32
	DB 32,0,59,45,59,32,83,69,67,84
	DB 73,79,78,32,46,100,115,101,103,32
	DB 97,108,105,103,110,61,49,54,32,59
	DB 59,32,99,111,109,109,101,110,116,101
	DB 100,32,111,117,116,32,102,111,114,32
	DB 46,99,111,109,32,118,101,114,115,105
	DB 111,110,0,68,66,32,0,84,73,77
	DB 69,83,32,0,68,87,32,0,65,68
	DB 68,32,32,83,80,44,0,68,69,67
	DB 32,32,83,80,0,80,85,83,72,32
	DB 48,0,65,68,68,32,32,83,80,44
	DB 0,65,68,68,32,32,65,88,44,65
	DB 88,0,65,68,68,32,32,65,88,44
	DB 66,88,0,83,85,66,32,32,66,88
	DB 44,65,88,0,77,79,86,32,32,65
	DB 88,44,66,88,0,77,85,76,32,32
	DB 66,88,0,88,67,72,71,32,65,88
	DB 44,66,88,0,77,79,86,32,32,68
	DB 88,44,48,0,68,73,86,32,32,66
	DB 88,0,77,79,86,32,32,66,88,44
	DB 68,88,0,88,67,72,71,32,65,88
	DB 44,66,88,0,67,87,68,0,73,68
	DB 73,86,32,66,88,0,77,79,86,32
	DB 32,66,88,44,68,88,0,79,82,32
	DB 32,32,65,88,44,66,88,0,88,79
	DB 82,32,32,65,88,44,66,88,0,65
	DB 78,68,32,32,65,88,44,66,88,0
	DB 77,79,86,32,32,67,76,44,65,76
	DB 0,77,79,86,32,32,65,88,44,66
	DB 88,0,83,65,82,32,32,65,88,44
	DB 67,76,0,77,79,86,32,32,67,76
	DB 44,65,76,0,77,79,86,32,32,65
	DB 88,44,66,88,0,83,65,76,32,32
	DB 65,88,44,67,76,0,78,69,71,32
	DB 32,65,88,0,78,79,84,32,32,65
	DB 88,0,73,78,67,32,32,65,88,0
	DB 68,69,67,32,32,65,88,0,67,77
	DB 80,32,32,66,88,44,65,88,0,77
	DB 79,86,32,32,65,88,44,49,0,74
	DB 90,32,32,32,36,43,53,0,77,79
	DB 86,32,32,65,88,44,48,0,67,77
	DB 80,32,32,66,88,44,65,88,0,77
	DB 79,86,32,32,65,88,44,49,0,74
	DB 78,90,32,32,36,43,53,0,77,79
	DB 86,32,32,65,88,44,48,0,67,77
	DB 80,32,32,66,88,44,65,88,0,77
	DB 79,86,32,32,65,88,44,49,0,74
	DB 76,32,32,32,36,43,53,0,77,79
	DB 86,32,32,65,88,44,48,0,67,77
	DB 80,32,32,66,88,44,65,88,0,77
	DB 79,86,32,32,65,88,44,49,0,74
	DB 76,69,32,32,36,43,53,0,77,79
	DB 86,32,32,65,88,44,48,0,67,77
	DB 80,32,32,66,88,44,65,88,0,77
	DB 79,86,32,32,65,88,44,49,0,74
	DB 71,32,32,32,36,43,53,0,77,79
	DB 86,32,32,65,88,44,48,0,67,77
	DB 80,32,32,66,88,44,65,88,0,77
	DB 79,86,32,32,65,88,44,49,0,74
	DB 71,69,32,32,36,43,53,0,77,79
	DB 86,32,32,65,88,44,48,0,67,77
	DB 80,32,32,66,88,44,65,88,0,77
	DB 79,86,32,32,65,88,44,49,0,74
	DB 66,32,32,32,36,43,53,0,77,79
	DB 86,32,32,65,88,44,48,0,67,77
	DB 80,32,32,66,88,44,65,88,0,77
	DB 79,86,32,32,65,88,44,49,0,74
	DB 66,69,32,32,36,43,53,0,77,79
	DB 86,32,32,65,88,44,48,0,67,77
	DB 80,32,32,66,88,44,65,88,0,77
	DB 79,86,32,32,65,88,44,49,0,74
	DB 65,32,32,32,36,43,53,0,77,79
	DB 86,32,32,65,88,44,48,0,67,77
	DB 80,32,32,66,88,44,65,88,0,77
	DB 79,86,32,32,65,88,44,49,0,74
	DB 65,69,32,32,36,43,53,0,77,79
	DB 86,32,32,65,88,44,48,0,45,61
	DB 32,83,116,114,105,110,103,32,109,97
	DB 120,101,100,32,101,114,114,111,114,32
	DB 61,45,36,0,78,111,32,65,118,97
	DB 105,108,97,98,108,101,32,73,79,68
	DB 36,0,102,111,112,101,110,32,83,84
	DB 65,84,69,95,69,82,32,101,114,114
	DB 111,114,46,36,0,67,67,66,32,70
	DB 105,108,101,32,66,117,102,102,101,114
	DB 32,97,115,115,105,103,110,101,100,46
	DB 36,0,102,111,112,101,110,32,114,101
	DB 115,117,108,116,32,114,101,112,111,114
	DB 116,115,32,110,111,116,32,110,117,108
	DB 108,46,36,0,102,111,112,101,110,32
	DB 114,101,115,117,108,116,32,114,101,112
	DB 111,114,116,115,32,110,117,108,108,46
	DB 36,0,70,105,108,101,32,78,111,116
	DB 32,70,111,117,110,100,32,102,111,114
	DB 32,114,101,97,100,105,110,103,44,32
	DB 69,114,114,111,114,46,46,36,0,70
	DB 105,108,101,32,70,111,117,110,100,32
	DB 97,110,100,32,79,112,101,110,101,100
	DB 32,102,111,114,32,82,101,97,100,105
	DB 110,103,46,36,0,70,105,108,101,32
	DB 78,111,116,32,70,111,117,110,100,32
	DB 102,111,114,32,119,114,105,116,105,110
	DB 103,44,32,67,114,101,97,116,105,110
	DB 103,46,46,36,0,32,45,70,105,108
	DB 101,32,67,114,101,97,116,101,100,32
	DB 102,111,114,32,87,114,105,116,105,110
	DB 103,45,32,36,0,32,45,77,97,106
	DB 111,114,32,70,77,79,68,69,32,101
	DB 114,114,111,114,45,32,36,0,102,99
	DB 108,111,115,101,32,114,101,115,117,108
	DB 116,32,114,101,112,111,114,116,115,32
	DB 110,117,108,108,44,32,115,117,99,99
	DB 101,115,115,46,36,0,102,99,108,111
	DB 115,101,32,114,101,115,117,108,116,32
	DB 114,101,112,111,114,116,115,32,110,111
	DB 116,32,110,117,108,108,44,32,102,97
	DB 105,108,46,36,0,79,83,95,102,99
	DB 32,114,101,115,117,108,116,32,114,101
	DB 112,111,114,116,115,32,110,117,108,108
	DB 44,32,115,117,99,99,101,115,115,46
	DB 36,0,79,83,95,102,99,32,114,101
	DB 115,117,108,116,32,114,101,112,111,114
	DB 116,115,32,110,111,110,45,110,117,108
	DB 108,44,32,101,114,114,111,114,46,36
	DB 0,70,105,108,101,32,77,111,100,101
	DB 32,69,114,114,111,114,44,32,110,111
	DB 116,32,111,112,101,110,101,100,32,102
	DB 111,114,32,82,101,97,100,105,110,103
	DB 36,0,45,61,32,69,110,100,32,111
	DB 102,32,70,105,108,101,32,82,101,97
	DB 99,104,101,100,32,61,45,32,36,0
	DB 83,84,68,73,78,32,32,32,73,79
	DB 66,0,83,84,68,79,85,84,32,32
	DB 73,79,66,0,83,84,68,69,82,82
	DB 32,32,73,79,66,0,73,78,70,73
	DB 76,69,32,32,84,88,84,0,79,85
	DB 84,70,73,76,69,32,84,88,84,0
	DB 84,69,77,80,32,32,32,32,84,88
	DB 84,0,114,0,119,0,119,0,110,0
	DB 110,0,110,0
	;-; SECTION .dseg align=16 ;; commented out for .com version
symtab:	TIMES 5760	DB 	0
staticptr:	TIMES 1	DW 	0
autoptr:	TIMES 1	DW 	0
wq:	TIMES 100	DW 	0
wqptr:	TIMES 1	DW 	0
litq:	TIMES 4000	DB 	0
litptr:	TIMES 1	DW 	0
macq:	TIMES 2176	DB 	0
macptr:	TIMES 1	DW 	0
line:	TIMES 80	DB 	0
mline:	TIMES 80	DB 	0
lptr:	TIMES 1	DW 	0
mptr:	TIMES 1	DW 	0
nxtlab:	TIMES 1	DW 	0
litlab:	TIMES 1	DW 	0
c_sp:	TIMES 1	DW 	0
argstk:	TIMES 1	DW 	0
ncmp:	TIMES 1	DW 	0
errcnt:	TIMES 1	DW 	0
eof_flg:	TIMES 1	DW 	0
fp_in:	TIMES 1	DW 	0
fp_out:	TIMES 1	DW 	0
fp_in2:	TIMES 1	DW 	0
staticflag:	TIMES 1	DW 	0
ctext:	TIMES 1	DW 	0
cmode:	TIMES 1	DW 	0
lastst:	TIMES 1	DW 	0
quote:	TIMES 2	DB 	0
cptr:	TIMES 1	DW 	0
iptr:	TIMES 1	DW 	0
_iod:	TIMES 6	DW 	0
f_unit0:	TIMES 1	DB 	0
fdd_01:	TIMES 171	DB 	0
f_unit1:	TIMES 1	DB 	0
fdd_02:	TIMES 171	DB 	0
f_unit2:	TIMES 1	DB 	0
fdd_03:	TIMES 171	DB 	0
f_unit3:	TIMES 1	DB 	0
fdd_04:	TIMES 171	DB 	0
f_unit4:	TIMES 1	DB 	0
fdd_05:	TIMES 171	DB 	0
f_unit5:	TIMES 1	DB 	0
fdd_06:	TIMES 171	DB 	0
fdta:	TIMES 128	DB 	0
tbuff:	TIMES 257	DB 	0
ubuff:	TIMES 257	DB 	0
cp:	TIMES 0	DW 	0

;0 errors in compilation.
;	-= END =-
</CODE></PRE>
<!-- www.000webhost.com Analytics Code -->
<script type="text/javascript" src="http://analytics.hosting24.com/count.php"></script>
<noscript><a href="http://www.hosting24.com/"><img src="http://analytics.hosting24.com/count.php" alt="web hosting" /></a></noscript>
<!-- End Of Analytics Code -->
