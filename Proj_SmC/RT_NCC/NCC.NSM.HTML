<html>
<P>
<I>
This is the Self-Compiled Output of NCC.COM on NCC.C in NASM assembler syntax.  This was my goal for this stage of development.  The MAP file shows a code size of: Length 0000B894h bytes.  COM files have their stack pointer initialized to SP:FFF0h & CS=DS=SS, by the loader, with a load offset at 0100h.  So the address for the end of the code is B994h, and the space from there to FFF0h is the stack area, or 456Ch for the approximate stack space.  All Locals, variables declared in a function after the opening brace, are local to the stack, created and placed on the stack, including declared arrays.  Recursive Functions create new copies on the stack, of Locals, each time they reenter themselves, something to be mindful of.  Only String Constants, surrounded by double quotes, are placed in the data area, they are Static Storage Class, K&R C Appendix A, 2.5, for reference.
</I>
</P>
<code>
<pre>
;Small-c Compiler rev 1.1 re:NASM c0.1.5 Aug 2008
	[MAP ALL SCCN.MAP]
	SECTION .text vstart=0100h

;/************************************************/ 
;/** Last: 8:53 PM 8/14/2008 NCC.C               */ 
;/** By: s_dubrovich@yahoo.com                  **/ 
;/** Vers: c0.1.5 New: inc macro pool 1664->2176 */ 
;/** Stat: compiles itself! Vers for .com by mod */ 
;/**  vstart=0100h, and commenting out section   */ 
;/**  .dseg to form small model CS=DS=SS, the    */ 
;/**  CMD.EXE dpmi server sets SP=FFF0h on load- */ 
;/**  ing a .COM file at segment:0100h and the   */ 
;/**  Program Segment Prefix is initialized with */ 
;/**  the legacy Location 0005h Vector for the   */ 
;/**  CP/M-80 API Emulation under dos fcb struct-*/ 
;/**  ures, also using the CP/M-80 ABI register  */ 
;/**  usage. see: http://www.patersontech.com/   */ 
;/**   dos/Docs/86_Dos_inst_.pdf                 */ 
;/**  also, added user input hints..             */ 
;/************************************************/ 
;/** Last: 8:41 PM 8/2/2008                      */ 
;/** Vers: c0.1.4 New: inc macro pool 1400->1664 */ 
;/** Stat: Successfully compiles itself with the */ 
;/**  current IO library!                        */ 
;/************************************************/ 
;/** Last: 11:36 AM 8/2/2008                     */ 
;/** Vers: 0.1.3 New: incr macro pool 1200->1400 */ 
;/**             gains about +18                 */ 
;/************************************************/ 
;/** Last: 25-Jul-08 07:26:13 AM                 */ 
;/** Vers: 0.1.3 New: chg parse return to exit(),*/ 
;/**  reverted nl().                             */ 
;/************************************************/ 
;/** Last: 24-Jul-08 08:15:15 PM                 */ 
;/** Vers: 0.1.2 New: DIV(), SDIV()              */ 
;/************************************************/ 
;/** SCNXa.C for LVL1 compile w/ POWERC          */ 
;/** SCNX.C for LVL2 compile w/ SCNXa.EXE        */ 
;/** Extern Files Req'd: IOC5.C for LVL2.        */ 
;/** POWERC compiles K&R with pcDos iolib which  */ 
;/** runs under win XP thru CMD.EXE, a DPMIv.9   */ 
;/** server, this is a LVL1 build.  LVL2 build   */ 
;/** binds a Call_5 legacy io-lib, which mimics  */  
;/** CP/M-80 io functions under pcDos.  LVL2 is a*/ 
;/** 'stand-in' for your hobby io-lib.  It shows */ 
;/** the cross development step needed to boot-  */ 
;/** strap mimimalist small-c for your hobby OS. */ 
;/** Since this demonstrates small-c compiling   */ 
;/** itself, along with grafting a minimal custom*/ 
;/** io-lib, it shows how the migration path to a*/ 
;/** new hobby OS platform can be achieved with  */ 
;/** small-c initially.  The back-end assembler  */ 
;/** syntax chosen is for NASM, 16bit small model*/ 
;/** with an eye for 32bit multi-segmented, or   */ 
;/** 64 bit later on.                            */ 
;/************************************************/ 
;/** Modified for NASM as SCNX.C Small-C, nasm   */ 
;/** Last: 7:45 AM 7/6/2008                      */ 
;/** Prev: 29 JUL 2007 Init: 31 MAR 2007         */ 
;/** By: s_dubrovich@yahoo.com                  **/ 
;/** Vers: 0.1.2b  Goal: NASM ouput, Call5 i.f. **/ 
;/** Base: from SCN_all.c &increase macro tblsz **/ 
;/************************************************/ 
;/** Modified for NASM as SCN_I.C Small-C, nasm **/ 
;/** Last: 27 APR 2008                           */ 
;/** Prev: 29 JUL 2007 Init: 31 MAR 2007        **/ 
;/** By: s_dubrovich@yahoo.com                  **/ 
;/** Vers: 0.0.4b  Goal: NASM ouput             **/ 
;/** Stat: incomplete modules                    */ 
;/************************************************/ 
;/* 9:03 AM 4/27/2008                            */ 
;/* remove angle brkts of include stdio.h        */ 
;/* for self compile testing.                    */ 
;/************************************************/ 
;/* 9:17 AM 5/21/2008                            */ 
;/* added outhexb(int) in scn_v.c                */ 
;/** for PowerC             **/ 
;/** #include "scn_i.c"     **/ 
;/** #include "scn_ii.c"    **/ 
;/** #include "scn_iii.c"   **/ 
;/** #include "scn_iv.c"    **/ 
;/** #include "scn_v.c"     **/ 
;/**                        **/ 
;/************************************************/ 
;/** Modified for NASM as SCN_I.C Small-C, nasm **/ 
;/** Last: 29 JUL 2007 Init: 31 MAR 2007        **/ 
;/** By: s_dubrovich@yahoo.com                  **/ 
;/** Vers: 0.0.3b  Goal: NASM ouput             **/ 
;/**                                            **/ 
;/************************************************/ 
;/* ToBe Modified for NASM as SCCN.C --          */ 
;/*  Small-C Compiler - Nasm                     */ 
;/* Last: 15 JUL 2007 Init: 14 JUL 2007          */ 
;/* By: s_dubrovich@yahoo.com                    */ 
;/* Vers: 0.0.1b  Goal: NASM ouput               */ 
;/* Comments:                                    */ 
;/*  This is a new offshoot of development from  */ 
;/*  NCn.C as changes beyond CC8.C are intended. */ 
;/*  NCn.C is Archived, Closed to further        */ 
;/*  development, superceded by this effort SCCN.*/ 
;/* EndComments:                                 */ 
;/** SCCN.C is parked                           **/ 
;/************************************************/ 
;/** New Development Branch                     **/ 
;/************************************************/ 
;/** Re-Codified as:                            **/ 
;/**     I.   Global Storage Defn, main()       **/ 
;/**     II.  Recursive Descent Parser          **/ 
;/**     III. Utility Functions                 **/ 
;/**     IV.  U.I. & I/O                        **/ 
;/**     V.   Backend, NASM Object Output       **/ 
;/************************************************/ 
;/************************************************/ 
;/*                                              */ 
;/*              small-c compiler                */ 
;/*                  rev. 1.1                    */ 
;/*                by Ron Cain                   */ 
;/*                  (1980)                      */ 
;/************************************************/ 
;/* #define NULL 0 -for PowerC */ 
;/* #define eol 13 -for PowerC */ 
; 
;/*	UNIX definitions (if not stand-alone)	*/ 
;/* #include <stdio.h>	*/ 
;/* #define eol 10	*/ 
; 
;/* Note use PowerC Library */ 
;/* #include <stdio.h>		**/ 
;/* #include stdio.h * remove angle brkts */ 
;/* #define eol 10	*/ 
; 
;/** SCNX.C & CALL5_IO.C attempt self compile   **/ 
;#define eol 10	/** this is correct **/ 
;#define NULL 0 
;/** move to the end --> #include IOC5.C         */ 
;/** However, initfcb() still must be called     */ 
;/**  before main(), so include stub function,   */ 
;/**  just ahead of file io in main().           */ 
;/************************************************/ 
;/** Appendix A                                 **/ 
;/**  4. C bases interp. of Identifier upon two **/ 
;/**     attributes: Storage Class and its Type.**/ 
;/** Storage Class determines Location, Lifetime**/ 
;/** Type determines the meaning of the values  **/ 
;/**  found in the identifier's storage.        **/ 
;/** Storage Classes[4]={auto,static,extern,reg}**/ 
;/** Type[Object]={char,int[3],float,double}    **/ 
;/**  Type[derived]={array,functions,pointer,   **/ 
;/**                 structures,unions}         **/ 
;/**  5. Objects and lvalues - An Object is a   **/ 
;/** manipulatable region of storage, an lvalue **/ 
;/** is an expression refering to an object.    **/ 
;/************************************************/ 
; 
;/*	Define the symbol table parameters	*/ 
; 
;#define	symsiz	16 /* incr sz by 2 for name */ 
; 
;/** #define	symtbsz	5040	**/ 
;#define symtbsz	5760  /** 360x16 **/ 
;#define numglbs 300 
;#define	numlocals	60	/* new def */ 
;#define	startglb symtab 
;#define	endglb	startglb+numglbs*symsiz /**4200**/ 
;#define	startloc endglb+symsiz          /**4214**/ 
;#define	endloc	symtab+symtbsz-symsiz /**net812**/ 
;/** 812 div by symsiz = 58 locals              **/ 
;/**--------------------------------------------**/ 
;/*	Define symbol table entry format	*/ 
;/** modified for longer symbol name 		*/ 
;#define	name	0	/** length 11 {0..10}  **/ 
;#define	ident	11	/** length 1           **/ 
;#define	type	12      /** length 1           **/ 
;#define	storage	13      /** length 1           **/ 
;#define	offset	14      /** length 2 {12..13}  **/ 
; 
;/*	System wide name size (for symbols)	*/ 
;#define	namesize 9 
;#define	namemax  8 
; 
;/*	Define possible entries for "ident"	*/ 
;/** Derived Types-                             **/ 
;#define	variable 1 
;#define	array	2 
;#define	pointer	3 
;#define	function 4 
; 
;/*	Define possible entries for "type"	*/ 
;#define	cchar	1  /** 8 bits **/ 
;#define	cint	2  /** 16 bits **/ 
; 
;/*	Define possible entries for "storage"	*/ 
;/** Storage Class-                             **/ 
;#define	statik	1 
;#define	stkloc	2 
; 
;/**--------------------------------------------**/ 
;/**	Define possible entries for "segment"  **/ 
;#define cseg 1  /** code **/ 
;#define dseg 2  /** data **/ 
;#define eseg 3  /** extra **/ 
;#define sseg 4  /** stack **/ 
;#define fseg 5  /** FS    **/ 
;#define gseg 6  /** GS    **/ 
;#define aux1 7  /** local heap **/ 
;#define aux2 8  /** DTA, data transfer area **/ 
;#define init 9  /** initialize on loading **/ 
;#define ntry 10 /** module entry **/ 
;#define stat 11 /** module status, exceptions **/ 
; 
;/**--------------------------------------------**/ 
;/*	Define the "while" statement queue	*/ 
;#define	wqtabsz	100	/** {0..24} entries    **/ 
;#define	wqsiz	4   /** ea. entry size, 4 bytes**/ 
;#define	wqmax	wq+wqtabsz-wqsiz /**lim offs 96**/ 
; 
;/*	Define entry offsets in while queue	*/ 
;/** Entry of byte elements of indexes:         **/ 
;#define	wqsym	0 
;#define	wqsp	1 
;#define	wqloop	2 
;#define	wqlab	3 
; 
;/**--------------------------------------------**/ 
;/*      Define the literal pool                 */ 
;/*#define	litabsz	2000                    */ 
;/** 2000 limit reached on self compile [1]      */ 
;#define litabsz 4000   
;#define	litmax	litabsz-1 
; 
;/**--------------------------------------------**/ 
;/*      Define the input line                   */ 
;#define	linesize 80 
;#define	linemax	linesize-1 
;#define	mpmax	linemax 
; 
;/**--------------------------------------------**/ 
;/*      Define the macro (define) pool          */ 
;#define	macqsize 2176 /** was 1664 **/ 
;#define	macmax	macqsize-1 
; 
;/**--------------------------------------------**/ 
;/*      Define statement types (tokens)         */ 
;#define	stif	1 
;#define	stwhile	2 
;#define	streturn 3 
;#define	stbreak	4 
;#define	stcont	5 
;#define	stasm	6 
;#define	stexp	7 
; 
; 
;/*      Now reserve some storage words           */ 
;char	symtab[symtbsz];  /* symbol table        */ 
;char	*glbptr,*locptr;  /* ptrs to next entries*/ 
;int	wq[wqtabsz];      /* while queue         */ 
;int	*wqptr;           /* ptr to next entry   */ 
; 
;char	litq[litabsz];    /* literal pool        */ 
;int	litptr;           /* ptr to next entry   */ 
; 
;char	macq[macqsize];   /* macro string buffer */ 
;int	macptr;           /* and its index       */ 
; 
;char	line[linesize];   /* parsing buffer      */ 
;char	mline[linesize];  /* temp macro buffer   */ 
;int	lptr,mptr;        /* ptrs into each      */ 
; 
;/*      Misc storage                             */ 
;int	nxtlab,           /* next avail label #  */ 
;	litlab,  /* label # assigned to literal pool*/ 
;	c_sp,    /* compiler relative stk ptr       */ 
;	argstk,  /* function arg c_sp               */ 
;	ncmp,    /* # open compound statements      */ 
;	errcnt,  /* # errors in compilation         */ 
;	eof,     /* set non-zero on final input eof */ 
;	input,   /* iob # for input file            */ 
;	output,  /* iob # for output file (if any)  */ 
;	input2,  /* iob # for "include" file        */ 
;	glbflag, /* non-zero if internal globals    */ 
;	ctext,   /* non-zero to intermix c-source   */ 
;	cmode,   /* non-zero while parsing c-code   */ 
;                 /* zero when passing assembly code */ 
;	lastst;  /* last executed statement type    */ 
; 
;char	quote[2];/* literal string for '"'      */ 
;char	*cptr;   /* work ptr to any char buffer */ 
;int	*iptr;   /* work ptr to any int buffer  */ 
; 
;/************************************************/ 
;/** Module: SCCN1.C                            **/ 
;/** Last: 20 JUL 2007  Init: 14 JUL 2007       **/ 
;/** Vers: 0.0.2b  Goal: Self Compile, Nasm out **/ 
;/** Modified for NASM by s_dubrovich@yahoo.com **/ 
;/************************************************/ 
;/** modified dumpglbs, dumplits                **/ 
; 
;/*	>>>>> start cc1 <<<<<<		*/ 
;/*					*/ 
;/*	Compiler begins execution here	*/ 
;/*					*/ 
;main() 
main:
;	{ 
;	glbptr=startglb; /* clear global symbols */ 
	MOV  AX,symtab
	MOV  [glbptr	],AX
;	locptr=startloc; /* clear local symbols  */ 
	MOV  AX,symtab
	PUSH AX
	MOV  AX,300
	PUSH AX
	MOV  AX,16
	POP  BX
	MUL  BX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,16
	POP  BX
	ADD  AX,BX
	MOV  [locptr	],AX
;	wqptr=wq;       /* clear while queue     */ 
	MOV  AX,wq
	MOV  [wqptr	],AX
;	macptr=         /* clear the macro pool  */ 
;	litptr=         /* clear literal pool    */ 
;  	c_sp =          /* stack ptr (relative)  */ 
;	errcnt=         /* no errors             */ 
;	eof=            /* not eof yet           */ 
;	input=          /* no input file         */ 
;	input2=         /* or include file       */ 
;	output=         /* no open units         */ 
;	ncmp=           /* no open compound states*/ 
;	lastst=         /* no last statement yet*/ 
;	quote[1]= 
	MOV  AX,quote
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	PUSH AX
;	0;              /*  ...all set to zero..*/ 
	MOV  AX,0
	POP  BX
	MOV  [BX],AL
	MOV  [lastst	],AX
	MOV  [ncmp	],AX
	MOV  [output	],AX
	MOV  [input2	],AX
	MOV  [input	],AX
	MOV  [eof	],AX
	MOV  [errcnt	],AX
	MOV  [c_sp	],AX
	MOV  [litptr	],AX
	MOV  [macptr	],AX
;	quote[0]='"';   /* fake a quote literal */ 
	MOV  AX,quote
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,34
	POP  BX
	MOV  [BX],AL
;	cmode=1;        /* enable preprocessing */ 
	MOV  AX,1
	MOV  [cmode	],AX
;/***--------------------------------------------*/ 
;/*** IO Init code before file use, in IOC5.C ****/ 
;	initfcb();  
	CALL initfcb
;/***--------------------------------------------*/ 
;/*	                        */ 
;/*	compiler body           */ 
;/*	                        */ 
;	ask();       /* get user options        */ 
	CALL ask
;	openout();   /* get an output file      */ 
	CALL openout
;	openin();    /* and initial input file  */ 
	CALL openin
;	header();    /* intro code              */ 
	CALL header
;	parse();     /* process ALL input       */ 
	CALL parse
;		 /** added back in **/ 
;	dumplits();  /* then dump literal pool  */ 
	CALL dumplits
;/** dump global static defs. to output source, required **/ 
;	dumpglbs();  /* and all static memory   */ 
	CALL dumpglbs
;		/** original place, added back in **/ 
;	errorsummary(); /* summarize errors     */ 
	CALL errorsum
;	trailer();   /* follow-up code          */ 
	CALL trailer
;	closeout();  /* close the output (if any) */ 
	CALL closeout
;/***	return;	** then exit to system */ 
;	exit(); /*** sjd 25-JUL-2008 ***/ 
	CALL exit
;	} 
	RET
;/********************************/ 
;/*				*/ 
;/** for PowerC 			**/ 
;/** see "scn_all.c"		**/ 
;/** #include "scn_ii.c"		**/ 
;/** #include "scn_iii.c"	**/ 
;/** #include "scn_iv.c"		**/ 
;/** #include "scn_v.c"		**/ 
;/** 				**/ 
;/** 				**/ 
;/**  SCN_I.C **/ 
;/** Next is SCN_II.C **/ 
;/************************************************/ 
;/** Modified for NASM as SCN_II.C Small-C, nasm**/ 
;/** Last: 29 JUL 2007 Init: 31 MAR 2007        **/ 
;/** By: s_dubrovich@yahoo.com                  **/ 
;/** Vers: 0.0.3b  Goal: NASM ouput             **/ 
;/**					       **/ 
;/************************************************/ 
;/* ToBe Modified for NASM as SCCN.C --          */ 
;/*  Small-C Compiler - Nasm                     */ 
;/* Last: 15 JUL 2007 Init: 14 JUL 2007          */ 
;/* By: s_dubrovich@yahoo.com                    */ 
;/* Vers: 0.0.1b  Goal: NASM ouput               */ 
;/* Comments:                                    */ 
;/*  This is a new offshoot of development from  */ 
;/*  NCn.C as changes beyond CC8.C are intended. */ 
;/*  NCn.C is Archived, Closed to further        */ 
;/*  development, superceded by this effort SCCN.*/ 
;/* EndComments:                                 */ 
;/** SCCN.C is parked                           **/ 
;/************************************************/ 
;/** New Development Branch                     **/ 
;/************************************************/ 
;/** Re-Codified as:                            **/ 
;/**	I.   Global Storage Defn, main()       **/ 
;/**     II.  Recursive Descent Parser          **/ 
;/**     III. Utility Functions                 **/ 
;/**     IV.  U.I. & I/O                        **/ 
;/**     V.   Backend, NASM Object Output       **/ 
;/************************************************/ 
;/************************************************/ 
;/*						*/ 
;/*		small-c compiler		*/ 
;/*                  rev. 1.1                    */ 
;/*		  by Ron Cain			*/ 
;/*		    (1980)			*/ 
;/************************************************/ 
;/** Fn's in this file **/ 
;/** parse(); 	** process ALL input */ 
;/** declgbl, newfunc, addmac,  doasm **/ 
;/** declloc(), put in here  **/ 
;/** doinclude(), is in SCN_IV **/ 
;/************************************************/ 
; 
;/*					*/ 
;/*	Process all input text		*/ 
;/*					*/ 
;/* At this level, only static declarations, */ 
;/*	defines, includes, and function */ 
;/*	definitions are legal...	*/ 
;parse() 
parse:
;	{ 
;	while (eof==0)		/* do until no more input */ 
cc2:
	MOV  AX,[eof	]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc3
;		{ 
;		if(amatch("char",4)){declglb(cchar);ns();} 
	MOV  AX,cc1+0
	PUSH AX
	MOV  AX,4
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc4
	MOV  AX,1
	PUSH AX
	CALL declglb
	ADD  SP,2
	CALL ns
;		else if(amatch("int",3)){declglb(cint);ns();} 
	JMP  cc5
cc4:
	MOV  AX,cc1+5
	PUSH AX
	MOV  AX,3
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc6
	MOV  AX,2
	PUSH AX
	CALL declglb
	ADD  SP,2
	CALL ns
;		else if(match("#asm"))doasm(); 
	JMP  cc7
cc6:
	MOV  AX,cc1+9
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc8
	CALL doasm
;		else if(match("#include"))doinclude(); 
	JMP  cc9
cc8:
	MOV  AX,cc1+14
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc10
	CALL doinclud
;		else if(match("#define"))addmac(); 
	JMP  cc11
cc10:
	MOV  AX,cc1+23
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc12
	CALL addmac
;		else newfunc(); 
	JMP  cc13
cc12:
	CALL newfunc
cc13:
cc11:
cc9:
cc7:
cc5:
;		blanks();	/* force eof if pending */ 
	CALL blanks
;		} 
	JMP  cc2
cc3:
;	} 
	RET
;/************************************************/ 
; 
;/*					*/ 
;/*	Declare a static variable	*/ 
;/*	  (i.e. define for use)		*/ 
;/*					*/ 
;/* makes an entry in the symbol table so subsequent */ 
;/*  references can call symbol by name	*/ 
;declglb(typ)		/* typ is cchar or cint */ 
declglb:
;	int typ; 
;{	int k,j;char sname[namesize]; 
	PUSH AX
	PUSH AX
	XCHG AX,BX
	MOV  AX,-9
	ADD  AX,SP
	MOV  SP,AX
	XCHG AX,BX
;	while(1) 
cc14:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc15
;		{while(1) 
cc16:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc17
;			{if(endst())return;	/* do line */ 
	CALL endst
	CMP  AX,0
	JNE  $+5
	JMP  cc18
	ADD  SP,13
	RET
;			k=1;		/* assume 1 element */ 
cc18:
	MOV  AX,11
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	POP  BX
	MOV  [BX],AX
;			if(match("*"))	/* pointer ? */ 
	MOV  AX,cc1+31
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc19
;				j=pointer;	/* yes */ 
	MOV  AX,9
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	POP  BX
	MOV  [BX],AX
;				else j=variable; /* no */ 
	JMP  cc20
cc19:
	MOV  AX,9
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	POP  BX
	MOV  [BX],AX
cc20:
;			if (symname(sname)==0) /* name ok? */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL symname
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc21
;				illname(); /* no... */ 
	CALL illname
;			if(findglb(sname)) /* already there? */ 
cc21:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL findglb
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc22
;				multidef(sname); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL multidef
	ADD  SP,2
;			if (match("["))		/* array? */ 
cc22:
	MOV  AX,cc1+33
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc23
;				{k=needsub();	/* get size */ 
	MOV  AX,11
	ADD  AX,SP
	PUSH AX
	CALL needsub
	POP  BX
	MOV  [BX],AX
;				if(k)j=array;	/* !0=array */ 
	MOV  AX,11
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc24
	MOV  AX,9
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	POP  BX
	MOV  [BX],AX
;				else j=pointer; /* 0=ptr */ 
	JMP  cc25
cc24:
	MOV  AX,9
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	POP  BX
	MOV  [BX],AX
cc25:
;				} 
;			addglb(sname,j,typ,k); /* add symbol */ 
cc23:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,19
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,17
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL addglb
	ADD  SP,8
;			break; 
	JMP  cc17
;			} 
	JMP  cc16
cc17:
;		if (match(",")==0) return; /* more? */ 
	MOV  AX,cc1+35
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc26
	ADD  SP,13
	RET
;		} 
cc26:
	JMP  cc14
cc15:
;	} 
	ADD  SP,13
	RET
; 
;/*					*/ 
;/*	Declare local variables		*/ 
;/*	(i.e. define for use)		*/ 
;/*					*/ 
;/* works just like "declglb" but modifies machine stack */ 
;/*	and adds symbol table entry with appropriate */ 
;/*	stack offset to find it again			*/ 
;declloc(typ)		/* typ is cchar or cint */ 
declloc:
;	int typ; 
;	{ 
;	int k,j;char sname[namesize]; 
	PUSH AX
	PUSH AX
	XCHG AX,BX
	MOV  AX,-9
	ADD  AX,SP
	MOV  SP,AX
	XCHG AX,BX
;	while(1) 
cc27:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc28
;		{while(1) 
cc29:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc30
;			{if(endst())return; 
	CALL endst
	CMP  AX,0
	JNE  $+5
	JMP  cc31
	ADD  SP,13
	RET
;			if(match("*")) 
cc31:
	MOV  AX,cc1+37
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc32
;				j=pointer; 
	MOV  AX,9
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	POP  BX
	MOV  [BX],AX
;				else j=variable; 
	JMP  cc33
cc32:
	MOV  AX,9
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	POP  BX
	MOV  [BX],AX
cc33:
;			if (symname(sname)==0) 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL symname
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc34
;				illname(); 
	CALL illname
;			if(findloc(sname)) 
cc34:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL findloc
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc35
;				multidef(sname); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL multidef
	ADD  SP,2
;			if (match("[")) 
cc35:
	MOV  AX,cc1+39
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc36
;				{k=needsub(); 
	MOV  AX,11
	ADD  AX,SP
	PUSH AX
	CALL needsub
	POP  BX
	MOV  [BX],AX
;				if(k) 
	MOV  AX,11
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc37
;					{j=array; 
	MOV  AX,9
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	POP  BX
	MOV  [BX],AX
;					if(typ==cint)k=k+k; 
	MOV  AX,15
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc38
	MOV  AX,11
	ADD  AX,SP
	PUSH AX
	MOV  AX,13
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,15
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;					} 
cc38:
;				else 
	JMP  cc39
cc37:
;					{j=pointer; 
	MOV  AX,9
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	POP  BX
	MOV  [BX],AX
;					k=2; 
	MOV  AX,11
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	POP  BX
	MOV  [BX],AX
;					} 
cc39:
;				} 
;			else 
	JMP  cc40
cc36:
;				if((typ==cchar) 
	MOV  AX,15
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
;					&(j!=pointer)) 
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc41
;					k=1;else k=2; 
	MOV  AX,11
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	POP  BX
	MOV  [BX],AX
	JMP  cc42
cc41:
	MOV  AX,11
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	POP  BX
	MOV  [BX],AX
cc42:
cc40:
;			/* change machine stack */ 
;			c_sp=mnem_modstk(c_sp-k); 
	MOV  AX,[c_sp	]
	PUSH AX
	MOV  AX,13
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	PUSH AX
	CALL mnem_mod
	ADD  SP,2
	MOV  [c_sp	],AX
;			addloc(sname,j,typ,c_sp); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,19
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,[c_sp	]
	PUSH AX
	CALL addloc
	ADD  SP,8
;			break; 
	JMP  cc30
;			} 
	JMP  cc29
cc30:
;		if (match(",")==0) return; 
	MOV  AX,cc1+41
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc43
	ADD  SP,13
	RET
;		} 
cc43:
	JMP  cc27
cc28:
;	} 
	ADD  SP,13
	RET
; 
; 
;/************************************************/ 
; 
;addmac() 
addmac:
;{	char sname[namesize]; 
	XCHG AX,BX
	MOV  AX,-9
	ADD  AX,SP
	MOV  SP,AX
	XCHG AX,BX
;	int k; 
	PUSH AX
;	if(symname(sname)==0) 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	CALL symname
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc44
;		{illname(); 
	CALL illname
;		kill(); 
	CALL kill
;		return; 
	ADD  SP,11
	RET
;		} 
;	k=0; 
cc44:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;	while(putmac(sname[k++])); 
cc45:
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	CALL putmac
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc46
	JMP  cc45
cc46:
;	while(chr()==' ' | chr()==9) gchr(); 
cc47:
	CALL chr
	PUSH AX
	MOV  AX,32
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	CALL chr
	PUSH AX
	MOV  AX,9
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc48
	CALL gchr
	JMP  cc47
cc48:
;	while(putmac(gchr())); 
cc49:
	CALL gchr
	PUSH AX
	CALL putmac
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc50
	JMP  cc49
cc50:
;	if(macptr>=macmax)error("macro table full"); 
	MOV  AX,[macptr	]
	PUSH AX
	MOV  AX,2176
	PUSH AX
	MOV  AX,1
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc51
	MOV  AX,cc1+43
	PUSH AX
	CALL error
	ADD  SP,2
;	} 
cc51:
	ADD  SP,11
	RET
; 
;putmac(c) 
putmac:
;	char c; 
;{	macq[macptr]=c; 
	MOV  AX,macq
	PUSH AX
	MOV  AX,[macptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;	if(macptr < macmax)macptr++; 
	MOV  AX,[macptr	]
	PUSH AX
	MOV  AX,2176
	PUSH AX
	MOV  AX,1
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc52
	MOV  AX,[macptr	]
	INC  AX
	MOV  [macptr	],AX
	DEC  AX
;	return c; 
cc52:
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	RET
;} 
; 
;findmac(sname) 
findmac:
;	char *sname; 
;{	int k; 
	PUSH AX
;	k=0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;	while(k < macptr) 
cc53:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,[macptr	]
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc54
;		{if(astreq(sname,macq+k,namemax)) 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,macq
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,8
	PUSH AX
	CALL astreq
	ADD  SP,6
	CMP  AX,0
	JNE  $+5
	JMP  cc55
;			{while(macq[k++]); 
cc56:
	MOV  AX,macq
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc57
	JMP  cc56
cc57:
;			return k; 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,2
	RET
;			} 
;		while(macq[k++]); 
cc55:
cc58:
	MOV  AX,macq
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc59
	JMP  cc58
cc59:
;		while(macq[k++]); 
cc60:
	MOV  AX,macq
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc61
	JMP  cc60
cc61:
;		} 
	JMP  cc53
cc54:
;	return 0; 
	MOV  AX,0
	ADD  SP,2
	RET
;} 
; 
;/************************************************/ 
;/*					*/ 
;/*	Get required array size		*/ 
;/*					*/ 
;/* invoked when declared variable is followed by "[" */ 
;/*	this routine makes subscript the absolute */ 
;/*	size of the array. */ 
; 
;needsub() 
needsub:
;	{ 
;	int num[1]; 
	PUSH AX
;	if(match("]"))return 0;	/* null size */ 
	MOV  AX,cc1+60
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc62
	MOV  AX,0
	ADD  SP,2
	RET
;	if (number(num)==0)	/* go after a number */ 
cc62:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL number
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc63
;		{error("must be constant");	/* it isn't */ 
	MOV  AX,cc1+62
	PUSH AX
	CALL error
	ADD  SP,2
;		num[0]=1;		/* so force one */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,1
	POP  BX
	MOV  [BX],AX
;		} 
;	if (num[0] < 0) 
cc63:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc64
;		{error("negative size illegal"); 
	MOV  AX,cc1+79
	PUSH AX
	CALL error
	ADD  SP,2
;		num[0]=(-num[0]); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	NEG  AX
	POP  BX
	MOV  [BX],AX
;		} 
;	needbrack("]");		/* force single dimension */ 
cc64:
	MOV  AX,cc1+101
	PUSH AX
	CALL needbrac
	ADD  SP,2
;	return num[0];		/* and return size */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,2
	RET
;	} 
; 
; 
;/*					*/ 
;/*	Begin a function		*/ 
;/*					*/ 
;/* Called from "parse" this routine tries to make a function */ 
;/*	out of what follows.	*/ 
; 
;newfunc() 
newfunc:
;	{ 
;	char n[namesize],*ptr; 
	XCHG AX,BX
	MOV  AX,-9
	ADD  AX,SP
	MOV  SP,AX
	XCHG AX,BX
	PUSH AX
;	if (symname(n)==0) 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	CALL symname
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc65
;		{error("illegal function or declaration"); 
	MOV  AX,cc1+103
	PUSH AX
	CALL error
	ADD  SP,2
;		kill();	/* invalidate line */ 
	CALL kill
;		return; 
	ADD  SP,11
	RET
;		} 
;	if(ptr=findglb(n))	/* already in symbol table ? */ 
cc65:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	CALL findglb
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc66
;		{if(ptr[ident]!=function)multidef(n); 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,4
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc67
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	CALL multidef
	ADD  SP,2
;			/* already variable by that name */ 
;		else if(ptr[offset]==function)multidef(n); 
	JMP  cc68
cc67:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,14
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,4
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc69
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	CALL multidef
	ADD  SP,2
;			/* already function by that name */ 
;		else ptr[offset]=function; 
	JMP  cc70
cc69:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,14
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,4
	POP  BX
	MOV  [BX],AL
cc70:
cc68:
;			/* otherwise we have what was earlier*/ 
;			/*  assumed to be a function */ 
;		} 
; 
;	/* if not in table, define as a function now */ 
; 
;	else addglb(n,function,cint,function); 
	JMP  cc71
cc66:
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,4
	PUSH AX
	MOV  AX,2
	PUSH AX
	MOV  AX,4
	PUSH AX
	CALL addglb
	ADD  SP,8
cc71:
; 
;	/* we had better see open paren for args... */ 
; 
;	if(match("(")==0)error("missing open paren"); 
	MOV  AX,cc1+135
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc72
	MOV  AX,cc1+137
	PUSH AX
	CALL error
	ADD  SP,2
;	outstr(n);col();nl();	/* print function name */ 
cc72:
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	CALL outstr
	ADD  SP,2
	CALL col
	CALL nl
;	argstk=0;		/* init arg count */ 
	MOV  AX,0
	MOV  [argstk	],AX
;	while(match(")")==0)	/* then count args */ 
cc73:
	MOV  AX,cc1+156
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc74
;		/* any legal name bumps arg count */ 
;		{if(symname(n))argstk=argstk+2; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	CALL symname
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc75
	MOV  AX,[argstk	]
	PUSH AX
	MOV  AX,2
	POP  BX
	ADD  AX,BX
	MOV  [argstk	],AX
;		else{error("illegal argument name");junk();} 
	JMP  cc76
cc75:
	MOV  AX,cc1+158
	PUSH AX
	CALL error
	ADD  SP,2
	CALL junk
cc76:
;		blanks(); 
	CALL blanks
;		/* if not closing paren, should be comma */ 
;		if(streq(line+lptr,")")==0) 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+180
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc77
;			{if(match(",")==0) 
	MOV  AX,cc1+182
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc78
;			error("expected comma"); 
	MOV  AX,cc1+184
	PUSH AX
	CALL error
	ADD  SP,2
;			} 
cc78:
;		if(endst())break; 
cc77:
	CALL endst
	CMP  AX,0
	JNE  $+5
	JMP  cc79
	JMP  cc74
;		} 
cc79:
	JMP  cc73
cc74:
; 
;	locptr=startloc;	/* "clear" local symbol table */ 
	MOV  AX,symtab
	PUSH AX
	MOV  AX,300
	PUSH AX
	MOV  AX,16
	POP  BX
	MUL  BX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,16
	POP  BX
	ADD  AX,BX
	MOV  [locptr	],AX
;	c_sp=0;			/* preset stack ptr */ 
	MOV  AX,0
	MOV  [c_sp	],AX
;	while(argstk) 
cc80:
	MOV  AX,[argstk	]
	CMP  AX,0
	JNE  $+5
	JMP  cc81
;		/* now let user declare what types of things */ 
;		/*	those arguments were */ 
;		{if(amatch("char",4)){getarg(cchar);ns();} 
	MOV  AX,cc1+199
	PUSH AX
	MOV  AX,4
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc82
	MOV  AX,1
	PUSH AX
	CALL getarg
	ADD  SP,2
	CALL ns
;		else if(amatch("int",3)){getarg(cint);ns();} 
	JMP  cc83
cc82:
	MOV  AX,cc1+204
	PUSH AX
	MOV  AX,3
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc84
	MOV  AX,2
	PUSH AX
	CALL getarg
	ADD  SP,2
	CALL ns
;		else{error("wrong number args");break;} 
	JMP  cc85
cc84:
	MOV  AX,cc1+208
	PUSH AX
	CALL error
	ADD  SP,2
	JMP  cc81
cc85:
cc83:
;		} 
	JMP  cc80
cc81:
; 
;	if(statement()!=streturn) /* do a statement, but if */ 
	CALL statemen
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc86
;				/* it's a return, skip */ 
;				/* cleaning up the stack */ 
;		{mnem_modstk(0); 
	MOV  AX,0
	PUSH AX
	CALL mnem_mod
	ADD  SP,2
;		mnem_ret(); 
	CALL mnem_ret
;		} 
;	c_sp=0;			/* reset stack ptr again */ 
cc86:
	MOV  AX,0
	MOV  [c_sp	],AX
;	locptr=startloc;        /* deallocate all locals */ 
	MOV  AX,symtab
	PUSH AX
	MOV  AX,300
	PUSH AX
	MOV  AX,16
	POP  BX
	MUL  BX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,16
	POP  BX
	ADD  AX,BX
	MOV  [locptr	],AX
;	} 
	ADD  SP,11
	RET
; 
;/*					*/ 
;/*	Declare argument types		*/ 
;/*					*/ 
;/* called from "newfunc" this routine adds an entry in the */ 
;/*	local symbol table for each named argument */ 
; 
;getarg(t)		/* t = cchar or cint */ 
getarg:
;	int t; 
;	{ 
;	char n[namesize],c;int j; 
	XCHG AX,BX
	MOV  AX,-9
	ADD  AX,SP
	MOV  SP,AX
	XCHG AX,BX
	DEC  SP
	PUSH AX
;	while(1) 
cc87:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc88
;		{if(argstk==0)return;	/* no more args */ 
	MOV  AX,[argstk	]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc89
	ADD  SP,12
	RET
;		if(match("*"))j=pointer; 
cc89:
	MOV  AX,cc1+226
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc90
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	POP  BX
	MOV  [BX],AX
;			else j=variable; 
	JMP  cc91
cc90:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	POP  BX
	MOV  [BX],AX
cc91:
;		if(symname(n)==0) illname(); 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	CALL symname
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc92
	CALL illname
;		if(findloc(n)) multidef(n); 
cc92:
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	CALL findloc
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc93
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	CALL multidef
	ADD  SP,2
;		if(match("["))	/* pointer ? */ 
cc93:
	MOV  AX,cc1+228
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc94
; 
;		/* it is a pointer, so skip all */ 
;		/* stuff between "[]" */ 
; 
;			{while(inbyte()!=']') 
cc95:
	CALL inbyte
	PUSH AX
	MOV  AX,93
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc96
;				if(endst())break; 
	CALL endst
	CMP  AX,0
	JNE  $+5
	JMP  cc97
	JMP  cc96
;			j=pointer; 
cc97:
	JMP  cc95
cc96:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	POP  BX
	MOV  [BX],AX
;			/* add entry as pointer */ 
;			} 
;		addloc(n,j,t,argstk); 
cc94:
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,18
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,[argstk	]
	PUSH AX
	CALL addloc
	ADD  SP,8
;		argstk=argstk-2;	/* cnt down */ 
	MOV  AX,[argstk	]
	PUSH AX
	MOV  AX,2
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	MOV  [argstk	],AX
;		if(endst())return; 
	CALL endst
	CMP  AX,0
	JNE  $+5
	JMP  cc98
	ADD  SP,12
	RET
;		if(match(",")==0)error("expected comma"); 
cc98:
	MOV  AX,cc1+230
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc99
	MOV  AX,cc1+232
	PUSH AX
	CALL error
	ADD  SP,2
;		} 
cc99:
	JMP  cc87
cc88:
;	} 
	ADD  SP,12
	RET
; 
;/*					*/ 
;/*	Statement parser		*/ 
;/*					*/ 
;/* called whenever syntax requires	*/ 
;/*	a statement. 			 */ 
;/*  this routine performs that statement */ 
;/*  and returns a number telling which one */ 
; 
;statement() 
statemen:
;{ 
;	if ((chr()==0) & (eof)) return; 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,[eof	]
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc100
	RET
;	else if(amatch("char",4)) 
	JMP  cc101
cc100:
	MOV  AX,cc1+247
	PUSH AX
	MOV  AX,4
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc102
;		{declloc(cchar);ns();} 
	MOV  AX,1
	PUSH AX
	CALL declloc
	ADD  SP,2
	CALL ns
;	else if(amatch("int",3)) 
	JMP  cc103
cc102:
	MOV  AX,cc1+252
	PUSH AX
	MOV  AX,3
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc104
;		{declloc(cint);ns();} 
	MOV  AX,2
	PUSH AX
	CALL declloc
	ADD  SP,2
	CALL ns
;	else if(match("{"))compound(); 
	JMP  cc105
cc104:
	MOV  AX,cc1+256
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc106
	CALL compound
;	else if(amatch("if",2)) 
	JMP  cc107
cc106:
	MOV  AX,cc1+258
	PUSH AX
	MOV  AX,2
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc108
;		{doif();lastst=stif;} 
	CALL doif
	MOV  AX,1
	MOV  [lastst	],AX
;/*	else if(amatch("do",2))		added by codeworks */ 
;/*		{dodo();lastst=stwhile;}	version */ 
;	else if(amatch("while",5)) 
	JMP  cc109
cc108:
	MOV  AX,cc1+261
	PUSH AX
	MOV  AX,5
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc110
;		{dowhile();lastst=stwhile;} 
	CALL dowhile
	MOV  AX,2
	MOV  [lastst	],AX
;	else if(amatch("return",6)) 
	JMP  cc111
cc110:
	MOV  AX,cc1+267
	PUSH AX
	MOV  AX,6
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc112
;		{doreturn();ns();lastst=streturn;} 
	CALL doreturn
	CALL ns
	MOV  AX,3
	MOV  [lastst	],AX
;	else if(amatch("break",5)) 
	JMP  cc113
cc112:
	MOV  AX,cc1+274
	PUSH AX
	MOV  AX,5
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc114
;		{dobreak();ns();lastst=stbreak;} 
	CALL dobreak
	CALL ns
	MOV  AX,4
	MOV  [lastst	],AX
;	else if(amatch("continue",8)) 
	JMP  cc115
cc114:
	MOV  AX,cc1+280
	PUSH AX
	MOV  AX,8
	PUSH AX
	CALL amatch
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc116
;		{docont();ns();lastst=stcont;} 
	CALL docont
	CALL ns
	MOV  AX,5
	MOV  [lastst	],AX
;	else if(match(";")); 
	JMP  cc117
cc116:
	MOV  AX,cc1+289
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc118
;	else if(match("#asm")) 
	JMP  cc119
cc118:
	MOV  AX,cc1+291
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc120
;		{doasm();lastst=stasm;} 
	CALL doasm
	MOV  AX,6
	MOV  [lastst	],AX
;	/* if nothing else, assume it's an expression */ 
;	else{expression();ns();lastst=stexp;} 
	JMP  cc121
cc120:
	CALL expressi
	CALL ns
	MOV  AX,7
	MOV  [lastst	],AX
cc121:
cc119:
cc117:
cc115:
cc113:
cc111:
cc109:
cc107:
cc105:
cc103:
cc101:
;	return lastst; 
	MOV  AX,[lastst	]
	RET
;} 
; 
;/*					*/ 
;/*	Semicolon enforcer		*/ 
;/*					*/ 
;/* called whenever syntax requires a semicolon */ 
; 
;ns()	{if(match(";")==0)error("missing semicolon");} 
ns:
	MOV  AX,cc1+296
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc122
	MOV  AX,cc1+298
	PUSH AX
	CALL error
	ADD  SP,2
cc122:
	RET
; 
; 
;/*					*/ 
;/*	Compound statement		*/ 
;/*					*/ 
;/* allow any number of statements to fall between "{}" */ 
; 
;compound() 
compound:
;	{ 
;	++ncmp;		/* new level open */ 
	MOV  AX,[ncmp	]
	INC  AX
	MOV  [ncmp	],AX
;	while (match("}")==0) 
cc123:
	MOV  AX,cc1+316
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc124
;		if(eof) return; 
	MOV  AX,[eof	]
	CMP  AX,0
	JNE  $+5
	JMP  cc125
	RET
;		else statement(); 
	JMP  cc126
cc125:
	CALL statemen
cc126:
	JMP  cc123
cc124:
;	--ncmp;		/* close current level */ 
	MOV  AX,[ncmp	]
	DEC  AX
	MOV  [ncmp	],AX
;	} 
	RET
; 
;/*					*/ 
;/*		"if" statement		*/ 
;/*					*/ 
; 
;doif() 
doif:
;	{ 
;	int flev,fsp,flab1,flab2; 
	PUSH AX
	PUSH AX
	PUSH AX
	PUSH AX
;	flev=locptr;	/* record current local level */ 
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	MOV  AX,[locptr	]
	POP  BX
	MOV  [BX],AX
;	fsp=c_sp;		/* record current stk ptr */ 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,[c_sp	]
	POP  BX
	MOV  [BX],AX
;	flab1=getlabel(); /* get label for false branch */ 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	CALL getlabel
	POP  BX
	MOV  [BX],AX
;	m_test(flab1);	/* get expression, and branch false */ 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL m_test
	ADD  SP,2
;	statement();	/* if true, do a statement */ 
	CALL statemen
;	c_sp=mnem_modstk(fsp);	/* then clean up the stack */ 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL mnem_mod
	ADD  SP,2
	MOV  [c_sp	],AX
;	locptr=flev;	/* and deallocate any locals */ 
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  [locptr	],AX
;	if (amatch("else",4)==0)	/* if...else ? */ 
	MOV  AX,cc1+318
	PUSH AX
	MOV  AX,4
	PUSH AX
	CALL amatch
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc127
;		/* simple "if"...print false label */ 
;		{printlabel(flab1);col();nl(); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL printlab
	ADD  SP,2
	CALL col
	CALL nl
;		return;		/* and exit */ 
	ADD  SP,8
	RET
;		} 
;	/* an "if...else" statement. */ 
; 
;	mnem_jump(flab2=getlabel());	/* jump around false code */ 
cc127:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL getlabel
	POP  BX
	MOV  [BX],AX
	PUSH AX
	CALL mnem_jum
	ADD  SP,2
;	printlabel(flab1);col();nl();	/* print false label */ 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL printlab
	ADD  SP,2
	CALL col
	CALL nl
;	statement();		/* and do "else" clause */ 
	CALL statemen
;	c_sp=mnem_modstk(fsp);		/* then clean up stk ptr */ 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL mnem_mod
	ADD  SP,2
	MOV  [c_sp	],AX
;	locptr=flev;		/* and deallocate locals */ 
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  [locptr	],AX
;	printlabel(flab2);col();nl();	/* print true label */ 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL printlab
	ADD  SP,2
	CALL col
	CALL nl
;	} 
	ADD  SP,8
	RET
; 
;/*					*/ 
;/*	"while" statement		*/ 
;/*					*/ 
; 
;dowhile() 
dowhile:
;	{ 
;	int wq[4];		/* allocate local queue */ 
	XCHG AX,BX
	MOV  AX,-8
	ADD  AX,SP
	MOV  SP,AX
	XCHG AX,BX
;	wq[wqsym]=locptr;	/* record local level */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,[locptr	]
	POP  BX
	MOV  [BX],AX
;	wq[wqsp]=c_sp;		/* and stk ptr */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,[c_sp	]
	POP  BX
	MOV  [BX],AX
;	wq[wqloop]=getlabel();	/* and looping label */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL getlabel
	POP  BX
	MOV  [BX],AX
;	wq[wqlab]=getlabel();	/* and exit label */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL getlabel
	POP  BX
	MOV  [BX],AX
;	addwhile(wq);		/* add entry to queue */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL addwhile
	ADD  SP,2
;				/* (for "break" statement) */ 
;	printlabel(wq[wqloop]);col();nl(); /* loop label */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL printlab
	ADD  SP,2
	CALL col
	CALL nl
;	m_test(wq[wqlab]);	/* see if true */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL m_test
	ADD  SP,2
;	statement();		/* if so, do a statement */ 
	CALL statemen
;	mnem_jump(wq[wqloop]);	/* loop to label */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL mnem_jum
	ADD  SP,2
;	printlabel(wq[wqlab]);col();nl(); /* exit label */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL printlab
	ADD  SP,2
	CALL col
	CALL nl
;	locptr=wq[wqsym];	/* deallocate locals */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  [locptr	],AX
;	c_sp=mnem_modstk(wq[wqsp]);	/* clean up stk ptr */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL mnem_mod
	ADD  SP,2
	MOV  [c_sp	],AX
;	delwhile();		/* delete queue entry */ 
	CALL delwhile
;	} 
	ADD  SP,8
	RET
; 
;/*					*/ 
;/*	"return" statement		*/ 
;/*					*/ 
; 
;doreturn() 
doreturn:
;	{ 
;	/* if not end of statement, get an expression */ 
;	if(endst()==0)expression(); 
	CALL endst
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc128
	CALL expressi
;	mnem_modstk(0);	/* clean up stk */ 
cc128:
	MOV  AX,0
	PUSH AX
	CALL mnem_mod
	ADD  SP,2
;	mnem_ret();	/* and exit function */ 
	CALL mnem_ret
;	} 
	RET
; 
;/*					*/ 
;/*	"break" statement		*/ 
;/*					*/ 
; 
;dobreak() 
dobreak:
;	{ 
;	int *ptr; 
	PUSH AX
;	/* see if any "whiles" are open */ 
;	if ((ptr=readwhile())==0) return;	/* no */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL readwhil
	POP  BX
	MOV  [BX],AX
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc129
	ADD  SP,2
	RET
;	mnem_modstk((ptr[wqsp]));	/* else clean up stk ptr */ 
cc129:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL mnem_mod
	ADD  SP,2
;	mnem_jump(ptr[wqlab]);	/* jump to exit label */ 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,3
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL mnem_jum
	ADD  SP,2
;	} 
	ADD  SP,2
	RET
; 
;/*					*/ 
;/*	"continue" statement		*/ 
;/*					*/ 
; 
;docont() 
docont:
;	{ 
;	int *ptr; 
	PUSH AX
;	/* see if any "whiles" are open */ 
;	if ((ptr=readwhile())==0) return;	/* no */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL readwhil
	POP  BX
	MOV  [BX],AX
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc130
	ADD  SP,2
	RET
;	mnem_modstk((ptr[wqsp]));	/* else clean up stk ptr */ 
cc130:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL mnem_mod
	ADD  SP,2
;	mnem_jump(ptr[wqloop]);	/* jump to loop label */ 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL mnem_jum
	ADD  SP,2
;	} 
	ADD  SP,2
	RET
; 
;/*					*/ 
;/*	"asm" pseudo-statement		*/ 
;/*					*/ 
;/* enters mode where assembly language statement are */ 
;/*	passed intact through parser	*/ 
; 
;doasm() 
doasm:
;	{ 
;	cmode=0;		/* mark mode as "asm" */ 
	MOV  AX,0
	MOV  [cmode	],AX
;	while (1) 
cc131:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc132
;		{inline();	/* get and print lines */ 
	CALL inline
;		if (match("#endasm")) break;	/* until... */ 
	MOV  AX,cc1+323
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc133
	JMP  cc132
;		if(eof)break; 
cc133:
	MOV  AX,[eof	]
	CMP  AX,0
	JNE  $+5
	JMP  cc134
	JMP  cc132
;		outstr(line); 
cc134:
	MOV  AX,line
	PUSH AX
	CALL outstr
	ADD  SP,2
;		nl(); 
	CALL nl
;		} 
	JMP  cc131
cc132:
;	kill();		/* invalidate line */ 
	CALL kill
;	cmode=1;		/* then back to parse level */ 
	MOV  AX,1
	MOV  [cmode	],AX
;	} 
	RET
; 
;/*					*/ 
;/*	Perform a function call		*/ 
;/*					*/ 
;/* called from heir11, this routine will either call */ 
;/*	the named function, or if the supplied ptr is */ 
;/*	zero, will call the contents of HL- Primary */ 
; 
;callfunction(ptr) 
callfunc:
;	char *ptr;	/* symbol table entry (or 0) */ 
;{	int nargs; 
	PUSH AX
;	nargs=0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;	blanks();	/* already saw open paren */ 
	CALL blanks
;	if(ptr==0)mnem_push();	/* calling HL- Primary */ 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc135
	CALL mnem_pus
;	while(streq(line+lptr,")")==0) 
cc135:
cc136:
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+331
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc137
;		{if(endst())break; 
	CALL endst
	CMP  AX,0
	JNE  $+5
	JMP  cc138
	JMP  cc137
;		expression();	/* get an argument */ 
cc138:
	CALL expressi
;		if(ptr==0)swapstk(); /* don't push addr */ 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc139
	CALL swapstk
;		mnem_push();	/* push argument */ 
cc139:
	CALL mnem_pus
;		nargs=nargs+2;	/* count args*2 */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;		if (match(",")==0) break; 
	MOV  AX,cc1+333
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc140
	JMP  cc137
;		} 
cc140:
	JMP  cc136
cc137:
;	needbrack(")"); 
	MOV  AX,cc1+335
	PUSH AX
	CALL needbrac
	ADD  SP,2
;	if(ptr)mnem_call(ptr); 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc141
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL mnem_cal
	ADD  SP,2
;	else mnemcallstk(); 
	JMP  cc142
cc141:
	CALL mnemcall
cc142:
;	c_sp=mnem_modstk(c_sp+nargs);	/* clean up arguments */ 
	MOV  AX,[c_sp	]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL mnem_mod
	ADD  SP,2
	MOV  [c_sp	],AX
;} 
	ADD  SP,2
	RET
; 
;junk() 
junk:
;{	if(an(inbyte())) 
	CALL inbyte
	PUSH AX
	CALL an
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc143
;		while(an(chr()))gchr(); 
cc144:
	CALL chr
	PUSH AX
	CALL an
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc145
	CALL gchr
	JMP  cc144
cc145:
;	else while(an(chr())==0) 
	JMP  cc146
cc143:
cc147:
	CALL chr
	PUSH AX
	CALL an
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc148
;		{if(chr()==0)break; 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc149
	JMP  cc148
;		gchr(); 
cc149:
	CALL gchr
;		} 
	JMP  cc147
cc148:
cc146:
;	blanks(); 
	CALL blanks
;} 
	RET
; 
;endst() 
endst:
;{	blanks(); 
	CALL blanks
;	return ((streq(line+lptr,";")|(chr()==0))); 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+337
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	RET
;} 
; 
;/** ch > chr, and > m_and, pop > mnem_pop         **/ 
;/** push > mnem_push, or > m_or, xor > m_xor **/ 
; 
; 
;/** The hierarchical recursive descent steps have  **/ 
;/** the pattern of, on entry, call the next higher **/ 
;/** precedence level, and then at return, filter   **/ 
;/** for lexeme operators for its level.  If false, **/ 
;/** returns control to the lower precedence level. **/ 
;/** If true, select for matching lexeme for its    **/ 
;/** precedence level and perform the production    **/ 
;/** actions to generate code.			   **/ 
;/** expression() forms a control array: lval[2] to **/ 
;/** which rvalue(lval) responds after primary(lval)**/ 
;/** has made its determinations on the nature of   **/ 
;/** the identifier parsed in a statement held in a **/ 
;/** line buffer.  Two symbol tables are maintained **/ 
;/** one for Local Symbols (auto storage class) and **/ 
;/** one for Global Symbols (static storage class). **/ 
;/** operations on auto variables take place on the **/ 
;/** Stack, static variable operations involve their**/ 
;/** storage in the Data Segment.  Symbol record    **/ 
;/** structure, and the possible field values are   **/ 
;/** defined at the begining of the source through  **/ 
;/** #define statements.  This C subset language    **/ 
;/** hasn't structures, unions, switch statements,  **/ 
;/** etc., but has enough to bootstrap those elements*/ 
;/** in later editions.  The primary(lval) sets lval**/ 
;/** fields as a control mechanism on identifiers for*/ 
;/** rvalue and the rest of the expression analyzer **/ 
;/** as well, it sets a return value of zero or one **/ 
;/** as an additional control flag.  Consequently,  **/ 
;/** the following control table develops:	   **/ 
;/**	 ident	lval[0]	[1]	ret_val	   	   **/ 
;/**						   **/ 
;/**    const	0	0	0		   **/ 
;/**    funct	ptr	0	0		   **/ 
;/**    array	ptr	typ	0		   **/ 
;/**  pointer	ptr	0	1		   **/ 
;/** variable	ptr	0	1		   **/ 
;/** such that.. ptr is identifier location in symbol*/ 
;/**  table and typ for array is one of cchar.1 or  **/ 
;/**  ccint.2, and an identifier of pointer or var  **/ 
;/** return(1), array and function identifiers      **/ 
;/** return(0).					   **/ 
; 
; 
;expression() 
expressi:
;{ 
;	int lval[2]; 
	PUSH AX
	PUSH AX
;	if(heir1(lval))rvalue(lval); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir1
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc150
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rvalue
	ADD  SP,2
;} 
cc150:
	ADD  SP,4
	RET
; 
;heir1(lval) 
heir1:
;	int lval[]; 
;{ 
;	int k,lval2[2]; 
	PUSH AX
	PUSH AX
	PUSH AX
;	k=heir2(lval); 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL heir2
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
;	if (match("=")) 
	MOV  AX,cc1+339
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc151
;		{if(k==0){needlval();return 0;} 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc152
	CALL needlval
	MOV  AX,0
	ADD  SP,6
	RET
;		if (lval[1])mnem_push(); 
cc152:
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc153
	CALL mnem_pus
;		if(heir1(lval2))rvalue(lval2); 
cc153:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir1
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc154
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rvalue
	ADD  SP,2
;		store(lval); 
cc154:
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL store
	ADD  SP,2
;		return 0; 
	MOV  AX,0
	ADD  SP,6
	RET
;		} 
;	else return k; 
	JMP  cc155
cc151:
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,6
	RET
cc155:
;} 
	ADD  SP,6
	RET
; 
;heir2(lval) 
heir2:
;	int lval[]; 
;{	int k,lval2[2]; 
	PUSH AX
	PUSH AX
	PUSH AX
;	k=heir3(lval); 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL heir3
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
;	blanks(); 
	CALL blanks
;	if(chr()!='|')return k; 
	CALL chr
	PUSH AX
	MOV  AX,124
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc156
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,6
	RET
;	if(k)rvalue(lval); 
cc156:
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc157
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL rvalue
	ADD  SP,2
;	while(1) 
cc157:
cc158:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc159
;		{if (match("|")) 
	MOV  AX,cc1+341
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc160
;			{mnem_push(); 
	CALL mnem_pus
;			if(heir3(lval2)) rvalue(lval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir3
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc161
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rvalue
	ADD  SP,2
;			mnem_pop(); 
cc161:
	CALL mnem_pop
;			m_or(); 
	CALL m_or
;			} 
;		else return 0; 
	JMP  cc162
cc160:
	MOV  AX,0
	ADD  SP,6
	RET
cc162:
;		} 
	JMP  cc158
cc159:
;} 
	ADD  SP,6
	RET
; 
;heir3(lval) 
heir3:
;	int lval[]; 
;{	int k,lval2[2]; 
	PUSH AX
	PUSH AX
	PUSH AX
;	k=heir4(lval); 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL heir4
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
;	blanks(); 
	CALL blanks
;	if(chr()!='^')return k; 
	CALL chr
	PUSH AX
	MOV  AX,94
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc163
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,6
	RET
;	if(k)rvalue(lval); 
cc163:
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc164
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL rvalue
	ADD  SP,2
;	while(1) 
cc164:
cc165:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc166
;		{if (match("^")) 
	MOV  AX,cc1+343
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc167
;			{mnem_push(); 
	CALL mnem_pus
;			if(heir4(lval2))rvalue(lval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir4
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc168
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rvalue
	ADD  SP,2
;			mnem_pop(); 
cc168:
	CALL mnem_pop
;			m_xor(); 
	CALL m_xor
;			} 
;		else return 0; 
	JMP  cc169
cc167:
	MOV  AX,0
	ADD  SP,6
	RET
cc169:
;		} 
	JMP  cc165
cc166:
;} 
	ADD  SP,6
	RET
; 
;heir4(lval) 
heir4:
;	int lval[]; 
;{	int k,lval2[2]; 
	PUSH AX
	PUSH AX
	PUSH AX
;	k=heir5(lval); 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL heir5
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
;	blanks(); 
	CALL blanks
;	if(chr()!='&')return k; 
	CALL chr
	PUSH AX
	MOV  AX,38
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc170
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,6
	RET
;	if(k)rvalue(lval); 
cc170:
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc171
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL rvalue
	ADD  SP,2
;	while(1) 
cc171:
cc172:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc173
;		{if (match("&")) 
	MOV  AX,cc1+345
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc174
;			{mnem_push(); 
	CALL mnem_pus
;			if(heir5(lval2))rvalue(lval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir5
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc175
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rvalue
	ADD  SP,2
;			mnem_pop(); 
cc175:
	CALL mnem_pop
;			m_and(); 
	CALL m_and
;			} 
;		else return 0; 
	JMP  cc176
cc174:
	MOV  AX,0
	ADD  SP,6
	RET
cc176:
;		} 
	JMP  cc172
cc173:
;} 
	ADD  SP,6
	RET
; 
;heir5(lval) 
heir5:
;	int lval[]; 
;{ 
;	int k,lval2[2]; 
	PUSH AX
	PUSH AX
	PUSH AX
;	k=heir6(lval); 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL heir6
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
;	blanks(); 
	CALL blanks
;	if((streq(line+lptr,"==")==0)& 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+347
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
;		(streq(line+lptr,"!=")==0))return k; 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+350
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc177
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,6
	RET
;	if(k)rvalue(lval); 
cc177:
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc178
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL rvalue
	ADD  SP,2
;	while(1) 
cc178:
cc179:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc180
;		{if (match("==")) 
	MOV  AX,cc1+353
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc181
;			{mnem_push(); 
	CALL mnem_pus
;			if(heir6(lval2))rvalue(lval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir6
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc182
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rvalue
	ADD  SP,2
;			mnem_pop(); 
cc182:
	CALL mnem_pop
;		/** cmp Secd. to Prim. ret1 in Prim. if TRUE **/ 
;			eq();  
	CALL eq
;			} 
;		else if (match("!=")) 
	JMP  cc183
cc181:
	MOV  AX,cc1+356
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc184
;			{mnem_push(); 
	CALL mnem_pus
;			if(heir6(lval2))rvalue(lval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir6
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc185
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rvalue
	ADD  SP,2
;			mnem_pop(); 
cc185:
	CALL mnem_pop
;			ne(); 
	CALL ne
;			} 
;		else return 0; 
	JMP  cc186
cc184:
	MOV  AX,0
	ADD  SP,6
	RET
cc186:
cc183:
;		} 
	JMP  cc179
cc180:
;} 
	ADD  SP,6
	RET
; 
;heir6(lval) 
heir6:
;	int lval[]; 
;{ 
;	int k,lval2[2]; 
	PUSH AX
	PUSH AX
	PUSH AX
;	k=heir7(lval); 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL heir7
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
;	blanks(); 
	CALL blanks
;	if((streq(line+lptr,"<")==0)& 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+359
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
;		(streq(line+lptr,">")==0)& 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+361
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	PUSH AX
;		(streq(line+lptr,"<=")==0)& 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+363
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	PUSH AX
;		(streq(line+lptr,">=")==0))return k; 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+366
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc187
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,6
	RET
;		if(streq(line+lptr,">>"))return k; 
cc187:
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+369
	PUSH AX
	CALL streq
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc188
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,6
	RET
;		if(streq(line+lptr,"<<"))return k; 
cc188:
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+372
	PUSH AX
	CALL streq
	ADD  SP,4
	CMP  AX,0
	JNE  $+5
	JMP  cc189
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,6
	RET
;	if(k)rvalue(lval); 
cc189:
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc190
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL rvalue
	ADD  SP,2
;	while(1) 
cc190:
cc191:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc192
;		{if (match("<=")) 
	MOV  AX,cc1+375
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc193
;			{mnem_push(); 
	CALL mnem_pus
;			if(heir7(lval2))rvalue(lval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir7
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc194
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rvalue
	ADD  SP,2
;			mnem_pop(); 
cc194:
	CALL mnem_pop
;			if(cptr=lval[0]) 
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  [cptr	],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc195
;				if(cptr[ident]==pointer) 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc196
;				{ule(); 
	CALL ule
;				continue; 
	JMP  cc191
;				} 
;			le(); 
cc196:
cc195:
	CALL le
;			} 
;		else if (match(">=")) 
	JMP  cc197
cc193:
	MOV  AX,cc1+378
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc198
;			{mnem_push(); 
	CALL mnem_pus
;			if(heir7(lval2))rvalue(lval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir7
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc199
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rvalue
	ADD  SP,2
;			mnem_pop(); 
cc199:
	CALL mnem_pop
;			if(cptr=lval[0]) 
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  [cptr	],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc200
;				if(cptr[ident]==pointer) 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc201
;				{uge(); 
	CALL uge
;				continue; 
	JMP  cc191
;				} 
;			if(cptr=lval2[0]) 
cc201:
cc200:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  [cptr	],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc202
;				if(cptr[ident]==pointer) 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc203
;				{uge(); 
	CALL uge
;				continue; 
	JMP  cc191
;				} 
;			ge(); 
cc203:
cc202:
	CALL ge
;			} 
;		else if((streq(line+lptr,"<"))& 
	JMP  cc204
cc198:
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+381
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
;			(streq(line+lptr,"<<")==0)) 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+383
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc205
;			{inbyte(); 
	CALL inbyte
;			mnem_push(); 
	CALL mnem_pus
;			if(heir7(lval2))rvalue(lval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir7
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc206
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rvalue
	ADD  SP,2
;			mnem_pop(); 
cc206:
	CALL mnem_pop
;			if(cptr=lval[0]) 
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  [cptr	],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc207
;				if(cptr[ident]==pointer) 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc208
;				{ult(); 
	CALL ult
;				continue; 
	JMP  cc191
;				} 
;			if(cptr=lval2[0]) 
cc208:
cc207:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  [cptr	],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc209
;				if(cptr[ident]==pointer) 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc210
;				{ult(); 
	CALL ult
;				continue; 
	JMP  cc191
;				} 
;			lt(); 
cc210:
cc209:
	CALL lt
;			} 
;		else if((streq(line+lptr,">"))& 
	JMP  cc211
cc205:
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+386
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
;			(streq(line+lptr,">>")==0)) 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+388
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc212
;			{inbyte(); 
	CALL inbyte
;			mnem_push(); 
	CALL mnem_pus
;			if(heir7(lval2))rvalue(lval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir7
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc213
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rvalue
	ADD  SP,2
;			mnem_pop(); 
cc213:
	CALL mnem_pop
;			if(cptr=lval[0]) 
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  [cptr	],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc214
;				if(cptr[ident]==pointer) 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc215
;				{ugt(); 
	CALL ugt
;				continue; 
	JMP  cc191
;				} 
;			if(cptr=lval2[0]) 
cc215:
cc214:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  [cptr	],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc216
;				if(cptr[ident]==pointer) 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc217
;				{ugt(); 
	CALL ugt
;				continue; 
	JMP  cc191
;				} 
;			gt(); 
cc217:
cc216:
	CALL gt
;			} 
;		else return 0; 
	JMP  cc218
cc212:
	MOV  AX,0
	ADD  SP,6
	RET
cc218:
cc211:
cc204:
cc197:
;		} 
	JMP  cc191
cc192:
;} 
	ADD  SP,6
	RET
; 
;/** ch > chr, div > m_div, push > mnem_push **/ 
;/** add > m_add, sub > m_sub, mult > m_mult **/ 
;/** inc > m_inc, dec > m_dec, neg > m_neg **/ 
; 
;heir7(lval) 
heir7:
;	int lval[]; 
;{ 
;	int k,lval2[2]; 
	PUSH AX
	PUSH AX
	PUSH AX
;	k=heir8(lval); /** recursive descent **/ 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL heir8
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
;	blanks(); 
	CALL blanks
;	if((streq(line+lptr,">>")==0)& 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+391
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
;		(streq(line+lptr,"<<")==0))return k; 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+394
	PUSH AX
	CALL streq
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc219
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,6
	RET
;		/** trap for >> << **/ 
;	if(k)rvalue(lval); 
cc219:
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc220
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL rvalue
	ADD  SP,2
;	while(1) 
cc220:
cc221:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc222
;		{if (match(">>")) 
	MOV  AX,cc1+397
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc223
;			{mnem_push(); 
	CALL mnem_pus
;			if(heir8(lval2))rvalue(lval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir8
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc224
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rvalue
	ADD  SP,2
;			mnem_pop(); 
cc224:
	CALL mnem_pop
;			asr(); 
	CALL asr
;			} 
;		else if (match("<<")) 
	JMP  cc225
cc223:
	MOV  AX,cc1+400
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc226
;			{mnem_push(); 
	CALL mnem_pus
;			if(heir8(lval2))rvalue(lval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir8
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc227
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rvalue
	ADD  SP,2
;			mnem_pop(); 
cc227:
	CALL mnem_pop
;			asl(); 
	CALL asl
;			} 
;		else return 0; 
	JMP  cc228
cc226:
	MOV  AX,0
	ADD  SP,6
	RET
cc228:
cc225:
;		} 
	JMP  cc221
cc222:
;} 
	ADD  SP,6
	RET
; 
;heir8(lval) 
heir8:
;	int lval[]; 
;{ 
;	int k,lval2[2]; 
	PUSH AX
	PUSH AX
	PUSH AX
;	k=heir9(lval); 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL heir9
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
;	blanks(); 
	CALL blanks
;	if((chr()!='+')&(chr()!='-'))return k; 
	CALL chr
	PUSH AX
	MOV  AX,43
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	PUSH AX
	CALL chr
	PUSH AX
	MOV  AX,45
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc229
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,6
	RET
;	if(k)rvalue(lval); 
cc229:
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc230
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL rvalue
	ADD  SP,2
;	while(1) 
cc230:
cc231:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc232
;		{if (match("+")) 
	MOV  AX,cc1+403
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc233
;			{mnem_push(); 
	CALL mnem_pus
;			if(heir9(lval2))rvalue(lval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir9
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc234
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rvalue
	ADD  SP,2
;			if(cptr=lval[0]) 
cc234:
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  [cptr	],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc235
;				if((cptr[ident]==pointer)& 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
;				(cptr[type]==cint)) 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc236
;				doublereg(); 
	CALL doublere
;			mnem_pop(); 
cc236:
cc235:
	CALL mnem_pop
;			m_add(); 
	CALL m_add
;			} 
;		else if (match("-")) 
	JMP  cc237
cc233:
	MOV  AX,cc1+405
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc238
;			{mnem_push(); 
	CALL mnem_pus
;			if(heir9(lval2))rvalue(lval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir9
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc239
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rvalue
	ADD  SP,2
;			if(cptr=lval[0]) 
cc239:
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  [cptr	],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc240
;				if((cptr[ident]==pointer)& 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
;				(cptr[type]==cint)) 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc241
;				doublereg(); 
	CALL doublere
;			mnem_pop(); 
cc241:
cc240:
	CALL mnem_pop
;			m_sub(); 
	CALL m_sub
;			} 
;		else return 0; 
	JMP  cc242
cc238:
	MOV  AX,0
	ADD  SP,6
	RET
cc242:
cc237:
;		} 
	JMP  cc231
cc232:
;} 
	ADD  SP,6
	RET
; 
;heir9(lval) 
heir9:
;	int lval[]; 
;{ 
;	int k,lval2[2]; 
	PUSH AX
	PUSH AX
	PUSH AX
;	k=heir10(lval); 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL heir10
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
;	blanks(); 
	CALL blanks
;	if((chr()!='*')&(chr()!='/')& 
	CALL chr
	PUSH AX
	MOV  AX,42
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	PUSH AX
	CALL chr
	PUSH AX
	MOV  AX,47
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	PUSH AX
;		(chr()!='%'))return k; 
	CALL chr
	PUSH AX
	MOV  AX,37
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc243
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,6
	RET
;	if(k)rvalue(lval); 
cc243:
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc244
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL rvalue
	ADD  SP,2
;	while(1) 
cc244:
cc245:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc246
;		{if (match("*")) 
	MOV  AX,cc1+407
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc247
;			{mnem_push(); 
	CALL mnem_pus
;			if(heir9(lval2))rvalue(lval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir9
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc248
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rvalue
	ADD  SP,2
;			mnem_pop(); 
cc248:
	CALL mnem_pop
;			m_mult(); 
	CALL m_mult
;			} 
;		else if (match("/")) 
	JMP  cc249
cc247:
	MOV  AX,cc1+409
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc250
;			{mnem_push(); 
	CALL mnem_pus
;			if(heir10(lval2))rvalue(lval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir10
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc251
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rvalue
	ADD  SP,2
;			mnem_pop(); 
cc251:
	CALL mnem_pop
;			m_div(); 
	CALL m_div
;			} 
;		else if (match("%")) 
	JMP  cc252
cc250:
	MOV  AX,cc1+411
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc253
;			{mnem_push(); 
	CALL mnem_pus
;			if(heir10(lval2))rvalue(lval2); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL heir10
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc254
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL rvalue
	ADD  SP,2
;			mnem_pop(); 
cc254:
	CALL mnem_pop
;			mod(); 
	CALL mod
;			} 
;		else return 0; 
	JMP  cc255
cc253:
	MOV  AX,0
	ADD  SP,6
	RET
cc255:
cc252:
cc249:
;		} 
	JMP  cc245
cc246:
;} 
	ADD  SP,6
	RET
; 
;heir10(lval) 
heir10:
;	int lval[]; 
;{ 
;	int k; 
	PUSH AX
;	char *ptr; 
	PUSH AX
;	if(match("++")) 
	MOV  AX,cc1+413
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc256
;		{if((k=heir10(lval))==0) 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL heir10
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc257
;			{needlval(); 
	CALL needlval
;			return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;			} 
;		if(lval[1])mnem_push(); 
cc257:
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc258
	CALL mnem_pus
;		rvalue(lval); 
cc258:
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL rvalue
	ADD  SP,2
;		m_inc(); 
	CALL m_inc
;		ptr=lval[0]; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;		if((ptr[ident]==pointer)& 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
;			(ptr[type]==cint)) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc259
;				m_inc(); 
	CALL m_inc
;		store(lval); 
cc259:
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL store
	ADD  SP,2
;		return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;		} 
;	else if(match("--")) 
	JMP  cc260
cc256:
	MOV  AX,cc1+416
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc261
;		{if((k=heir10(lval))==0) 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL heir10
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc262
;			{needlval(); 
	CALL needlval
;			return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;			} 
;		if(lval[1])mnem_push(); 
cc262:
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc263
	CALL mnem_pus
;		rvalue(lval); 
cc263:
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL rvalue
	ADD  SP,2
;		m_dec(); 
	CALL m_dec
;		ptr=lval[0]; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;		if((ptr[ident]==pointer)& 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
;			(ptr[type]==cint)) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc264
;			m_dec(); 
	CALL m_dec
;		store(lval); 
cc264:
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL store
	ADD  SP,2
;		return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;		} 
;	else if (match("-")) 
	JMP  cc265
cc261:
	MOV  AX,cc1+419
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc266
;		{k=heir10(lval); 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL heir10
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
;		if (k) rvalue(lval); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc267
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL rvalue
	ADD  SP,2
;		m_neg(); 
cc267:
	CALL m_neg
;		return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;		} 
;	else if(match("*")) 
	JMP  cc268
cc266:
	MOV  AX,cc1+421
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc269
;		{k=heir10(lval); 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL heir10
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
;		if(k)rvalue(lval); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc270
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL rvalue
	ADD  SP,2
;		if(ptr=lval[0]) 
cc270:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc271
;			lval[1]=ptr[type]; 
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AX
;		 
;		lval[0]=0; 
cc271:
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;		return 1; 
	MOV  AX,1
	ADD  SP,4
	RET
;		} 
;	else if(match("&")) 
	JMP  cc272
cc269:
	MOV  AX,cc1+423
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc273
;		{k=heir10(lval); 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL heir10
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
;		if(k==0) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc274
;			{error("illegal address"); 
	MOV  AX,cc1+425
	PUSH AX
	CALL error
	ADD  SP,2
;			return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;			} 
;		else if(lval[1])return 0; 
	JMP  cc275
cc274:
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc276
	MOV  AX,0
	ADD  SP,4
	RET
;		else 
	JMP  cc277
cc276:
;			{immed(); 
	CALL immed
;			outstr(ptr=lval[0]); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
	PUSH AX
	CALL outstr
	ADD  SP,2
;			nl(); 
	CALL nl
;			lval[1]=ptr[type]; 
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AX
;			return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;			} 
cc277:
cc275:
;		} 
;	else  
	JMP  cc278
cc273:
;		{k=heir11(lval); 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL heir11
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
;		if(match("++")) 
	MOV  AX,cc1+441
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc279
;			{if(k==0) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc280
;				{needlval(); 
	CALL needlval
;				return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;				} 
;			if(lval[1])mnem_push(); 
cc280:
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc281
	CALL mnem_pus
;			rvalue(lval); 
cc281:
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL rvalue
	ADD  SP,2
;			m_inc(); 
	CALL m_inc
;			ptr=lval[0]; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;			if((ptr[ident]==pointer)& 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
;				(ptr[type]==cint)) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc282
;					m_inc(); 
	CALL m_inc
;			store(lval); 
cc282:
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL store
	ADD  SP,2
;			m_dec(); 
	CALL m_dec
;			if((ptr[ident]==pointer)& 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
;				(ptr[type]==cint)) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc283
;				m_dec(); 
	CALL m_dec
;			return 0; 
cc283:
	MOV  AX,0
	ADD  SP,4
	RET
;			} 
;		else if(match("--")) 
	JMP  cc284
cc279:
	MOV  AX,cc1+444
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc285
;			{if(k==0) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc286
;				{needlval(); 
	CALL needlval
;				return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;				} 
;			if(lval[1])mnem_push(); 
cc286:
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc287
	CALL mnem_pus
;			rvalue(lval); 
cc287:
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL rvalue
	ADD  SP,2
;			m_dec(); 
	CALL m_dec
;			if((ptr[ident]==pointer)& 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
;				(ptr[type]==cint)) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc288
;				m_dec(); 
	CALL m_dec
;			store(lval); 
cc288:
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL store
	ADD  SP,2
;			m_inc(); 
	CALL m_inc
;			if((ptr[ident]==pointer)& 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
;				(ptr[type]==cint)) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc289
;				m_inc(); 
	CALL m_inc
;			return 0; 
cc289:
	MOV  AX,0
	ADD  SP,4
	RET
;			} 
;		else return k; 
	JMP  cc290
cc285:
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,4
	RET
cc290:
cc284:
;		} 
cc278:
cc272:
cc268:
cc265:
cc260:
;	} 
	ADD  SP,4
	RET
;/************************************************/ 
;/** ch > chr, gch > gchr, add > m_add          **/ 
;/** push > mnem_push, pop > mnem_pop, test > m_test  **/ 
; 
;heir11(lval) 
heir11:
;	int *lval; 
;{	int k;char *ptr; 
	PUSH AX
	PUSH AX
;	k=primary(lval); 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL primary
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
;	ptr=lval[0]; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;	blanks(); 
	CALL blanks
;	if((chr()=='[')|(chr()=='(')) 
	CALL chr
	PUSH AX
	MOV  AX,91
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	CALL chr
	PUSH AX
	MOV  AX,40
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc291
;	while(1) 
cc292:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc293
;		{if(match("[")) 
	MOV  AX,cc1+447
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc294
;			{if(ptr==0) 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc295
;				{error("can't subscript"); 
	MOV  AX,cc1+449
	PUSH AX
	CALL error
	ADD  SP,2
;				junk(); 
	CALL junk
;				needbrack("]"); 
	MOV  AX,cc1+465
	PUSH AX
	CALL needbrac
	ADD  SP,2
;				return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;				} 
;			else if(ptr[ident]==pointer)rvalue(lval); 
	JMP  cc296
cc295:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc297
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL rvalue
	ADD  SP,2
;			else if(ptr[ident]!=array) 
	JMP  cc298
cc297:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc299
;				{error("can't subscript"); 
	MOV  AX,cc1+467
	PUSH AX
	CALL error
	ADD  SP,2
;				k=0; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;				} 
;			mnem_push(); 
cc299:
cc298:
cc296:
	CALL mnem_pus
;			expression(); 
	CALL expressi
;			needbrack("]"); 
	MOV  AX,cc1+483
	PUSH AX
	CALL needbrac
	ADD  SP,2
;			if(ptr[type]==cint)doublereg(); 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc300
	CALL doublere
;			mnem_pop(); 
cc300:
	CALL mnem_pop
;			m_add(); 
	CALL m_add
;			lval[0]=0; 
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;			lval[1]=ptr[type]; 
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AX
;			k=1; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	POP  BX
	MOV  [BX],AX
;			} 
;		else if(match("(")) 
	JMP  cc301
cc294:
	MOV  AX,cc1+485
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc302
;			{if(ptr==0) 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc303
;				{callfunction(0); 
	MOV  AX,0
	PUSH AX
	CALL callfunc
	ADD  SP,2
;				} 
;			else if(ptr[ident]!=function) 
	JMP  cc304
cc303:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,4
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc305
;				{rvalue(lval); 
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL rvalue
	ADD  SP,2
;				callfunction(0); 
	MOV  AX,0
	PUSH AX
	CALL callfunc
	ADD  SP,2
;				} 
;			else callfunction(ptr); 
	JMP  cc306
cc305:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL callfunc
	ADD  SP,2
cc306:
cc304:
;			k=lval[0]=0; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
	POP  BX
	MOV  [BX],AX
;			} 
;		else return k; 
	JMP  cc307
cc302:
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,4
	RET
cc307:
cc301:
;		} 
	JMP  cc292
cc293:
;	if(ptr==0)return k; 
cc291:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc308
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,4
	RET
;	if(ptr[ident]==function) 
cc308:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,4
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc309
;		{immed();	/*immedo*/ 
	CALL immed
;		outstr(ptr); 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL outstr
	ADD  SP,2
;		nl(); 
	CALL nl
;		return 0; 
	MOV  AX,0
	ADD  SP,4
	RET
;		} 
;	return k; 
cc309:
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,4
	RET
;} 
; 
;primary(lval) 
primary:
;	int *lval; 
;{	char *ptr,sname[namesize];int num[1]; 
	PUSH AX
	XCHG AX,BX
	MOV  AX,-9
	ADD  AX,SP
	MOV  SP,AX
	XCHG AX,BX
	PUSH AX
;	int k; 
	PUSH AX
;	if(match("(")) 
	MOV  AX,cc1+487
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc310
;		{k=heir1(lval); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,19
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL heir1
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
;		needbrack(")"); 
	MOV  AX,cc1+489
	PUSH AX
	CALL needbrac
	ADD  SP,2
;		return k; 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,15
	RET
;		} 
;	if(symname(sname)) 
cc310:
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	CALL symname
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc311
;		{if(ptr=findloc(sname)) 
	MOV  AX,13
	ADD  AX,SP
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	CALL findloc
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc312
;			{getloc(ptr); 
	MOV  AX,13
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL getloc
	ADD  SP,2
;			lval[0]=ptr; 
	MOV  AX,17
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,15
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;			lval[1]=ptr[type]; 
	MOV  AX,17
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,15
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AX
;			if(ptr[ident]==pointer)lval[1]=cint; 
	MOV  AX,13
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc313
	MOV  AX,17
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,2
	POP  BX
	MOV  [BX],AX
;			if(ptr[ident]==array)return 0; 
cc313:
	MOV  AX,13
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc314
	MOV  AX,0
	ADD  SP,15
	RET
;					else return 1; 
	JMP  cc315
cc314:
	MOV  AX,1
	ADD  SP,15
	RET
cc315:
;			} 
;		if(ptr=findglb(sname)) 
cc312:
	MOV  AX,13
	ADD  AX,SP
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	CALL findglb
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc316
;			if(ptr[ident]!=function) 
	MOV  AX,13
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,4
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc317
;			{lval[0]=ptr; 
	MOV  AX,17
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,15
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;			lval[1]=0; 
	MOV  AX,17
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;			if(ptr[ident]!=array)return 1; 
	MOV  AX,13
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc318
	MOV  AX,1
	ADD  SP,15
	RET
;			immed(); 
cc318:
	CALL immed
;			outstr(ptr);nl(); /*outname*/ 
	MOV  AX,13
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL outstr
	ADD  SP,2
	CALL nl
;			lval[1]=ptr[type]; 
	MOV  AX,17
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,15
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AX
;			return 0; 
	MOV  AX,0
	ADD  SP,15
	RET
;			} 
;		ptr=addglb(sname,function,cint,0); 
cc317:
cc316:
	MOV  AX,13
	ADD  AX,SP
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	MOV  AX,4
	PUSH AX
	MOV  AX,2
	PUSH AX
	MOV  AX,0
	PUSH AX
	CALL addglb
	ADD  SP,8
	POP  BX
	MOV  [BX],AX
;		lval[0]=ptr; 
	MOV  AX,17
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,15
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;		lval[1]=0; 
	MOV  AX,17
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;		return 0; 
	MOV  AX,0
	ADD  SP,15
	RET
;		} 
;	if(constant(num)) 
cc311:
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	CALL constant
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc319
;		return(lval[0]=lval[1]=0); 
	MOV  AX,17
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,19
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
	POP  BX
	MOV  [BX],AX
	ADD  SP,15
	RET
;	else 
	JMP  cc320
cc319:
;		{error("invalid expression"); 
	MOV  AX,cc1+491
	PUSH AX
	CALL error
	ADD  SP,2
;		immed();outdec(0);nl(); 
	CALL immed
	MOV  AX,0
	PUSH AX
	CALL outdec
	ADD  SP,2
	CALL nl
;		junk(); 
	CALL junk
;		return 0; 
	MOV  AX,0
	ADD  SP,15
	RET
;		} 
cc320:
;	} 
	ADD  SP,15
	RET
; 
;store(lval) 
store:
;	int *lval; 
;{	if (lval[1]==0)putmem(lval[0]); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc321
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL putmem
	ADD  SP,2
;	else putstk(lval[1]); 
	JMP  cc322
cc321:
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL putstk
	ADD  SP,2
cc322:
;} 
	RET
; 
;rvalue(lval) 
rvalue:
;	int *lval; 
;{	if((lval[0] != 0) & (lval[1] == 0)) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc323
;		getmem(lval[0]); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL getmem
	ADD  SP,2
;		else indirect(lval[1]); 
	JMP  cc324
cc323:
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL indirect
	ADD  SP,2
cc324:
;} 
	RET
; 
;m_test(label) 
m_test:
;	int label; 
;{ 
;	needbrack("("); 
	MOV  AX,cc1+510
	PUSH AX
	CALL needbrac
	ADD  SP,2
;	expression(); 
	CALL expressi
;	needbrack(")"); 
	MOV  AX,cc1+512
	PUSH AX
	CALL needbrac
	ADD  SP,2
;	testjump(label); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL testjump
	ADD  SP,2
;} 
	RET
; 
;constant(val) 
constant:
;	int val[]; 
;{	if (number(val)) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL number
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc325
;		immed(); 
	CALL immed
;	else if (pstr(val)) 
	JMP  cc326
cc325:
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL pstr
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc327
;		immed(); 
	CALL immed
;	else if (qstr(val)) 
	JMP  cc328
cc327:
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL qstr
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc329
;		{immed();printlabel(litlab);outbyte('+');} 
	CALL immed
	MOV  AX,[litlab	]
	PUSH AX
	CALL printlab
	ADD  SP,2
	MOV  AX,43
	PUSH AX
	CALL outbyte
	ADD  SP,2
;	else return 0;	 
	JMP  cc330
cc329:
	MOV  AX,0
	RET
cc330:
cc328:
cc326:
;	outdec(val[0]); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL outdec
	ADD  SP,2
;	nl(); 
	CALL nl
;	return 1; 
	MOV  AX,1
	RET
;} 
; 
;number(val) 
number:
;	int val[]; 
;{	int k,minus;char c; 
	PUSH AX
	PUSH AX
	DEC  SP
;	k=minus=1; 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	POP  BX
	MOV  [BX],AX
	POP  BX
	MOV  [BX],AX
;	while(k) 
cc331:
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc332
;		{k=0; 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;		if (match("+")) k=1; 
	MOV  AX,cc1+514
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc333
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	POP  BX
	MOV  [BX],AX
;		if (match("-")) {minus=(-minus);k=1;} 
cc333:
	MOV  AX,cc1+516
	PUSH AX
	CALL match
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc334
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	NEG  AX
	POP  BX
	MOV  [BX],AX
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	POP  BX
	MOV  [BX],AX
;		} 
cc334:
	JMP  cc331
cc332:
;	if(numeric(chr())==0)return 0; 
	CALL chr
	PUSH AX
	CALL numeric
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc335
	MOV  AX,0
	ADD  SP,5
	RET
;	while (numeric(chr())) 
cc335:
cc336:
	CALL chr
	PUSH AX
	CALL numeric
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc337
;		{c=inbyte(); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL inbyte
	POP  BX
	MOV  [BX],AL
;		k=k*10+(c-'0'); 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,5
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,10
	POP  BX
	MUL  BX
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,48
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;		} 
	JMP  cc336
cc337:
;	if (minus < 0) k=(-k); 
	MOV  AX,1
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc338
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,5
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	NEG  AX
	POP  BX
	MOV  [BX],AX
;	val[0]=k; 
cc338:
	MOV  AX,7
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,5
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;	return 1; 
	MOV  AX,1
	ADD  SP,5
	RET
;} 
; 
;pstr(val) 
pstr:
;	int val[]; 
;{	int k;char c; 
	PUSH AX
	DEC  SP
;	k=0; 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;	if (match("'")==0) return 0; 
	MOV  AX,cc1+518
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc339
	MOV  AX,0
	ADD  SP,3
	RET
;	while((c=gchr())!=39) 
cc339:
cc340:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	CALL gchr
	POP  BX
	MOV  [BX],AL
	PUSH AX
	MOV  AX,39
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc341
;		k=(k&255)*256 + (c&127); 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,255
	POP  BX
	AND  AX,BX
	PUSH AX
	MOV  AX,256
	POP  BX
	MUL  BX
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,127
	POP  BX
	AND  AX,BX
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
	JMP  cc340
cc341:
;	val[0]=k; 
	MOV  AX,5
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;	return 1; 
	MOV  AX,1
	ADD  SP,3
	RET
;} 
; 
;qstr(val) 
qstr:
;	int val[]; 
;{	char c; 
	DEC  SP
;	if (match(quote)==0) return 0; 
	MOV  AX,quote
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc342
	MOV  AX,0
	ADD  SP,1
	RET
;	val[0]=litptr; 
cc342:
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,[litptr	]
	POP  BX
	MOV  [BX],AX
;	while (chr()!='"') 
cc343:
	CALL chr
	PUSH AX
	MOV  AX,34
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc344
;		{if(chr()==0)break; 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc345
	JMP  cc344
;		if(litptr>=litmax) 
cc345:
	MOV  AX,[litptr	]
	PUSH AX
	MOV  AX,4000
	PUSH AX
	MOV  AX,1
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc346
;			{error("string space exhausted"); 
	MOV  AX,cc1+520
	PUSH AX
	CALL error
	ADD  SP,2
;			while(match(quote)==0) 
cc347:
	MOV  AX,quote
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc348
;				if(gchr()==0)break; 
	CALL gchr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc349
	JMP  cc348
;			return 1; 
cc349:
	JMP  cc347
cc348:
	MOV  AX,1
	ADD  SP,1
	RET
;			} 
;		litq[litptr++]=gchr(); 
cc346:
	MOV  AX,litq
	PUSH AX
	MOV  AX,[litptr	]
	INC  AX
	MOV  [litptr	],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL gchr
	POP  BX
	MOV  [BX],AL
;		} 
	JMP  cc343
cc344:
;	gchr(); 
	CALL gchr
;	litq[litptr++]=0; 
	MOV  AX,litq
	PUSH AX
	MOV  AX,[litptr	]
	INC  AX
	MOV  [litptr	],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AL
;	return 1; 
	MOV  AX,1
	ADD  SP,1
	RET
;} 
; 
;/****************************************/ 
;/**  SCN_II.C 			       **/ 
;/** Next is SCN_III.C 		       **/ 
;/************************************************/ 
;/** Modified for NASM as SCN_III.C Small-C,nasm**/ 
;/** Last: 29 JUL 2007 Init: 31 MAR 2007        **/ 
;/** By: s_dubrovich@yahoo.com                  **/ 
;/** Vers: 0.0.3b  Goal: NASM ouput             **/ 
;/**					       **/ 
;/************************************************/ 
;/* ToBe Modified for NASM as SCCN.C --          */ 
;/*  Small-C Compiler - Nasm                     */ 
;/* Last: 15 JUL 2007 Init: 14 JUL 2007          */ 
;/* By: s_dubrovich@yahoo.com                    */ 
;/* Vers: 0.0.1b  Goal: NASM ouput               */ 
;/* Comments:                                    */ 
;/*  This is a new offshoot of development from  */ 
;/*  NCn.C as changes beyond CC8.C are intended. */ 
;/*  NCn.C is Archived, Closed to further        */ 
;/*  development, superceded by this effort SCCN.*/ 
;/* EndComments:                                 */ 
;/** SCCN.C is parked                           **/ 
;/************************************************/ 
;/** New Development Branch                     **/ 
;/************************************************/ 
;/** Re-Codified as:                            **/ 
;/**	I.   Global Storage Defn, main()       **/ 
;/**     II.  Recursive Descent Parser          **/ 
;/**     III. Utility Functions                 **/ 
;/**     IV.  U.I. & I/O                        **/ 
;/**     V.   Backend, NASM Object Output       **/ 
;/************************************************/ 
;/************************************************/ 
;/*						*/ 
;/*		small-c compiler		*/ 
;/*                  rev. 1.1                    */ 
;/*		  by Ron Cain			*/ 
;/*		    (1980)			*/ 
;/************************************************/ 
; 
;findglb(sname) 
findglb:
;	char *sname; 
;{	char *ptr; 
	PUSH AX
;	ptr=startglb; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,symtab
	POP  BX
	MOV  [BX],AX
;	while(ptr!=glbptr) 
cc350:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,[glbptr	]
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc351
;		{if(astreq(sname,ptr,namemax))return ptr; 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,8
	PUSH AX
	CALL astreq
	ADD  SP,6
	CMP  AX,0
	JNE  $+5
	JMP  cc352
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,2
	RET
;		ptr=ptr+symsiz; 
cc352:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,16
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;		} 
	JMP  cc350
cc351:
;	return 0; 
	MOV  AX,0
	ADD  SP,2
	RET
;} 
; 
;findloc(sname) 
findloc:
;	char *sname; 
;{	char *ptr; 
	PUSH AX
;	ptr=startloc; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,symtab
	PUSH AX
	MOV  AX,300
	PUSH AX
	MOV  AX,16
	POP  BX
	MUL  BX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,16
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;	while(ptr!=locptr) 
cc353:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,[locptr	]
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc354
;		{if(astreq(sname,ptr,namemax))return ptr; 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,8
	PUSH AX
	CALL astreq
	ADD  SP,6
	CMP  AX,0
	JNE  $+5
	JMP  cc355
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,2
	RET
;		ptr=ptr+symsiz; 
cc355:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,16
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;		} 
	JMP  cc353
cc354:
;	return 0; 
	MOV  AX,0
	ADD  SP,2
	RET
;} 
; 
;addglb(sname,id,typ,value) 
addglb:
;	char *sname,id,typ; 
;	int value; 
;{	char *ptr; 
	PUSH AX
;	if(cptr=findglb(sname))return cptr; 
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL findglb
	ADD  SP,2
	MOV  [cptr	],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc356
	MOV  AX,[cptr	]
	ADD  SP,2
	RET
;	if(glbptr>=endglb) 
cc356:
	MOV  AX,[glbptr	]
	PUSH AX
	MOV  AX,symtab
	PUSH AX
	MOV  AX,300
	PUSH AX
	MOV  AX,16
	POP  BX
	MUL  BX
	POP  BX
	ADD  AX,BX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JAE  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc357
;		{error("global symbol table overflow"); 
	MOV  AX,cc1+543
	PUSH AX
	CALL error
	ADD  SP,2
;		return 0; 
	MOV  AX,0
	ADD  SP,2
	RET
;		} 
;	cptr=ptr=glbptr; 
cc357:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,[glbptr	]
	POP  BX
	MOV  [BX],AX
	MOV  [cptr	],AX
;	while(an(*ptr++ = *sname++));	/* copy name */ 
cc358:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	PUSH AX
	MOV  AX,12
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
	PUSH AX
	CALL an
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc359
	JMP  cc358
cc359:
;	cptr[ident]=id; 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;	cptr[type]=typ; 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;	cptr[storage]=statik; 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,13
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,1
	POP  BX
	MOV  [BX],AL
;	cptr[offset]=value; 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,14
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AL
;	cptr[offset+1]=value>>8; 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,14
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,8
	POP  BX
	MOV  CL,AL
	MOV  AX,BX
	SAR  AX,CL
	POP  BX
	MOV  [BX],AL
;	glbptr=glbptr+symsiz; 
	MOV  AX,[glbptr	]
	PUSH AX
	MOV  AX,16
	POP  BX
	ADD  AX,BX
	MOV  [glbptr	],AX
;	return cptr; 
	MOV  AX,[cptr	]
	ADD  SP,2
	RET
;} 
; 
;addloc(sname,id,typ,value) 
addloc:
;	char *sname,id,typ; 
;	int value; 
;{	char *ptr; 
	PUSH AX
;	if(cptr=findloc(sname))return cptr; 
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL findloc
	ADD  SP,2
	MOV  [cptr	],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc360
	MOV  AX,[cptr	]
	ADD  SP,2
	RET
;	if(locptr>=endloc) 
cc360:
	MOV  AX,[locptr	]
	PUSH AX
	MOV  AX,symtab
	PUSH AX
	MOV  AX,5760
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,16
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JAE  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc361
;		{error("local symbol table overflow"); 
	MOV  AX,cc1+572
	PUSH AX
	CALL error
	ADD  SP,2
;		return 0; 
	MOV  AX,0
	ADD  SP,2
	RET
;		} 
;	cptr=ptr=locptr; 
cc361:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,[locptr	]
	POP  BX
	MOV  [BX],AX
	MOV  [cptr	],AX
;	while(an(*ptr++ = *sname++));	/* copy name */ 
cc362:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	PUSH AX
	MOV  AX,12
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
	PUSH AX
	CALL an
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc363
	JMP  cc362
cc363:
;	cptr[ident]=id; 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;	cptr[type]=typ; 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;	cptr[storage]=stkloc; 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,13
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,2
	POP  BX
	MOV  [BX],AL
;	cptr[offset]=value; 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,14
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AL
;	cptr[offset+1]=value>>8; 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,14
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,8
	POP  BX
	MOV  CL,AL
	MOV  AX,BX
	SAR  AX,CL
	POP  BX
	MOV  [BX],AL
;	locptr=locptr+symsiz; 
	MOV  AX,[locptr	]
	PUSH AX
	MOV  AX,16
	POP  BX
	ADD  AX,BX
	MOV  [locptr	],AX
;	return cptr; 
	MOV  AX,[cptr	]
	ADD  SP,2
	RET
;} 
; 
;/* Test if next input string is legal symbol name */ 
;symname(sname) 
symname:
;	char *sname; 
;{	int k;char c; 
	PUSH AX
	DEC  SP
;	blanks(); 
	CALL blanks
;	if(alpha(chr())==0)return 0; 
	CALL chr
	PUSH AX
	CALL alpha
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc364
	MOV  AX,0
	ADD  SP,3
	RET
;	k=0; 
cc364:
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;	while(an(chr()))sname[k++]=gchr(); 
cc365:
	CALL chr
	PUSH AX
	CALL an
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc366
	MOV  AX,5
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL gchr
	POP  BX
	MOV  [BX],AL
	JMP  cc365
cc366:
;	sname[k]=0; 
	MOV  AX,5
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AL
;	return 1; 
	MOV  AX,1
	ADD  SP,3
	RET
;	} 
; 
;/* Return next avail internal label number */ 
;getlabel() 
getlabel:
;{	return(++nxtlab); 
	MOV  AX,[nxtlab	]
	INC  AX
	MOV  [nxtlab	],AX
	RET
;} 
; 
;/* Print specified number as label */ 
;printlabel(label) 
printlab:
;	int label; 
;{	outstr("cc"); 
	MOV  AX,cc1+600
	PUSH AX
	CALL outstr
	ADD  SP,2
;	outdec(label); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL outdec
	ADD  SP,2
;} 
	RET
;/* Test if given character is alpha */ 
;alpha(c) 
alpha:
;	char c; 
;{	c=c&127; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,127
	POP  BX
	AND  AX,BX
	POP  BX
	MOV  [BX],AL
;	return(((c>='a')&(c<='z'))| 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,97
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,122
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JLE  $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	PUSH AX
;		((c>='A')&(c<='Z'))| 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,65
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,90
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JLE  $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	POP  BX
	OR   AX,BX
	PUSH AX
;		(c=='_')); 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,95
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	RET
;} 
;/* Test if given character is numeric */ 
;numeric(c) 
numeric:
;	char c; 
;{	c=c&127; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,127
	POP  BX
	AND  AX,BX
	POP  BX
	MOV  [BX],AL
;	return((c>='0')&(c<='9')); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,48
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,57
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JLE  $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	RET
;} 
;/* Test if given character is alphanumeric */ 
;an(c) 
an:
;	char c; 
;{	return((alpha(c))|(numeric(c))); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	CALL alpha
	ADD  SP,2
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	CALL numeric
	ADD  SP,2
	POP  BX
	OR   AX,BX
	RET
;} 
; 
;addwhile(ptr) 
addwhile:
;	int ptr[]; 
; { 
;	int k; 
	PUSH AX
;	if (wqptr==wqmax) 
	MOV  AX,[wqptr	]
	PUSH AX
	MOV  AX,wq
	PUSH AX
	MOV  AX,100
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,4
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc367
;		{error("too many active whiles");return;} 
	MOV  AX,cc1+603
	PUSH AX
	CALL error
	ADD  SP,2
	ADD  SP,2
	RET
;	k=0; 
cc367:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;	while (k < wqsiz) 
cc368:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,4
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc369
;		{*wqptr++ = ptr[k++];} 
	MOV  AX,[wqptr	]
	INC  AX
	INC  AX
	MOV  [wqptr	],AX
	DEC  AX
	DEC  AX
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
	JMP  cc368
cc369:
;} 
	ADD  SP,2
	RET
;delwhile() 
delwhile:
;	{if(readwhile()) wqptr=wqptr-wqsiz; 
	CALL readwhil
	CMP  AX,0
	JNE  $+5
	JMP  cc370
	MOV  AX,[wqptr	]
	PUSH AX
	MOV  AX,4
	ADD  AX,AX
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	MOV  [wqptr	],AX
;	} 
cc370:
	RET
;readwhile() 
readwhil:
; { 
;	if (wqptr==wq){error("no active whiles");return 0;} 
	MOV  AX,[wqptr	]
	PUSH AX
	MOV  AX,wq
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc371
	MOV  AX,cc1+626
	PUSH AX
	CALL error
	ADD  SP,2
	MOV  AX,0
	RET
;	else return (wqptr-wqsiz); 
	JMP  cc372
cc371:
	MOV  AX,[wqptr	]
	PUSH AX
	MOV  AX,4
	ADD  AX,AX
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	RET
cc372:
; } 
	RET
; 
;chr() 
chr:
;{	return(line[lptr]&127); 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,127
	POP  BX
	AND  AX,BX
	RET
;} 
;nchr() 
nchr:
;{	if(chr()==0)return 0; 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc373
	MOV  AX,0
	RET
;		else return(line[lptr+1]&127); 
	JMP  cc374
cc373:
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,127
	POP  BX
	AND  AX,BX
	RET
cc374:
;} 
	RET
;gchr() 
gchr:
;{	if(chr()==0)return 0; 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc375
	MOV  AX,0
	RET
;		else return(line[lptr++]&127); 
	JMP  cc376
cc375:
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	INC  AX
	MOV  [lptr	],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,127
	POP  BX
	AND  AX,BX
	RET
cc376:
;} 
	RET
;kill() 
kill:
;{	lptr=0; 
	MOV  AX,0
	MOV  [lptr	],AX
;	line[lptr]=0; 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AL
;} 
	RET
;inbyte() 
inbyte:
;{ 
;	while(chr()==0) 
cc377:
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc378
;		{if (eof) return 0; 
	MOV  AX,[eof	]
	CMP  AX,0
	JNE  $+5
	JMP  cc379
	MOV  AX,0
	RET
;		inline(); 
cc379:
	CALL inline
;		preprocess(); 
	CALL preproce
;		} 
	JMP  cc377
cc378:
;	return gchr(); 
	CALL gchr
	RET
;} 
;inchar() 
inchar:
;{ 
;	if(chr()==0)inline(); 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc380
	CALL inline
;	if(eof)return 0; 
cc380:
	MOV  AX,[eof	]
	CMP  AX,0
	JNE  $+5
	JMP  cc381
	MOV  AX,0
	RET
;	return(gchr()); 
cc381:
	CALL gchr
	RET
;} 
;inline() 
inline:
;{ 
;	int k,unit; 
	PUSH AX
	PUSH AX
;	while(1) 
cc382:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc383
;		{if (input==0)openin(); 
	MOV  AX,[input	]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc384
	CALL openin
;		if(eof)return; 
cc384:
	MOV  AX,[eof	]
	CMP  AX,0
	JNE  $+5
	JMP  cc385
	ADD  SP,4
	RET
;		if((unit=input2)==0)unit=input; 
cc385:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,[input2	]
	POP  BX
	MOV  [BX],AX
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc386
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,[input	]
	POP  BX
	MOV  [BX],AX
;		kill(); 
cc386:
	CALL kill
;		while((k=getc(unit))>0) 
cc387:
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL getc
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JG   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc388
;			{if((k==eol)|(lptr>=linemax))break; 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,10
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,[lptr	]
	PUSH AX
	MOV  AX,80
	PUSH AX
	MOV  AX,1
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc389
	JMP  cc388
;			line[lptr++]=k; 
cc389:
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	INC  AX
	MOV  [lptr	],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AL
;			} 
	JMP  cc387
cc388:
;		line[lptr]=0;	/* append null */ 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AL
;		if(k<=0) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JLE  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc390
;			{fclose(unit); 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL fclose
	ADD  SP,2
;			if(input2)input2=0; 
	MOV  AX,[input2	]
	CMP  AX,0
	JNE  $+5
	JMP  cc391
	MOV  AX,0
	MOV  [input2	],AX
;				else input=0; 
	JMP  cc392
cc391:
	MOV  AX,0
	MOV  [input	],AX
cc392:
;			} 
;		if(lptr) 
cc390:
	MOV  AX,[lptr	]
	CMP  AX,0
	JNE  $+5
	JMP  cc393
;			{if((ctext)&(cmode)) 
	MOV  AX,[ctext	]
	PUSH AX
	MOV  AX,[cmode	]
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc394
;				{comment(); 
	CALL comment
;				outstr(line); 
	MOV  AX,line
	PUSH AX
	CALL outstr
	ADD  SP,2
;				nl(); 
	CALL nl
;				} 
;			lptr=0; 
cc394:
	MOV  AX,0
	MOV  [lptr	],AX
;			return; 
	ADD  SP,4
	RET
;			} 
;		} 
cc393:
	JMP  cc382
cc383:
;} 
	ADD  SP,4
	RET
; 
;/** ch > chr, gch > gchr, nch > nchr           **/ 
;keepch(c) 
keepch:
;	char c; 
;{	mline[mptr]=c; 
	MOV  AX,mline
	PUSH AX
	MOV  AX,[mptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;	if(mptr < mpmax)mptr++; 
	MOV  AX,[mptr	]
	PUSH AX
	MOV  AX,80
	PUSH AX
	MOV  AX,1
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc395
	MOV  AX,[mptr	]
	INC  AX
	MOV  [mptr	],AX
	DEC  AX
;	return c; 
cc395:
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	RET
;} 
; 
;preprocess() /* Process Line in LineBuffer line[k] */ 
preproce:
;{	int k; 
	PUSH AX
;	char c,sname[namesize]; 
	DEC  SP
	XCHG AX,BX
	MOV  AX,-9
	ADD  AX,SP
	MOV  SP,AX
	XCHG AX,BX
;	if(cmode==0)return; 
	MOV  AX,[cmode	]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc396
	ADD  SP,12
	RET
;	mptr=lptr=0; 
cc396:
	MOV  AX,0
	MOV  [lptr	],AX
	MOV  [mptr	],AX
;	while(chr()) 
cc397:
	CALL chr
	CMP  AX,0
	JNE  $+5
	JMP  cc398
;		{if((chr()==' ')|(chr()==9)) /* filter sp, tab */ 
	CALL chr
	PUSH AX
	MOV  AX,32
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	CALL chr
	PUSH AX
	MOV  AX,9
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc399
;			{keepch(' '); 
	MOV  AX,32
	PUSH AX
	CALL keepch
	ADD  SP,2
;			while((chr()==' ')| 
cc400:
	CALL chr
	PUSH AX
	MOV  AX,32
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
;				(chr()==9)) 
	CALL chr
	PUSH AX
	MOV  AX,9
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc401
;				gchr(); 
	CALL gchr
	JMP  cc400
cc401:
;			} 
;		else if(chr()=='"')         /* filter double quote */ 
	JMP  cc402
cc399:
	CALL chr
	PUSH AX
	MOV  AX,34
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc403
;			{keepch(chr()); 
	CALL chr
	PUSH AX
	CALL keepch
	ADD  SP,2
;			gchr(); 
	CALL gchr
;			while(chr()!='"') 
cc404:
	CALL chr
	PUSH AX
	MOV  AX,34
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc405
;				{if(chr()==0) 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc406
;				  {error("missing quote"); 
	MOV  AX,cc1+643
	PUSH AX
	CALL error
	ADD  SP,2
;				  break; 
	JMP  cc405
;				  } 
;				keepch(gchr()); 
cc406:
	CALL gchr
	PUSH AX
	CALL keepch
	ADD  SP,2
;				} 
	JMP  cc404
cc405:
;			gchr(); 
	CALL gchr
;			keepch('"'); 
	MOV  AX,34
	PUSH AX
	CALL keepch
	ADD  SP,2
;			} 
;		else if(chr()==39)          /* filter single quote */ 
	JMP  cc407
cc403:
	CALL chr
	PUSH AX
	MOV  AX,39
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc408
;			{keepch(39); 
	MOV  AX,39
	PUSH AX
	CALL keepch
	ADD  SP,2
;			gchr(); 
	CALL gchr
;			while(chr()!=39) 
cc409:
	CALL chr
	PUSH AX
	MOV  AX,39
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc410
;				{if(chr()==0) 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc411
;				  {error("missing apostrophe"); 
	MOV  AX,cc1+657
	PUSH AX
	CALL error
	ADD  SP,2
;				  break; 
	JMP  cc410
;				  } 
;				keepch(gchr()); 
cc411:
	CALL gchr
	PUSH AX
	CALL keepch
	ADD  SP,2
;				} 
	JMP  cc409
cc410:
;			gchr(); 
	CALL gchr
;			keepch(39); 
	MOV  AX,39
	PUSH AX
	CALL keepch
	ADD  SP,2
;			} 
;		else if((chr()=='/')&(nchr()=='*')) /* filter bi-glyph, comment start */ 
	JMP  cc412
cc408:
	CALL chr
	PUSH AX
	MOV  AX,47
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	CALL nchr
	PUSH AX
	MOV  AX,42
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc413
;			{inchar();inchar(); 
	CALL inchar
	CALL inchar
;			while(((chr()=='*')& 
cc414:
	CALL chr
	PUSH AX
	MOV  AX,42
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
;				(nchr()=='/'))==0) 
	CALL nchr
	PUSH AX
	MOV  AX,47
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc415
;				{if(chr()==0)inline(); 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc416
	CALL inline
;					else inchar(); 
	JMP  cc417
cc416:
	CALL inchar
cc417:
;				if(eof)break; 
	MOV  AX,[eof	]
	CMP  AX,0
	JNE  $+5
	JMP  cc418
	JMP  cc415
;				} 
cc418:
	JMP  cc414
cc415:
;			inchar();inchar(); 
	CALL inchar
	CALL inchar
;			} 
;		else if(an(chr()))  /* CK alpha-numeric */ 
	JMP  cc419
cc413:
	CALL chr
	PUSH AX
	CALL an
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc420
;			{k=0; 
	MOV  AX,10
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;			while(an(chr())) 
cc421:
	CALL chr
	PUSH AX
	CALL an
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc422
;				{if(k < namemax)sname[k++]=chr(); 
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,8
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc423
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,12
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL chr
	POP  BX
	MOV  [BX],AL
;				gchr(); 
cc423:
	CALL gchr
;				} 
	JMP  cc421
cc422:
;			sname[k]=0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,12
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AL
;			if(k=findmac(sname)) 
	MOV  AX,10
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	CALL findmac
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc424
;				while(c=macq[k++]) 
cc425:
	MOV  AX,9
	ADD  AX,SP
	PUSH AX
	MOV  AX,macq
	PUSH AX
	MOV  AX,14
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
	CMP  AX,0
	JNE  $+5
	JMP  cc426
;					keepch(c); 
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	CALL keepch
	ADD  SP,2
	JMP  cc425
cc426:
;			else 
	JMP  cc427
cc424:
;				{k=0; 
	MOV  AX,10
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;				while(c=sname[k++]) 
cc428:
	MOV  AX,9
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,14
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
	CMP  AX,0
	JNE  $+5
	JMP  cc429
;					keepch(c); 
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	CALL keepch
	ADD  SP,2
	JMP  cc428
cc429:
;				} 
cc427:
;			} 
;		else keepch(gchr()); 
	JMP  cc430
cc420:
	CALL gchr
	PUSH AX
	CALL keepch
	ADD  SP,2
cc430:
cc419:
cc412:
cc407:
cc402:
;		} 
	JMP  cc397
cc398:
;	keepch(0); 
	MOV  AX,0
	PUSH AX
	CALL keepch
	ADD  SP,2
;	if(mptr>=mpmax)error("line too long"); 
	MOV  AX,[mptr	]
	PUSH AX
	MOV  AX,80
	PUSH AX
	MOV  AX,1
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc431
	MOV  AX,cc1+676
	PUSH AX
	CALL error
	ADD  SP,2
;	lptr=mptr=0; 
cc431:
	MOV  AX,0
	MOV  [mptr	],AX
	MOV  [lptr	],AX
;	while(line[lptr++]=mline[mptr++]); 
cc432:
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	INC  AX
	MOV  [lptr	],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,mline
	PUSH AX
	MOV  AX,[mptr	]
	INC  AX
	MOV  [mptr	],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
	CMP  AX,0
	JNE  $+5
	JMP  cc433
	JMP  cc432
cc433:
;	lptr=0; 
	MOV  AX,0
	MOV  [lptr	],AX
;} 
	ADD  SP,12
	RET
; 
;/************************************************/ 
;streq(str1,str2) 
streq:
;	char str1[],str2[]; 
; { 
;	int k; 
	PUSH AX
;	k=0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;	while (str2[k]) 
cc434:
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc435
;		{if ((str1[k])!=(str2[k])) return 0; 
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc436
	MOV  AX,0
	ADD  SP,2
	RET
;		k++; 
cc436:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
;		} 
	JMP  cc434
cc435:
;	return k; 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,2
	RET
; } 
; 
;astreq(str1,str2,len) 
astreq:
;	char str1[],str2[];int len; 
; { 
;	int k; 
	PUSH AX
;	k=0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;	while (k < len) 
cc437:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc438
;		{if ((str1[k])!=(str2[k]))break; 
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc439
	JMP  cc438
;		if(str1[k]==0)break; 
cc439:
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc440
	JMP  cc438
;		if(str2[k]==0)break; 
cc440:
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc441
	JMP  cc438
;		k++; 
cc441:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
;		} 
	JMP  cc437
cc438:
;	if (an(str1[k]))return 0; 
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	CALL an
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc442
	MOV  AX,0
	ADD  SP,2
	RET
;	if (an(str2[k]))return 0; 
cc442:
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	CALL an
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc443
	MOV  AX,0
	ADD  SP,2
	RET
;	return k; 
cc443:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,2
	RET
; } 
; 
;match(lit) 
match:
;	char *lit; 
;{ 
;	int k; 
	PUSH AX
;	blanks(); 
	CALL blanks
;	if (k=streq(line+lptr,lit)) 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL streq
	ADD  SP,4
	POP  BX
	MOV  [BX],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc444
;		{lptr=lptr+k; 
	MOV  AX,[lptr	]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	MOV  [lptr	],AX
;		return 1; 
	MOV  AX,1
	ADD  SP,2
	RET
;		} 
; 	return 0; 
cc444:
	MOV  AX,0
	ADD  SP,2
	RET
;} 
; 
;amatch(lit,len) 
amatch:
;	char *lit;int len; 
; { 
;	int k; 
	PUSH AX
;	blanks(); 
	CALL blanks
;	if (k=astreq(line+lptr,lit,len)) 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL astreq
	ADD  SP,6
	POP  BX
	MOV  [BX],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc445
;		{lptr=lptr+k; 
	MOV  AX,[lptr	]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	MOV  [lptr	],AX
;		while(an(chr())) inbyte(); 
cc446:
	CALL chr
	PUSH AX
	CALL an
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc447
	CALL inbyte
	JMP  cc446
cc447:
;		return 1; 
	MOV  AX,1
	ADD  SP,2
	RET
;		} 
;	return 0; 
cc445:
	MOV  AX,0
	ADD  SP,2
	RET
; } 
; 
;blanks() 
blanks:
;	{while(1) 
cc448:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc449
;		{while(chr()==0) 
cc450:
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc451
;			{inline(); 
	CALL inline
;			preprocess(); 
	CALL preproce
;			if(eof)break; 
	MOV  AX,[eof	]
	CMP  AX,0
	JNE  $+5
	JMP  cc452
	JMP  cc451
;			} 
cc452:
	JMP  cc450
cc451:
;		if(chr()==' ')gchr(); 
	CALL chr
	PUSH AX
	MOV  AX,32
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc453
	CALL gchr
;		else if(chr()==9)gchr(); 
	JMP  cc454
cc453:
	CALL chr
	PUSH AX
	MOV  AX,9
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc455
	CALL gchr
;		else return; 
	JMP  cc456
cc455:
	RET
cc456:
cc454:
;		} 
	JMP  cc448
cc449:
;	} 
	RET
; 
;/**  SCN_III.C **/ 
;/** Next is SCN_IV.C **/ 
;/************************************************/ 
;/** Modified for NASM as SCN_IV.C Small-C, nasm**/ 
;/** Last: 29 JUL 2007 Init: 31 MAR 2007        **/ 
;/** By: s_dubrovich@yahoo.com                  **/ 
;/** Vers: 0.0.3b  Goal: NASM ouput             **/ 
;/**					       **/ 
;/************************************************/ 
;/* ToBe Modified for NASM as SCCN.C --          */ 
;/*  Small-C Compiler - Nasm                     */ 
;/* Last: 15 JUL 2007 Init: 14 JUL 2007          */ 
;/* By: s_dubrovich@yahoo.com                    */ 
;/* Vers: 0.0.1b  Goal: NASM ouput               */ 
;/* Comments:                                    */ 
;/*  This is a new offshoot of development from  */ 
;/*  NCn.C as changes beyond CC8.C are intended. */ 
;/*  NCn.C is Archived, Closed to further        */ 
;/*  development, superceded by this effort SCCN.*/ 
;/* EndComments:                                 */ 
;/** SCCN.C is parked                           **/ 
;/************************************************/ 
;/** New Development Branch                     **/ 
;/************************************************/ 
;/** Re-Codified as:                            **/ 
;/**	I.   Global Storage Defn, main()       **/ 
;/**     II.  Recursive Descent Parser          **/ 
;/**     III. Utility Functions                 **/ 
;/**     IV.  U.I. & I/O                        **/ 
;/**     V.   Backend, NASM Object Output       **/ 
;/************************************************/ 
;/************************************************/ 
;/*						*/ 
;/*		small-c compiler		*/ 
;/*                  rev. 1.1                    */ 
;/*		  by Ron Cain			*/ 
;/*		    (1980)			*/ 
;/************************************************/ 
;/** Fn's in this file **/ 
;/**	ask();		* get user options */ 
;/**	openout();	* get an output file */ 
;/**	openin();	* and initial input file */ 
;/**	header();	* intro code */ 
;/** Logically Parse is here **/ 
;/**	dumplits();	* then dump literal pool */ 
;/** dump global static defs. to output source,  **/ 
;/**  required **/ 
;/**	dumpglbs();	* and all static memory  */ 
;/** original place, added back in **/ 
;/**	errorsummary();	* summarize errors */ 
;/**	trailer();	* follow-up code */ 
;/**	closeout();	* close the output (if any) */ 
;/**	return;		* then exit to system */ 
;/************************************************/ 
;/** doinclude() **/ 
;/************************************************/ 
; 
;/*					*/ 
;/*	Get options from user		*/ 
;/*					*/ 
;ask() 
ask:
;	{ 
;	int k,num[1]; 
	PUSH AX
	PUSH AX
;	kill();			/* clear input line */ 
	CALL kill
;/**	outbyte(12);	* Form Feed, clear the screen */ 
;	nl();nl();nl();		/* print banner */ 
	CALL nl
	CALL nl
	CALL nl
;	pl("     * * *  small-c compiler  * * *"); 
	MOV  AX,cc1+690
	PUSH AX
	CALL pl
	ADD  SP,2
;	nl(); 
	CALL nl
;	pl("              by Ron Cain"); 
	MOV  AX,cc1+726
	PUSH AX
	CALL pl
	ADD  SP,2
;	nl(); 
	CALL nl
;	pl("* NASM Vers c0.1.5, Aug. 2008, s_dubrovich@yahoo.com *"); 
	MOV  AX,cc1+752
	PUSH AX
	CALL pl
	ADD  SP,2
;	nl(); 
	CALL nl
;	/* see if user wants to interleave the c-text */ 
;	/*	in form of comments (for clarity) */ 
;	pl("Do you want the c-text to appear? (y) "); 
	MOV  AX,cc1+807
	PUSH AX
	CALL pl
	ADD  SP,2
;	gets(line);		/* get answer */ 
	MOV  AX,line
	PUSH AX
	CALL gets
	ADD  SP,2
;	ctext=0;		/* assume no */ 
	MOV  AX,0
	MOV  [ctext	],AX
;	if((chr()=='Y')|(chr()=='y')) 
	CALL chr
	PUSH AX
	MOV  AX,89
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	CALL chr
	PUSH AX
	MOV  AX,121
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc457
;		ctext=1;	/* user said yes */ 
	MOV  AX,1
	MOV  [ctext	],AX
; 	/* see if user wants us to allocate static */ 
; 	/*  variables by name in this module	*/ 
; 	/*	(pseudo external capability)	*/ 
; 	pl("Do you wish the globals to be defined? (y) "); 
cc457:
	MOV  AX,cc1+846
	PUSH AX
	CALL pl
	ADD  SP,2
; 	gets(line); 
	MOV  AX,line
	PUSH AX
	CALL gets
	ADD  SP,2
; 	glbflag=0; 
	MOV  AX,0
	MOV  [glbflag	],AX
; 	if((chr()=='Y')|(chr()=='y')) 
	CALL chr
	PUSH AX
	MOV  AX,89
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	CALL chr
	PUSH AX
	MOV  AX,121
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc458
; 		glbflag=1;	/* user said yes */ 
	MOV  AX,1
	MOV  [glbflag	],AX
;	/* get first allowable number for compiler-generated */ 
; 	/*	labels (in case user will append modules) */ 
; 	while(1){ 
cc458:
cc459:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc460
; 		pl("Starting number for labels? (0) "); 
	MOV  AX,cc1+890
	PUSH AX
	CALL pl
	ADD  SP,2
; 		gets(line); 
	MOV  AX,line
	PUSH AX
	CALL gets
	ADD  SP,2
; 		if(chr()==0){num[0]=0;break;} 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc461
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
	JMP  cc460
;		if(k=number(num))break; 
cc461:
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	CALL number
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
	CMP  AX,0
	JNE  $+5
	JMP  cc462
	JMP  cc460
;		} 
cc462:
	JMP  cc459
cc460:
;	nxtlab=num[0]; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  [nxtlab	],AX
;	litlab=getlabel();	/* first label=literal pool */  
	CALL getlabel
	MOV  [litlab	],AX
;	kill();			/* erase line */ 
	CALL kill
;	} 
	ADD  SP,4
	RET
; 
;/*					*/ 
;/*	Get output filename		*/ 
;/*					*/ 
;openout() 
openout:
;	{ 
;	kill();			/* erase line */ 
	CALL kill
;	output=0;		/* start with none */ 
	MOV  AX,0
	MOV  [output	],AX
;	pl("Output filename? "); /* ask...*/ 
	MOV  AX,cc1+923
	PUSH AX
	CALL pl
	ADD  SP,2
;	gets(line);	/* get a filename */ 
	MOV  AX,line
	PUSH AX
	CALL gets
	ADD  SP,2
;	if(chr()==0)return;	/* none given... */ 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc463
	RET
;	if((output=fopen(line,"w"))==NULL) /* if given, open */ 
cc463:
	MOV  AX,line
	PUSH AX
	MOV  AX,cc1+941
	PUSH AX
	CALL fopen
	ADD  SP,4
	MOV  [output	],AX
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc464
;		{output=0;	/* can't open */ 
	MOV  AX,0
	MOV  [output	],AX
;		error("Open failure!"); 
	MOV  AX,cc1+943
	PUSH AX
	CALL error
	ADD  SP,2
;		} 
;	kill();			/* erase line */ 
cc464:
	CALL kill
;} 
	RET
; 
; 
;/*					*/ 
;/*	Get (next) input file		*/ 
;/*					*/ 
;openin() 
openin:
;{ 
;	input=0;		/* none to start with */ 
	MOV  AX,0
	MOV  [input	],AX
;	while(input==0){	/* any above 1 allowed */ 
cc465:
	MOV  AX,[input	]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc466
;		kill();		/* clear line */ 
	CALL kill
;		if(eof)break;	/* if user said none */ 
	MOV  AX,[eof	]
	CMP  AX,0
	JNE  $+5
	JMP  cc467
	JMP  cc466
;		pl("Input filename? "); 
cc467:
	MOV  AX,cc1+957
	PUSH AX
	CALL pl
	ADD  SP,2
;		gets(line);	/* get a name */ 
	MOV  AX,line
	PUSH AX
	CALL gets
	ADD  SP,2
;		if(chr()==0) 
	CALL chr
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc468
;			{eof=1;break;} /* none given... */ 
	MOV  AX,1
	MOV  [eof	],AX
	JMP  cc466
;		if((input=fopen(line,"r"))==NULL) 
cc468:
	MOV  AX,line
	PUSH AX
	MOV  AX,cc1+974
	PUSH AX
	CALL fopen
	ADD  SP,4
	MOV  [input	],AX
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc469
;			{input=0;	/* can't open it */ 
	MOV  AX,0
	MOV  [input	],AX
;			pl("Open failure"); 
	MOV  AX,cc1+976
	PUSH AX
	CALL pl
	ADD  SP,2
;			} 
;		} 
cc469:
	JMP  cc465
cc466:
;	kill();		/* erase line */ 
	CALL kill
;	} 
	RET
; 
;/*					*/ 
;/*	Report errors for user		*/ 
;/*					*/ 
;errorsummary() 
errorsum:
;	{ 
;	/* see if anything left hanging... */ 
;	if (ncmp) error("missing closing bracket"); 
	MOV  AX,[ncmp	]
	CMP  AX,0
	JNE  $+5
	JMP  cc470
	MOV  AX,cc1+989
	PUSH AX
	CALL error
	ADD  SP,2
;		/* open compound statement ... */ 
;	nl(); 
cc470:
	CALL nl
;	comment(); 
	CALL comment
;	outdec(errcnt);	/* total # errors */ 
	MOV  AX,[errcnt	]
	PUSH AX
	CALL outdec
	ADD  SP,2
;	outstr(" errors in compilation."); 
	MOV  AX,cc1+1013
	PUSH AX
	CALL outstr
	ADD  SP,2
;	nl(); 
	CALL nl
;	} 
	RET
; 
;/*					*/ 
;/*	Close the output file		*/ 
;/*					*/ 
;closeout() 
closeout:
;{ 
;	if(output)fclose(output); /* if open, close it */ 
	MOV  AX,[output	]
	CMP  AX,0
	JNE  $+5
	JMP  cc471
	MOV  AX,[output	]
	PUSH AX
	CALL fclose
	ADD  SP,2
;	output=0;		/* mark as closed */ 
cc471:
	MOV  AX,0
	MOV  [output	],AX
;} 
	RET
; 
; 
;/*					*/ 
;/*	Dump the literal pool		*/ 
;/*					*/ 
;dumplits() 
dumplits:
;	{int j,k; 
	PUSH AX
	PUSH AX
;	if (litptr==0) return;	/* if nothing there, exit...*/ 
	MOV  AX,[litptr	]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc472
	ADD  SP,4
	RET
; 
;	do_dseg();     /** in SCCN8.C for section .dseg **/ 
cc472:
	CALL do_dseg
;	nl(); 
	CALL nl
; 
;	printlabel(litlab);col(); /* print literal label */ 
	MOV  AX,[litlab	]
	PUSH AX
	CALL printlab
	ADD  SP,2
	CALL col
;	k=0;			/* init an index... */ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;	while (k < litptr)	/* 	to loop with */ 
cc473:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,[litptr	]
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc474
;		{defbyte();	/* pseudo-op to define byte */ 
	CALL defbyte
;		j=10;		/* max bytes per line */ 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,10
	POP  BX
	MOV  [BX],AX
;		while(j--) 
cc475:
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	DEC  AX
	POP  BX
	MOV  [BX],AX
	INC  AX
	CMP  AX,0
	JNE  $+5
	JMP  cc476
;			{outdec((litq[k++]&127)); 
	MOV  AX,litq
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,127
	POP  BX
	AND  AX,BX
	PUSH AX
	CALL outdec
	ADD  SP,2
;			if ((j==0) | (k>=litptr)) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,[litptr	]
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc477
;				{nl();		/* need <cr> */ 
	CALL nl
;				break; 
	JMP  cc476
;				} 
;			outbyte(',');	/* separate bytes */ 
cc477:
	MOV  AX,44
	PUSH AX
	CALL outbyte
	ADD  SP,2
;			} 
	JMP  cc475
cc476:
;		} 
	JMP  cc473
cc474:
;	} 
	ADD  SP,4
	RET
; 
;/*					*/ 
;/*	Dump all static variables	*/ 
;/*					*/ 
;/** these are put to outfile, required **/ 
;/** for nasm DSegment data ref. defs.  **/ 
;/** Form; {Name,TIMES,numb,DB 0}       **/ 
; 
;dumpglbs() 
dumpglbs:
;	{ 
;	int j; 
	PUSH AX
;	if(glbflag==0)return;	/* don't if user said no */ 
	MOV  AX,[glbflag	]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc478
	ADD  SP,2
	RET
;/** do SECTION here as well, there may not be lits, above **/ 
;	do_dseg();     /** in SCCN8.C for section .dseg **/ 
cc478:
	CALL do_dseg
;	nl();	/** do in dumplits, it is first **/ 
	CALL nl
;	cptr=startglb; 
	MOV  AX,symtab
	MOV  [cptr	],AX
;	while(cptr < glbptr) 
cc479:
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,[glbptr	]
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JB   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc480
;		{if(cptr[ident]!=function) 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,4
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc481
;			/* do if anything but function */ 
;			{outstr(cptr);col(); 
	MOV  AX,[cptr	]
	PUSH AX
	CALL outstr
	ADD  SP,2
	CALL col
;				/* output name as label... */ 
;			defstorage();	/* define storage, Times */ 
	CALL defstora
;			j=((cptr[offset]&255)+((cptr[offset+1]&255)<<8)); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,14
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,255
	POP  BX
	AND  AX,BX
	PUSH AX
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,14
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,255
	POP  BX
	AND  AX,BX
	PUSH AX
	MOV  AX,8
	POP  BX
	MOV  CL,AL
	MOV  AX,BX
	SAL  AX,CL
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;				/* calc # bytes lo,hi */ 
;/**	why?		if((cptr[type]==cint)|(cptr[ident]==pointer)) **/ 
;/**	why?			j=j+1;					**/ 
;			outdec(j);	/* need that many */ 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL outdec
	ADD  SP,2
;			if((cptr[type]==cint)|(cptr[ident]==pointer)) 
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc482
;				defword(); 
	CALL defword
;				else defbyte(); 
	JMP  cc483
cc482:
	CALL defbyte
cc483:
;			ot("0"); /** filler value **/ 
	MOV  AX,cc1+1037
	PUSH AX
	CALL ot
	ADD  SP,2
;			nl(); 
	CALL nl
;			} 
;		cptr=cptr+symsiz;  /** inc thru table **/ 
cc481:
	MOV  AX,[cptr	]
	PUSH AX
	MOV  AX,16
	POP  BX
	ADD  AX,BX
	MOV  [cptr	],AX
;		} 
	JMP  cc479
cc480:
;	} 
	ADD  SP,2
	RET
; 
;/************************************************/ 
; 
;/*					*/ 
;/*	Open an include file		*/ 
;/*					*/ 
;doinclude() 
doinclud:
;{ 
;	blanks();	/* skip over to name */ 
	CALL blanks
;	if((input2=fopen(line+lptr,"r"))==NULL) 
	MOV  AX,line
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,cc1+1039
	PUSH AX
	CALL fopen
	ADD  SP,4
	MOV  [input2	],AX
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc484
;		{input2=0; 
	MOV  AX,0
	MOV  [input2	],AX
;		error("Open failure on include file"); 
	MOV  AX,cc1+1041
	PUSH AX
	CALL error
	ADD  SP,2
;		} 
;	kill();		/* clear rest of line */ 
cc484:
	CALL kill
;			/* so next read will come from */ 
;			/* new file (if open */ 
;} 
	RET
; 
;/************************************************/ 
; 
;illname() 
illname:
;{	error("illegal symbol name");junk();} 
	MOV  AX,cc1+1070
	PUSH AX
	CALL error
	ADD  SP,2
	CALL junk
	RET
; 
;multidef(sname) 
multidef:
;	char *sname; 
;{	error("already defined"); 
	MOV  AX,cc1+1090
	PUSH AX
	CALL error
	ADD  SP,2
;	comment(); 
	CALL comment
;	outstr(sname);nl(); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL outstr
	ADD  SP,2
	CALL nl
;} 
	RET
; 
;needbrack(str) 
needbrac:
;	char *str; 
;{	if (match(str)==0) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL match
	ADD  SP,2
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc485
;		{error("missing bracket"); 
	MOV  AX,cc1+1106
	PUSH AX
	CALL error
	ADD  SP,2
;		comment();outstr(str);nl(); 
	CALL comment
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL outstr
	ADD  SP,2
	CALL nl
;		} 
;} 
cc485:
	RET
; 
;needlval() 
needlval:
;{	error("must be lvalue"); 
	MOV  AX,cc1+1122
	PUSH AX
	CALL error
	ADD  SP,2
;} 
	RET
; 
;/************************************************/ 
;/* Print a carriage return and a string only to console */ 
;pl(str) 
pl:
;	char *str; 
;{	int k; 
	PUSH AX
;	k=0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;	putchar(eol); 
	MOV  AX,10
	PUSH AX
	CALL putchar
	ADD  SP,2
;	while(str[k])putchar(str[k++]); 
cc486:
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc487
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	CALL putchar
	ADD  SP,2
	JMP  cc486
cc487:
;} 
	ADD  SP,2
	RET
; 
; 
;/************************************************/ 
;/** putc <- outbyte <- nl, outstr <- ol        **/ 
;/** Note: null, eof, cause closeout.           **/ 
; 
;outbyte(c)  /** Note usage: outbyte must return null or chr **/ 
outbyte:
;	char c; 
;{ 
;	if(c==0)return 0; /** don't pass null terminator in **/ 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc488
	MOV  AX,0
	RET
;	if(output)  /** output is file fp_ **/ 
cc488:
	MOV  AX,[output	]
	CMP  AX,0
	JNE  $+5
	JMP  cc489
;		{ 
;		if((putc(c,output))<=0) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,[output	]
	PUSH AX
	CALL putc
	ADD  SP,4
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JLE  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc490
;			{ 
;			closeout(); 
	CALL closeout
;			error("Output file error"); 
	MOV  AX,cc1+1137
	PUSH AX
	CALL error
	ADD  SP,2
;			} 
;		} 
cc490:
;	else putchar(c); 
	JMP  cc491
cc489:
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	CALL putchar
	ADD  SP,2
cc491:
;	return c; 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	RET
;} 
; 
;outstr(ptr) 
outstr:
;	char ptr[]; 
;{ 
;	int k; 
	PUSH AX
;	k=0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;  /** Note usage: outbyte must return null or chr **/ 
;	while(outbyte(ptr[k++])); 
cc492:
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	CALL outbyte
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc493
	JMP  cc492
cc493:
;} 
	ADD  SP,2
	RET
; 
;/** was nl() {outbyte(eol);} **/ 
;nl()	{outbyte(13); outbyte(10);} 
nl:
	MOV  AX,13
	PUSH AX
	CALL outbyte
	ADD  SP,2
	MOV  AX,10
	PUSH AX
	CALL outbyte
	ADD  SP,2
	RET
; 
;tab()	{outbyte(9);} 
tab:
	MOV  AX,9
	PUSH AX
	CALL outbyte
	ADD  SP,2
	RET
; 
;col()	{outbyte(58);} /** colon **/ 
col:
	MOV  AX,58
	PUSH AX
	CALL outbyte
	ADD  SP,2
	RET
; 
;error(ptr) 
error:
;	char ptr[]; 
;{ 
;	int k; 
	PUSH AX
;	comment();outstr(line);nl();comment(); 
	CALL comment
	MOV  AX,line
	PUSH AX
	CALL outstr
	ADD  SP,2
	CALL nl
	CALL comment
;	k=0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;	while(k < lptr) 
cc494:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,[lptr	]
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc495
;		{if(line[k]==9) tab(); 
	MOV  AX,line
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,9
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc496
	CALL tab
;			else outbyte(' '); 
	JMP  cc497
cc496:
	MOV  AX,32
	PUSH AX
	CALL outbyte
	ADD  SP,2
cc497:
;			++k; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
;			} 
	JMP  cc494
cc495:
;	outbyte('^'); 
	MOV  AX,94
	PUSH AX
	CALL outbyte
	ADD  SP,2
;	nl();comment();outstr("******  "); 
	CALL nl
	CALL comment
	MOV  AX,cc1+1155
	PUSH AX
	CALL outstr
	ADD  SP,2
;	outstr(ptr); 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL outstr
	ADD  SP,2
;	outstr("  ******"); 
	MOV  AX,cc1+1164
	PUSH AX
	CALL outstr
	ADD  SP,2
;	nl(); 
	CALL nl
;	++errcnt; 
	MOV  AX,[errcnt	]
	INC  AX
	MOV  [errcnt	],AX
;} 
	ADD  SP,2
	RET
; 
;ol(ptr) 
ol:
;	char ptr[]; 
;{ 
;	ot(ptr); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL ot
	ADD  SP,2
;	nl(); 
	CALL nl
;} 
	RET
; 
;ot(ptr) 
ot:
;	char ptr[]; 
;{ 
;	tab(); 
	CALL tab
;	outstr(ptr);	/*outasm*/ 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL outstr
	ADD  SP,2
;} 
	RET
; 
;/************************************************/ 
; 
;outdec(number) 
outdec:
;	int number; 
; { 
;	int k,zs; 
	PUSH AX
	PUSH AX
;	char c; 
	DEC  SP
;	zs = 0; 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;	k=10000; 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,10000
	POP  BX
	MOV  [BX],AX
;	if (number < 0) 
	MOV  AX,7
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc498
;		{number=(-number); 
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	NEG  AX
	POP  BX
	MOV  [BX],AX
;		outbyte('-'); 
	MOV  AX,45
	PUSH AX
	CALL outbyte
	ADD  SP,2
;		} 
;	while (k>=1) 
cc498:
cc499:
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc500
;		{ 
;		c=number/k + '0'; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,7
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	XCHG AX,BX
	MOV  DX,0
	DIV  BX
	MOV  BX,DX
	PUSH AX
	MOV  AX,48
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AL
;		if ((c!='0')|(k==1)|(zs)) 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,48
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,5
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc501
;			{zs=1;outbyte(c);} 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	POP  BX
	MOV  [BX],AX
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	CALL outbyte
	ADD  SP,2
;		number=number%k; 
cc501:
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,7
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	XCHG AX,BX
	MOV  DX,0
	DIV  BX
	MOV  BX,DX
	XCHG AX,BX
	POP  BX
	MOV  [BX],AX
;		k=k/10; 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,5
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,10
	POP  BX
	XCHG AX,BX
	MOV  DX,0
	DIV  BX
	MOV  BX,DX
	POP  BX
	MOV  [BX],AX
;		} 
	JMP  cc499
cc500:
; } 
	ADD  SP,5
	RET
; 
; 
;/**  SCN_IV.C **/ 
;/** Next is SCN_V.C **/ 
;/************************************************/ 
;/** Modified for NASM as SCN_V.C Small-C, nasm **/ 
;/** Last: 26 APR 2008				*/ 
;/** Prev: 29 JUL 2007 Init: 31 MAR 2007        **/ 
;/** By: s_dubrovich@yahoo.com                  **/ 
;/** Vers: 0.0.4b  Goal: NASM ouput             **/ 
;/**					       **/ 
;/************************************************/ 
;/* ToBe Modified for NASM as SCCN.C --          */ 
;/*  Small-C Compiler - Nasm                     */ 
;/* Last: 15 JUL 2007 Init: 14 JUL 2007          */ 
;/* By: s_dubrovich@yahoo.com                    */ 
;/* Vers: 0.0.1b  Goal: NASM ouput               */ 
;/* Comments:                                    */ 
;/*  This is a new offshoot of development from  */ 
;/*  NCn.C as changes beyond CC8.C are intended. */ 
;/*  NCn.C is Archived, Closed to further        */ 
;/*  development, superceded by this effort SCCN.*/ 
;/* EndComments:                                 */ 
;/** SCCN.C is parked                           **/ 
;/************************************************/ 
;/** New Development Branch                     **/ 
;/************************************************/ 
;/** Re-Codified as:                            **/ 
;/**	I.   Global Storage Defn, main()       **/ 
;/**     II.  Recursive Descent Parser          **/ 
;/**     III. Utility Functions                 **/ 
;/**     IV.  U.I. & I/O                        **/ 
;/**     V.   Backend, NASM Object Output       **/ 
;/************************************************/ 
;/************************************************/ 
;/*						*/ 
;/*		small-c compiler		*/ 
;/*                  rev. 1.1                    */ 
;/*		  by Ron Cain			*/ 
;/*		    (1980)			*/ 
;/************************************************/ 
;/** Functions in this file:			*/ 
;/** comment, header, outhexb, trailer, getmem  **/ 
;/** getloc, putmem, putstk, indirect, swap,	*/ 
;/** immed, m_push, m_push_zr, m_pop, swapstk	*/ 
;/** m_call, m_ret, callstk, jump, testjump,	*/ 
;/** do_seg, defbyte, defstorage, defword, modstk*/ 
;/** doublereg, m_add, m_sub, m_mult, m_div, mod */ 
;/** m_or, m_xor, m_and, asr, asl, m_neg, com   **/ 
;/** m_inc, m_dec, eq, ne, lt, le, gt, ult, ule **/ 
;/** ugt, uge					*/ 
;/**  SCN_V.C **/ 
;/*       1         2         3         4         5   */ 
;/*	>>>>>> start of cc8 <<<<<<<	*/ 
;/************************************************/ 
;/** Module: SCCN8.C                            **/ 
;/** Last: 23 DEC 2007  Init: 14 JUL 2007       **/ 
;/** Vers: 0.0.2b  Goal: Self Compile, Nasm out **/ 
;/** Modified for NASM by s_dubrovich@yahoo.com **/ 
;/************************************************/ 
;/** Nasm Text Output Begins in This Module     **/ 
;/** Primary: 8080.HL 8086.BX, Static Cell is DSEG **/ 
;/** Secondary: 8080.DE 8086.DX                    **/ 
;/**  -made 2 versions, SCCN8.C & SCCNT8.C test    **/ 
;/** - appx A 6.1 char are conv to ints, which  **/ 
;/**   are signed values. K&R C.                **/ 
;/** 8:47 PM 7/27/2007 -Changes Primary = AX,	**/ 
;/** Secondary = BX, chg due to sign extend AL	**/ 
;/** 10:34 PM 12/23/2007 --                      **/ 
;/** -Fixed 'indirect' mov prim,[prim]           **/ 
; 
;/* Begin a comment line for the assembler */ 
;comment() 
comment:
;{	outbyte(';'); 
	MOV  AX,59
	PUSH AX
	CALL outbyte
	ADD  SP,2
;} 
	RET
;/*       1         2         3         4         5   */ 
;/* Print all assembler info before any code          */ 
;/*  is generated.                                    */ 
; 
;header() 
header:
;{ 
;	comment(); 
	CALL comment
;	outstr("Small-c Compiler rev 1.1 re:NASM c0.1.5 Aug 2008"); 
	MOV  AX,cc1+1173
	PUSH AX
	CALL outstr
	ADD  SP,2
;	nl(); 
	CALL nl
;	ol("[MAP ALL SCCN.MAP]"); 
	MOV  AX,cc1+1222
	PUSH AX
	CALL ol
	ADD  SP,2
;/**	ol("SECTION .cseg vstart=0");	**/ 
;	ol("SECTION .text vstart=0100h"); /*** .com vers. ***/ 
	MOV  AX,cc1+1241
	PUSH AX
	CALL ol
	ADD  SP,2
;	nl(); 
	CALL nl
;} 
	RET
;/***------------------------------------------***/ 
; 
;/***------------------------------------------***/ 
; 
;outhexw(number)	int number; 
outhexw:
; { 
;	leaderx(); 
	CALL leaderx
;	hex(number); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL hex
	ADD  SP,2
; } 
	RET
; 
;hex(x) int x; 
hex:
;{ 
;	hexb(x>>8); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,8
	POP  BX
	MOV  CL,AL
	MOV  AX,BX
	SAR  AX,CL
	PUSH AX
	CALL hexb
	ADD  SP,2
;	hexb(x); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL hexb
	ADD  SP,2
;} 
	RET
; 
;hexb(x) int x; 
hexb:
;{ 
;	hexn(x>>4); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,4
	POP  BX
	MOV  CL,AL
	MOV  AX,BX
	SAR  AX,CL
	PUSH AX
	CALL hexn
	ADD  SP,2
;	hexn(x); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL hexn
	ADD  SP,2
;} 
	RET
; 
;hexn(x) int x; 
hexn:
;{ 
;	x=x&15; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,15
	POP  BX
	AND  AX,BX
	POP  BX
	MOV  [BX],AX
;	if(x < 10) putchar(x+'0'); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,10
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc502
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,48
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL putchar
	ADD  SP,2
;	else putchar(x-10+'A'); 
	JMP  cc503
cc502:
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,10
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	PUSH AX
	MOV  AX,65
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL putchar
	ADD  SP,2
cc503:
;} /** EO outhexw **/ 
	RET
; 
;/***------------------------------------------***/ 
; 
;outhexb(number) int number; 
outhexb:
;{ 
;	leaderx(); 
	CALL leaderx
;	hexb(number & 255); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,255
	POP  BX
	AND  AX,BX
	PUSH AX
	CALL hexb
	ADD  SP,2
;} /** EO outhexb **/ 
	RET
; 
;/***------------------------------------------***/ 
; 
;leaderx() 
leaderx:
;{ 
;/**	ot("0x"); **/ 
;	putchar('0'); 
	MOV  AX,48
	PUSH AX
	CALL putchar
	ADD  SP,2
;	putchar('x'); 
	MOV  AX,120
	PUSH AX
	CALL putchar
	ADD  SP,2
;}  /** EO leaderx() **/ 
	RET
; 
;/***------------------------------------------***/ 
; 
; 
;/***------------------------------------------***/ 
;/* Print any assembler stuff needed after all code */ 
;trailer() 
trailer:
;{	comment(); 
	CALL comment
;	ol("-= END =-"); 
	MOV  AX,cc1+1268
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/***------------------------------------------***/ 
;/* Fetch a static memory cell into the primary register */ 
;/** Primary 8080.HL 8086.AX, Static Cell is DSEG **/ 
;/** If byte, then affirm it is sign extended to wordsz **/ 
;getmem(sym) 
getmem:
;	char *sym; 
;{	if((sym[ident]!=pointer)&(sym[type]==cchar)) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,1
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc504
;		{ot("MOV  AL,["); 
	MOV  AX,cc1+1278
	PUSH AX
	CALL ot
	ADD  SP,2
;		outstr(sym+name); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL outstr
	ADD  SP,2
;		ot("]"); 
	MOV  AX,cc1+1288
	PUSH AX
	CALL ot
	ADD  SP,2
;		nl(); 
	CALL nl
;	/** sign extension **/ 
;		ol("CBW"); 
	MOV  AX,cc1+1290
	PUSH AX
	CALL ol
	ADD  SP,2
;		} 
;	else 
	JMP  cc505
cc504:
;		{ot("MOV  AX,["); 
	MOV  AX,cc1+1294
	PUSH AX
	CALL ot
	ADD  SP,2
;		outstr(sym+name); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL outstr
	ADD  SP,2
;		ot("]"); 
	MOV  AX,cc1+1304
	PUSH AX
	CALL ot
	ADD  SP,2
;		nl(); 
	CALL nl
;		} 
cc505:
;	} 
	RET
; 
;/* Fetch the address of the specified symbol */ 
;/** the Stack Address of the passed Parameter, **/ 
;/** place that reference into the Primary Cell **/ 
;getloc(sym) 
getloc:
;	char *sym; 
;{	immed(); 
	CALL immed
;	outdec(((sym[offset]&255)+ 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,14
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,255
	POP  BX
	AND  AX,BX
	PUSH AX
;		((sym[offset+1]&255)<<8))- 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,14
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,255
	POP  BX
	AND  AX,BX
	PUSH AX
	MOV  AX,8
	POP  BX
	MOV  CL,AL
	MOV  AX,BX
	SAL  AX,CL
	POP  BX
	ADD  AX,BX
	PUSH AX
;		c_sp); 
	MOV  AX,[c_sp	]
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	PUSH AX
	CALL outdec
	ADD  SP,2
;	nl(); 
	CALL nl
;	ol("ADD  AX,SP"); 
	MOV  AX,cc1+1306
	PUSH AX
	CALL ol
	ADD  SP,2
;	} 
	RET
; 
;/* Store the primary register into the specified */ 
;/*	static memory cell */ 
;putmem(sym) 
putmem:
;	char *sym; 
;{	if((sym[ident]!=pointer)&(sym[type]==cchar)) 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,11
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,3
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,12
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,1
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc506
;		{ot("MOV  ["); 
	MOV  AX,cc1+1317
	PUSH AX
	CALL ot
	ADD  SP,2
;		outstr(sym+name); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL outstr
	ADD  SP,2
;		ot("],AL");nl(); 
	MOV  AX,cc1+1324
	PUSH AX
	CALL ot
	ADD  SP,2
	CALL nl
;		} 
;	else  
	JMP  cc507
cc506:
;		{ot("MOV  ["); 
	MOV  AX,cc1+1329
	PUSH AX
	CALL ot
	ADD  SP,2
;		outstr(sym+name); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL outstr
	ADD  SP,2
;		ot("],AX"); 
	MOV  AX,cc1+1336
	PUSH AX
	CALL ot
	ADD  SP,2
;		nl(); 
	CALL nl
;		} 
cc507:
;	} 
	RET
; 
;/* Store the specified object type in the primary register */ 
;/*	at the address on the top of the stack */ 
;putstk(typeobj) 
putstk:
;	char typeobj; 
;/**{pop();if(typeobj==cchar)call("ccpchar");else call("ccpint");}**/ 
;{	mnem_pop();	/** BX <- Addr.TOS **/ 
	CALL mnem_pop
;			/** Effective Address must be in BX **/ 
;	if(typeobj==cchar) ol("MOV  [BX],AL"); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,1
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc508
	MOV  AX,cc1+1341
	PUSH AX
	CALL ol
	ADD  SP,2
;		else ol("MOV  [BX],AX"); 
	JMP  cc509
cc508:
	MOV  AX,cc1+1354
	PUSH AX
	CALL ol
	ADD  SP,2
cc509:
;} 
	RET
; 
;/* Fetch the specified object type indirect through the */ 
;/*	primary register into the primary register */ 
;indirect(typeobj) 
indirect:
;	char typeobj; 
;/**{if (typeobj==cchar)call("ccgchar");else call("ccgint");}**/ 
;{	if (typeobj==cchar)  
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,1
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc510
;		{ol("MOV  BX,AX"); 
	MOV  AX,cc1+1367
	PUSH AX
	CALL ol
	ADD  SP,2
;		ol("MOV  AL,[Byte BX]"); 
	MOV  AX,cc1+1378
	PUSH AX
	CALL ol
	ADD  SP,2
;		ol("CBW"); 
	MOV  AX,cc1+1396
	PUSH AX
	CALL ol
	ADD  SP,2
;		} 
;		else {  ol("MOV  BX,AX"); 
	JMP  cc511
cc510:
	MOV  AX,cc1+1400
	PUSH AX
	CALL ol
	ADD  SP,2
;			ol("MOV  AX,[BX]"); 
	MOV  AX,cc1+1411
	PUSH AX
	CALL ol
	ADD  SP,2
;			} 
cc511:
;} 
	RET
; 
;/* Swap the primary and secondary registers */ 
;swap() 
swap:
;{	ol("XCHG AX,BX"); 
	MOV  AX,cc1+1424
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Print partial instruction to get an immediate value */ 
;/*	into the primary register */ 
;immed() 
immed:
;{	ot("MOV  AX,"); 
	MOV  AX,cc1+1435
	PUSH AX
	CALL ot
	ADD  SP,2
;} 
	RET
; 
;/* Push the primary register onto the stack */ 
;/** 24 callers **/ 
;mnem_push() 
mnem_pus:
;{	ol("PUSH AX"); 
	MOV  AX,cc1+1444
	PUSH AX
	CALL ol
	ADD  SP,2
;	c_sp=c_sp-2; 
	MOV  AX,[c_sp	]
	PUSH AX
	MOV  AX,2
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	MOV  [c_sp	],AX
;} 
	RET
; 
;/** Push Zero onto the stack		**/ 
;/** 10:30 AM 8/5/2007			**/ 
;/** unlinked from callfunction() 11:54 AM 8/5/2007 **/ 
;m_push_zr() 
m_push_z:
;{	ol("PUSH 0"); 
	MOV  AX,cc1+1452
	PUSH AX
	CALL ol
	ADD  SP,2
;	c_sp=c_sp-2; 
	MOV  AX,[c_sp	]
	PUSH AX
	MOV  AX,2
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	MOV  [c_sp	],AX
;} 
	RET
; 
;/* Pop the top of the stack into the secondary register */ 
;/** 17 callers **/ 
;mnem_pop() 
mnem_pop:
;{	ol("POP  BX"); 
	MOV  AX,cc1+1459
	PUSH AX
	CALL ol
	ADD  SP,2
;	c_sp=c_sp+2; 
	MOV  AX,[c_sp	]
	PUSH AX
	MOV  AX,2
	POP  BX
	ADD  AX,BX
	MOV  [c_sp	],AX
;} 
	RET
; 
;/* Swap the primary register and the top of the stack */ 
;swapstk() 
swapstk:
;{	ol("XCHG [SP],AX"); 
	MOV  AX,cc1+1467
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Call the specified subroutine name */ 
;/** 1 caller **/ 
;mnem_call(sname) 
mnem_cal:
;	char *sname; 
;{	ot("CALL "); 
	MOV  AX,cc1+1480
	PUSH AX
	CALL ot
	ADD  SP,2
;	outstr(sname); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL outstr
	ADD  SP,2
;	nl(); 
	CALL nl
;} 
	RET
; 
;/* Return from subroutine */ 
;/** 2 callers **/ 
;mnem_ret() 
mnem_ret:
;{	ol("RET"); 
	MOV  AX,cc1+1486
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Perform subroutine call to value on top of stack */ 
;/** one caller **/ 
;mnemcallstk() 
mnemcall:
;{	immed(); 
	CALL immed
;	outstr("$+5"); 
	MOV  AX,cc1+1490
	PUSH AX
	CALL outstr
	ADD  SP,2
;	nl(); 
	CALL nl
;	swapstk(); 
	CALL swapstk
;	ol("CALL [AX]"); 
	MOV  AX,cc1+1494
	PUSH AX
	CALL ol
	ADD  SP,2
;	c_sp=c_sp+2; 
	MOV  AX,[c_sp	]
	PUSH AX
	MOV  AX,2
	POP  BX
	ADD  AX,BX
	MOV  [c_sp	],AX
;	} 
	RET
; 
;/* Jump to specified internal label number */ 
;/** 4 Callers **/ 
;mnem_jump(label) 
mnem_jum:
;	int label; 
;{	ot("JMP  "); 
	MOV  AX,cc1+1504
	PUSH AX
	CALL ot
	ADD  SP,2
;	printlabel(label); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL printlab
	ADD  SP,2
;	nl(); 
	CALL nl
;	} 
	RET
; 
;/* Test the primary register and jump if false to label */ 
;/** Primary holds Bool on entry 1=TRUE, 0=FALSE the jump **/ 
;/** often is not short, so change this... **/ 
;/** testjump(label)int label;{ol("MOV  CX,AX"); **/ 
;/** ot("JCXZ ");printlabel(label);nl();} **/ 
; 
;testjump(label) 
testjump:
;	int label; 
;{	ol("CMP  AX,0"); /** ZF if equal **/ 
	MOV  AX,cc1+1510
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JNE  $+5"); /** next is past, jmp label **/ 
	MOV  AX,cc1+1520
	PUSH AX
	CALL ol
	ADD  SP,2
;	ot("JMP  "); 
	MOV  AX,cc1+1529
	PUSH AX
	CALL ot
	ADD  SP,2
;	printlabel(label); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL printlab
	ADD  SP,2
;	nl(); 
	CALL nl
;} 
	RET
; 
;/** .dseg section **/ 
;do_dseg() 
do_dseg:
;{ 
;  ot(";-; SECTION .dseg align=16 ;; commented out for .com version"); 
	MOV  AX,cc1+1535
	PUSH AX
	CALL ot
	ADD  SP,2
;} 
	RET
; 
; 
;/* Print pseduo-op to define a byte */ 
;defbyte() 
defbyte:
;{	ot("DB "); 
	MOV  AX,cc1+1596
	PUSH AX
	CALL ot
	ADD  SP,2
;} 
	RET
; 
;/* Print psedo-op to define storage */ 
;/** Called by CC1 dumpglbs(), both will need modifications **/ 
;/**   form: times nn d_sz val **/ 
;defstorage() 
defstora:
;{	ot("TIMES "); /**ot("DS ");**/ 
	MOV  AX,cc1+1600
	PUSH AX
	CALL ot
	ADD  SP,2
;} 
	RET
; 
;/* Print pseudo-op to define a word */ 
;defword() 
defword:
;{	ot("DW "); 
	MOV  AX,cc1+1607
	PUSH AX
	CALL ot
	ADD  SP,2
;} 
	RET
; 
;/* Modify the stack pointer to the new value indicated */ 
;/** 9 callers, pertains to local stack index **/ 
;mnem_modstk(newsp) 
mnem_mod:
;	int newsp; 
;{	int k; 
	PUSH AX
;	k=newsp-c_sp; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,[c_sp	]
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	POP  BX
	MOV  [BX],AX
;	if(k==0)return newsp; 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc512
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,2
	RET
;	if(k>+0) 
cc512:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JG   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc513
;		{ 
;		ot("ADD  SP,"); 
	MOV  AX,cc1+1611
	PUSH AX
	CALL ot
	ADD  SP,2
;		outdec(k); 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL outdec
	ADD  SP,2
;		nl(); 
	CALL nl
;		return newsp; 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,2
	RET
;		} 
;	if(k < 0) 
cc513:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JL   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc514
;		{if(k>-7) 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,7
	NEG  AX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JG   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc515
;			{if(k&1) 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc516
;				{ol("DEC  SP"); 
	MOV  AX,cc1+1620
	PUSH AX
	CALL ol
	ADD  SP,2
;				k++; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
;				} 
;			while(k) 
cc516:
cc517:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc518
;				{ol("PUSH AX"); 
	MOV  AX,cc1+1628
	PUSH AX
	CALL ol
	ADD  SP,2
;				k=k+2; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;				} 
	JMP  cc517
cc518:
;			return newsp; 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,2
	RET
;			} 
;		} 
cc515:
; 
;/* 2 Modify the stack pointer to the new value indicated */ 
;/** 9 callers, pertains to local stack index **/ 
;/* mnem_modstk(newsp)int newsp;{int k;k=newsp-c_sp; **/ 
;/* if(k==0)return newsp;if(k>+0){if(k<7){if(k&1)**/ 
;/** handle odd alignment **/ 
;/* {ol("INC  SP");k--;}while(k)**/ 
;/** throw away **/ 
;/** without overwriting primary */ 
;/* {ol("POP  DX");k=k-2;}return newsp;}} **/ 
;/* if(k<0){if(k>-7){if(k&1){ol("DEC  SP");k++;}while(k){ol("PUSH AX"); **/ 
;/* k=k+2;}return newsp;}} **/ 
; 
;/* Modify the stack pointer to the new value indicated */ 
;/* modstk(newsp)int newsp;{int k;k=newsp-Zsp; **/ 
;/* if(k==0)return newsp;ot("ADD SP,");outdec(k); **/ 
;/* nl();return newsp;} **/ 
; 
;/** Have a closer look at the following for improvement **/ 
;	swap(); 
cc514:
	CALL swap
;	immed();outdec(k);nl(); 
	CALL immed
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL outdec
	ADD  SP,2
	CALL nl
;	ol("ADD  AX,SP"); 
	MOV  AX,cc1+1636
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  SP,AX"); 
	MOV  AX,cc1+1647
	PUSH AX
	CALL ol
	ADD  SP,2
;	swap(); 
	CALL swap
;	return newsp; 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,2
	RET
;} 
; 
;/* Double the primary register */ 
;doublereg() 
doublere:
;{	ol("ADD  AX,AX"); 
	MOV  AX,cc1+1658
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Add the primary and secondary registers */ 
;/*	(results in primary) */ 
;m_add() 
m_add:
;{	ol("ADD  AX,BX"); 
	MOV  AX,cc1+1669
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Substract the primary register from the secondary */ 
;/*	(results in the primary) */ 
;/** sub() {call("ccsub");} **/ 
;m_sub() 
m_sub:
;{	ol("SUB  BX,AX"); /** BX-AX -> BX **/ 
	MOV  AX,cc1+1680
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,BX"); 
	MOV  AX,cc1+1691
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Multiply the primary and secondary registers */ 
;/*	(results in primary) */ 
;/** mult() {call("ccmult");} **/ 
;/** Unsigned Mult re:AX*BX -> DX:AX **/ 
;m_mult() 
m_mult:
;{	 
;	ol("MUL  BX"); 
	MOV  AX,cc1+1702
	PUSH AX
	CALL ol
	ADD  SP,2
;	 
;} 
	RET
; 
;/* Divide the secondary by the primary */ 
;/* (quotient in primary, remainder in secondary) */ 
;/*** 21-Jul-08 07:41:16 PM add signed integer divide ***/ 
;/**** 24-Jul-08 02:51:10 PM force DX := 0, prevent exception ****/ 
;/** div() {call("ccdiv");} **/ 
;/** swap Primary&Secondary **/ 
;/** Unsigned Div re:DX.0:AX/BX -> AX.quot DX.rem **/ 
;/** mov remainder into Secondary		**/ 
;m_div() 
m_div:
;{	ol("XCHG AX,BX"); 
	MOV  AX,cc1+1710
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  DX,0");	/** clear extended reg DX **/ 
	MOV  AX,cc1+1721
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("DIV  BX");	/** DX has remainder **/ 
	MOV  AX,cc1+1731
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  BX,DX"); 
	MOV  AX,cc1+1739
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;m_sdiv() 
m_sdiv:
;{	ol("XCHG AX,BX"); 
	MOV  AX,cc1+1750
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("CWD");		/** sign extend into DX **/ 
	MOV  AX,cc1+1761
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("IDIV BX");	/** DX has remainder **/ 
	MOV  AX,cc1+1765
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  BX,DX"); 
	MOV  AX,cc1+1773
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Compute remainder (mod) of secondary register divided */ 
;/*	by the primary */ 
;/*	(remainder in primary, quotient in secondary) */ 
;mod() 
mod:
;{	m_div(); 
	CALL m_div
;	swap(); 
	CALL swap
;	} 
	RET
; 
;/* Inclusive 'or' the primary and secondary registers */ 
;/*	(results in the primary) */ 
;/** or() {call("ccor");} **/ 
;m_or() 
m_or:
;{	ol("OR   AX,BX"); 
	MOV  AX,cc1+1784
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Exclusive 'or' the primary and secondary registers */ 
;/*	(results in the primary) */ 
;/** xor() {call("ccxor");} **/ 
;m_xor() 
m_xor:
;{	ol("XOR  AX,BX"); 
	MOV  AX,cc1+1795
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* 'And' the primary and secondary registers */ 
;/*	(results in primary) */ 
;/** and() {call("ccand");} **/ 
;m_and() 
m_and:
;{	ol("AND  AX,BX"); 
	MOV  AX,cc1+1806
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Arithmetic shift right the secondary register number of */ 
;/*	times in the primary (results in primary) */ 
;/** asr() {call("ccasr");} **/ 
;asr() 
asr:
;{	ol("MOV  CL,AL"); /** BH is disregarded **/ 
	MOV  AX,cc1+1817
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,BX"); 
	MOV  AX,cc1+1828
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("SAR  AX,CL"); 
	MOV  AX,cc1+1839
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Arithmetic left shift the secondary register number of */ 
;/*	times in the primary (results in primary) */ 
;/** asl() {call("ccasl");} **/ 
;asl() 
asl:
;{	ol("MOV  CL,AL"); /** BH is disregarded **/ 
	MOV  AX,cc1+1850
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,BX"); 
	MOV  AX,cc1+1861
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("SAL  AX,CL"); 
	MOV  AX,cc1+1872
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Form two's complement of primary register */ 
;/** neg() {call("ccneg");} **/ 
;m_neg() 
m_neg:
;{	ol("NEG  AX"); 
	MOV  AX,cc1+1883
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Form one's complement of primary register */ 
;/** com() {call("cccom");} **/ 
;com() 
com:
;{	ol("NOT  AX"); 
	MOV  AX,cc1+1891
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Increment the primary register by one */ 
;/** inc() {ol("INX H");} **/ 
;m_inc() 
m_inc:
;{	ol("INC  AX"); 
	MOV  AX,cc1+1899
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Decrement the primary register by one */ 
;/** dec() {ol("DCX H");} **/ 
;m_dec() 
m_dec:
;{	ol("DEC  AX"); 
	MOV  AX,cc1+1907
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Following are the conditional operators */ 
;/* They compare the secondary register against the primary */ 
;/* and put a literal 1 in the primary if the condition is */ 
;/* true, otherwise they clear the primary register */ 
;/** Here for NASM, I've inlined these fns instead of	**/ 
;/**  leaving them for an include *.* 			**/ 
; 
;/* Test for equal */ 
;eq()	/** {call("cceq");} **/ 
eq:
;{	ol("CMP  BX,AX");  /** sets flags **/ 
	MOV  AX,cc1+1915
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,1");   /** assume true **/ 
	MOV  AX,cc1+1926
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JZ   $+5"); 
	MOV  AX,cc1+1936
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,0");   /** is false **/ 
	MOV  AX,cc1+1945
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Test for not equal */ 
;ne()	/** {call("ccne");} **/ 
ne:
;{	ol("CMP  BX,AX");  /** sets flags **/ 
	MOV  AX,cc1+1955
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,1");   /** assume true **/ 
	MOV  AX,cc1+1966
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JNZ  $+5"); 
	MOV  AX,cc1+1976
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,0");   /** is false **/ 
	MOV  AX,cc1+1985
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Test for less than (signed) */ 
;lt()	/** {call("cclt");} **/ 
lt:
;{	ol("CMP  BX,AX");  /** sets flags **/ 
	MOV  AX,cc1+1995
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,1");   /** assume true **/ 
	MOV  AX,cc1+2006
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JL   $+5"); 
	MOV  AX,cc1+2016
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,0");   /** is false **/ 
	MOV  AX,cc1+2025
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Test for less than or equal to (signed) */ 
;le()	/** {call("ccle");} **/ 
le:
;{	ol("CMP  BX,AX");  /** sets flags **/ 
	MOV  AX,cc1+2035
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,1");   /** assume true **/ 
	MOV  AX,cc1+2046
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JLE  $+5"); 
	MOV  AX,cc1+2056
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,0");   /** is false **/ 
	MOV  AX,cc1+2065
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Test for greater than (signed) */ 
;gt()	/** {call("ccgt");} **/ 
gt:
;{	ol("CMP  BX,AX");  /** sets flags **/ 
	MOV  AX,cc1+2075
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,1");   /** assume true **/ 
	MOV  AX,cc1+2086
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JG   $+5"); 
	MOV  AX,cc1+2096
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,0");   /** is false **/ 
	MOV  AX,cc1+2105
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Test for greater than or equal to (signed) */ 
;ge()	/** {call("ccge");} **/ 
ge:
;{	ol("CMP  BX,AX");  /** sets flags **/ 
	MOV  AX,cc1+2115
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,1");   /** assume true **/ 
	MOV  AX,cc1+2126
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JGE  $+5"); 
	MOV  AX,cc1+2136
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,0");   /** is false **/ 
	MOV  AX,cc1+2145
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Test for less than (unsigned) */ 
;ult()	/** {call("ccult");} **/ 
ult:
;{	ol("CMP  BX,AX");  /** sets flags **/ 
	MOV  AX,cc1+2155
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,1");   /** assume true **/ 
	MOV  AX,cc1+2166
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JB   $+5"); 
	MOV  AX,cc1+2176
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,0");   /** is false **/ 
	MOV  AX,cc1+2185
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Test for less than or equal to (unsigned) */ 
;ule()	/** {call("ccule");} **/ 
ule:
;{	ol("CMP  BX,AX");  /** sets flags **/ 
	MOV  AX,cc1+2195
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,1");   /** assume true **/ 
	MOV  AX,cc1+2206
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JBE  $+5"); 
	MOV  AX,cc1+2216
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,0");   /** is false **/ 
	MOV  AX,cc1+2225
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Test for greater than (unsigned) */ 
;ugt()	/** {call("ccugt");} **/ 
ugt:
;{	ol("CMP  BX,AX");  /** sets flags **/ 
	MOV  AX,cc1+2235
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,1");   /** assume true **/ 
	MOV  AX,cc1+2246
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JA   $+5"); 
	MOV  AX,cc1+2256
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,0");   /** is false **/ 
	MOV  AX,cc1+2265
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
; 
;/* Test for greater than or equal to (unsigned) */ 
;uge()	/** {call("ccuge");} **/ 
uge:
;{	ol("CMP  BX,AX");  /** sets flags **/ 
	MOV  AX,cc1+2275
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,1");   /** assume true **/ 
	MOV  AX,cc1+2286
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("JAE  $+5"); 
	MOV  AX,cc1+2296
	PUSH AX
	CALL ol
	ADD  SP,2
;	ol("MOV  AX,0");   /** is false **/ 
	MOV  AX,cc1+2305
	PUSH AX
	CALL ol
	ADD  SP,2
;} 
	RET
;/***------------------------------------------***/ 
;/**-------------------------------------**/ 
;/** extern functions needed by small-c: **/ 
;/** fopen()				**/ 
;/** fclose()				**/ 
;/** putchar()				**/ 
;/** getc()				**/ 
;/** putc()				**/ 
;/** gets()				**/ 
;/**	Example..			**/ 
;/** CALL gets | gets(line);		**/ 
;/** CALL fopen | fopen(line,"w")	**/ 
;/** CALL fclose | fclose(output);	**/ 
;/*	<<<<< End of Compiler >>>>>	 */ 
;/* #include IOC5.C * when self compiling */ 
;/* Otherwise, the PowerC pcdos io lib is */ 
;/* used: stdio.h			**/ 
;/** SCNXa.C is PowerC Level 1 Compile	**/ 
;/** SCNX.C is IOC5.C Level 2 Self-Compile*/ 
;/** #include IOC5.C ** for self-compile **/ 
;/** Name changed to...			**/ 
;#include C5LIB.C /** for self-compile	**/ 
;/*********************************************************/ 
;/** Module: C5LIB.C  By: s_dubrovich@yahoo.com		**/ 
;/** Last: 8:00 AM 8/16/2008				**/ 
;/** Vers: 0.2.4						**/ 
;/**  modified puts();					**/ 
;/*********************************************************/ 
;/** Module: C5LIB.C  By: s_dubrovich@yahoo.com		**/ 
;/** Last:  10:29 PM 8/14/2008				**/ 
;/** Vers: 0.2.2						**/ 
;/**  Chg to C5LIB.C for further development.  Added in	**/ 
;/**  mainmain() for initialization of user source.	**/ 
;/**  file Was IOC5.C					**/ 
;/**  Added puts();					**/ 
;/*********************************************************/ 
;/** IOC5.C -- stripped main for small-c include		**/ 
;/** Call 5 IO Interface Library				**/ 
;/*********************************************************/ 
;/** Last: 30-Jul-08 05:08:51 PM.			**/ 
;/** Prev: 08:15:42 AM 17-Jul-08				**/ 
;/** Vers: 0.1.7	modified re_ubuff()			**/ 
;/** chg index update for ol(ptr)			**/ 
;/*********************************************************/ 
;/** Last: 07:32:44 AM 15-Jul-08				**/ 
;/** Vers: 0.1.5 -filter 0Dh -> 20h for eol problem    ****/ 
;/**  chgd getc() to filter & 127, or, ret EOF         ****/ 
;/*********************************************************/ 
;/** Last: 05:23:25 AM 07/13/2008 01:31:05 PM 07/12/2008	**/ 
;/** Init: 11:18 PM 7/5/2008				**/ 
;/*********************************************************/ 
;/** CALL5_IO.C test file & IO Functions for small-c	**/ 
;/** Last: 11:44 AM 7/5/2008 :: 11:28 AM 7/4/2008	**/ 
;/** Init: 7:24 AM 5/31/2008				**/ 
;/** Vers: 0.1.0  By: s_dubrovich@yahoo.com		**/ 
;/** Goal: minimal IO to Call_5 interface to run small-c **/ 
;/** Note: Only Character, not binary Files.		**/ 
;/** -Cloned From SINKIO01.C as IO LIB base Fn's		**/ 
;/** -includes some testing code as main()		**/ 
;/*********************************************************/ 
;/** NOTE: for cmd.exe edit NASM src for vstart=0100h,   **/ 
;/** and comment out ';;' the two SECTION .dseg align=16 **/ 
;/** directives so that the pcdos 'small' model is used. **/ 
;/*********************************************************/ 
;/** Req'd IO Functions for Small-c			**/ 
;/**getc(){;} gets(){;} putc(){;}  			**/ 
;/**putchar(){;} fopen(){;} fclose(){;}			**/ 
; 
;/* 
;** STDIO.H -- Standard Small-C Definitions --  
;*/ 
;#define stdin    0 
;#define stdout   1 
;#define stderr   2 
;#define ERR   (-2) 
;#define EOF   (-1) 
;#define YES      1 
;#define NO       0 
;/** #define NULL     0 **/ 
;#define BAD	(-1) 
;#define CR      13 
;#define LF      10 
;#define BELL     7 
;#define SPACE  ' ' 
;#define NEWLINE LF 
; 
;#define EOL 10   /** LF **/ 
;#define NL  10 
;#define TAB  9 
;#define EOL2    13 /*;end-of-line character          */ 
;                   /*  (=carriage return,CR)         */ 
;#define CTRLZ	26 /** 1Ah, Ctrl-Z, cpm textfile EOF */ 
;/**-----------------------------------------------------**/ 
;#define MAX_IOD   6 /** Max Streams, incl stdin,out,err **/ 
;#define FILE  char /** Cain's C doesn't know struc FILE **/ 
;#define VERBOSE   1 /** debugging, report runtime state **/ 
;/**-----------------------------------------------------**/ 
;/** #define PCDOS 1 * IBM PC DOS, Same as CP/M-80   */ 
;/** #if PCDOS		*****************************/ 
;#define EXIT	   0	/* Exit to BDOS		    */ 
;#define CONIN	   1	/* direct echoing con input */ 
;#define CONOUT	   2	/* Direct console output    */ 
;#define LSTOUT	   5	/* Direct list device output*/ 
;#define CONIO	   6	/* Direct console I/O	    */ 
;#define C_WRITESTR 9	/* Console string output    */ 
;#define CONBUF	   10	/* Read console buffer	    */ 
;#define C_STAT	   11	/* Get console status	    */ 
;#define OPEN	   15	/* OPEN a disk file	    */ 
;#define CLOSE	   16	/* Close a disk file	    */ 
;#define SEARCHF	   17	/* Search for first	    */ 
;#define SEARCHN	   18	/* Search for next	    */ 
;#define DELETE	   19	/* Delete a disk file	    */ 
;#define SEQREAD    20	/* seq read		    */ 
;#define SEQWRITE   21	/* seq write		    */ 
;#define CREATE	   22	/* Create a disk file	    */ 
;#define F_RENAME   23	/* Rename a disk file	    */ 
;#define SETDMA	   26	/* Set DMA address	    */ 
;#define B_READ	   33	/* Read Random record	    */ 
;#define B_WRITE	   34	/* Write Random record	    */ 
;#define FILSIZ	   35	/* Compute File Size	    */ 
;/** #endif		*****************************/ 
; 
;/***	File State  bit definitions                       ***/ 
;#define STATE_FR 0	/* Available State, FREE CCB        */ 
;#define STATE_FO 1	/* else File Opened                 */ 
;#define STATE_DT 2	/* at least 1 rec put to file, ndx0 */ 
;#define STATE_PW 4	/* Pending Write, Flush before close*/ 
;#define STATE_EF 8	/* EOF state on last read	    */ 
;#define STATE_ER BAD	/* Error State                      */ 
; 
;/***	File Mode, Character String                         */ 
;#define MODE_RD	'R'	/* Read mode parameter for open     */ 
;#define MODE_WR	'W'	/* Write mode                       */ 
;#define MODE_NU	'N'	/* Null Mode for reuse              */  
; 
;/*	CP/M FCB definition - similar to PC Dos	*/ 
;#define EOFCHR	26	/* End of file character-^Z, 0x1a   */ 
;				/****************************/ 
;#define SECSIZ		128	/* size of CP/M sectorrecord*/ 
;#define _MAXSXFR	1	/* max # sectors xferrable  */ 
;#define _MAXSHFT	12	/* shift right BDOS rtn val */ 
;				/*   to obtain nsecs on err */ 
;				/****************************/ 
;#define BYTE	char 
;#define INT	int 
;#define WORD	int 
; 
;/******************************************************************** 
; *	Channel Control Block (CCB), _iod, I/O Descriptor. 
; *									     
; * One CCB is allocated (statically) for each of the possible open   
; * files under C (including STDIN, STDOUT, STDERR).  Permanent data     
; * regarding the channel is kept here.				     
; *	-= note: initially. use 6 CCB's, adequate for small-c =- 
; ********************************************************************/ 
;  /** Define File Descriptor Indexes - _IOD **/ 
;#define DRV	0 
;#define FNAME	1 
;#define FTYP	9 
;#define FBLK	12 /* current 16k Block */ 
;#define LRS	14 /* Logical Record Size, 0080h */ 
;#define FSZ	16 /* FileSize in bytes */ 
;#define FDATE	20 /* Date */ 
;#define FTCHG	22 /* Time of Last Change */ 
;#define FDCHG	24 /* Date of Last Change */ 
;#define FCLUS	26 /* First Cluster Number for FAT Entry */ 
;#define FSIZE	28 /* File Size 28..31 */ 
;#define FCREC	32 /* Current Record in current 16k Block */ 
;#define FR0	33 /* lo byte of Random Rec Number */ 
;#define FR1	34 /* mid byte of Random Rec Number */ 
;#define FR2	35 /* hi byte of Random Rec Number */ 
;#define FR3	36 /* Overflo byte under certain circumstances */ 
;  /** -= File Operational Elements of Struct =- **/ 
;#define IOTYP   37 /* TYPES: 'S'torage(file), 'M'emory(file) **/ 
;#define FMODE	38 /* File Mode Indication Bytes [3] ex.'wb+' **/ 
;#define FSTATE	41 /* Current Operational State Byte **/ 
;#define FBUFNDX 42 /* Buffer index DW to next free position, 0..127 **/ 
;#define FBUFFER	44 /* File Transfer Buffer **/  
;#define LENFDD	172 /* Next Position after FCB Structure, */ 
;		/** Length of File Descriptor Area **/ 
;#define LEN_Y	171 /** LENFDD - 1, for addressing f_units **/ 
;/**-------------------------------------------------------------*/ 
;/*** -= DECLARATIONS =- ***/ 
;/**-------------------------------------------------------------*/ 
; 
;/** FCB STUCTURES ARRAY AREA ***** CCB's	**/ 
;/** First three are STDIN, STDOUT, STDERR	**/ 
; 
;	int  *_iod[MAX_IOD]; /** holds addrs of f_units at runtime **/ 
; 
;  /** File Descriptor Area **/ 
;	char f_unit0;	/** Location is DRV in struct **/ 
;	char fdd_01[LEN_Y];  /** one less than LENFDD **/ 
; 
;	char f_unit1; 
;	char fdd_02[LEN_Y]; 
; 
;	char f_unit2; 
;	char fdd_03[LEN_Y]; 
; 
;	char f_unit3; 
;	char fdd_04[LEN_Y]; 
; 
;	char f_unit4; 
;	char fdd_05[LEN_Y]; 
; 
;	char f_unit5; 
;	char fdd_06[LEN_Y]; 
; 
; 
;	char fdta[128]; /** default fp buff **/ 
;  /** TBUFF Area for CONIO *********************/ 
;	char tbuff[257]; 
;	char ubuff[257]; 
;	char cp[]; 
; 
;/*       1         2         3         4         5   */ 
;/*****************************************************/ 
;/* Module: OSFN.C				     */ 
;/* Last:  12:10 PM 4/12/2008                         */ 
;/* Init:  9:28 PM 12/28/2007                         */ 
;/* By:  s_dubrovich@yahoo.com                        */ 
;/* Goal: test module for small-c & nasm              */ 
;/* testb.c -  to demo "SMALLC-NASM"                  */ 
;/* -f bin -l testb.lst -o testb.com testb.nsm        */ 
;/* #asm                                              */ 
;/* ;-;	org 0100h ;; for .com locate main()	     */ 
;/* ;-; Doesn't work, for pcDos, edit SECTION .text   */ 
;/* ;-;  to vstart=0100h                              */ 
;/* #endasm                                           */ 
; 
;/***-----------------------------------------------***/ 
;/***                   M A I N                     ***/ 
;/***-----------------------------------------------***/ 
;/*** Main Block, testing File I/O Functions.  Also, **/ 
;/** provides startup initialization for FCB's for   **/ 
;/** User codes' main() -this depends on including   **/ 
;/**  #include C5LIB.C ** first in users's source    **/ 
;/**  in order for mainmain() to execute first. If   **/ 
;/**  included elsewhere in user's source then this  **/ 
;/**  mainmain() doesn't execute, but the lib fn's   **/ 
;/**  are still available and the user must explicit- */ 
;/*   ly call initfcb() first before file operations. */ 
; 
;mainmain() 
mainmain:
;{ 
;	initfcb(); /** in this file **/ 
	CALL initfcb
;	main();    /** call users main **/ 
	CALL main
;	exit();	/** user's main returns, handle exit */ 
	CALL exit
;} 
	RET
;/** eo main **/ 
; 
;/***-----------------------------------------------***/ 
;/***             S U B R O U T I N E S             ***/ 
;/***-----------------------------------------------***/ 
; 
;/*** codify EOL sequence...			   ***/ 
;NLfn() 
NLfn:
;{ 
;	putchar(CR); putchar(LF); 
	MOV  AX,13
	PUSH AX
	CALL putchar
	ADD  SP,2
	MOV  AX,10
	PUSH AX
	CALL putchar
	ADD  SP,2
;} 
	RET
; 
;/* Test if given character is alpha - internal FN !? */ 
;/****---- alpha(c) 
;	char c; 
;{	c=c&127; 
;	return(((c>='a')&(c<='z'))| 
;		((c>='A')&(c<='Z'))| 
;		(c=='_')); 
;} ----****/ 
; 
; 
;/***-----------------------------------------------***/ 
;/** Test for Printable Character, EOF		---***/ 
;/**  ret bool := 1 if not a printable char, else 0 ***/ 
;/**  ret`0 .if. e|{' '..'~'} .else. 1		   ***/ 
; 
;isnprint(c) char c; 
isnprint:
;{ 
;	if ((c>=' ')&(c<='~')) return 0; 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,32
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,126
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JLE  $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc519
	MOV  AX,0
	RET
;	else return 1; 
	JMP  cc520
cc519:
	MOV  AX,1
	RET
cc520:
;} 
	RET
; 
;/***-----------------------------------------------***/ 
;toupper(c) char c; 
toupper:
;{ 
;	if (c) /** not null **/ 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc521
;		{ 
;		if ((c>='a')&(c<='z')) return (c-32); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,97
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JGE  $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,122
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JLE  $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc522
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,32
	POP  BX
	SUB  BX,AX
	MOV  AX,BX
	RET
;		else return (c); 
	JMP  cc523
cc522:
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	RET
cc523:
;		} 
;	return (c); 
cc521:
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	RET
;} 
; 
;/***-----------------------------------------------***/ 
;/*** put a char array of len length to conout.	---***/ 
;putchara(str,len) char str[]; int len; 
putchara:
;{ 
;	int cnt, ix; 
	PUSH AX
	PUSH AX
;	cnt = len; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;	ix  = 0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;	while (len) 
cc524:
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc525
;		{ 
;		putchar(str[ix++]); 
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	CALL putchar
	ADD  SP,2
;		len--; 
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	DEC  AX
	POP  BX
	MOV  [BX],AX
	INC  AX
;		} 
	JMP  cc524
cc525:
;} 
	ADD  SP,4
	RET
; 
;/***-----------------------------------------------***/ 
;/*** to Upper Case conversion of string 'str$'     ***/ 
; 
;uc_str(pstr) char *pstr; 
uc_str:
;{ /** takes a ptr to a '$' terminated string **/ 
;	char chr, *ip; 
	DEC  SP
	PUSH AX
; 
;	while (*pstr != '$') 
cc526:
	MOV  AX,5
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,36
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc527
;		{ 
;		chr=toupper(*pstr++); 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	CALL toupper
	ADD  SP,2
	POP  BX
	MOV  [BX],AL
;		putchar(chr); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	CALL putchar
	ADD  SP,2
;		*ip++ = chr; /** ip++; **/ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;		} /** str conversion **/ 
	JMP  cc526
cc527:
;} 
	ADD  SP,3
	RET
; 
;/***-----------------------------------------------***/ 
;/*** to Upper Case conversion of string 'str\0'    ***/ 
; 
;uc_nstr(pstr) char *pstr; 
uc_nstr:
;{ /** takes a ptr to a null terminated string **/ 
;	char chr, *ip; 
	DEC  SP
	PUSH AX
; 
;	while (*pstr) 
cc528:
	MOV  AX,5
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc529
;		{ 
;		chr=toupper(*pstr++); 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	CALL toupper
	ADD  SP,2
	POP  BX
	MOV  [BX],AL
;		putchar(chr); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	CALL putchar
	ADD  SP,2
;		*ip++ = chr; /** ip++; **/ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;		} /** str conversion **/ 
	JMP  cc528
cc529:
;} 
	ADD  SP,3
	RET
; 
;/***-----------------------------------------------***/ 
;/*** NOTE- limited function, copy filespec 11 chars***/ 
; 
;copystr(str1, str2) char str1[], str2[];  
copystr:
;{ 
;	int i,cnt; 
	PUSH AX
	PUSH AX
;	cnt = 11; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	POP  BX
	MOV  [BX],AX
;	i   = 0; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;	while (cnt) 
cc530:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc531
;		{ 
;		str2[i] = str1[i]; 
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;		cnt--; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	DEC  AX
	POP  BX
	MOV  [BX],AX
	INC  AX
;		i++; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
;		} 
	JMP  cc530
cc531:
;} 
	ADD  SP,4
	RET
; 
;/***-----------------------------------------------***/ 
;copymem(blk1, blk2, ccnt) char blk1[], blk2[]; int ccnt;  
copymem:
;{ 
;	int i; 
	PUSH AX
;	i   = 0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;	while (ccnt) 
cc532:
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc533
;		{ 
;		blk2[i] = blk1[i]; 
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;		ccnt--; 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	DEC  AX
	POP  BX
	MOV  [BX],AX
	INC  AX
;		i++; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
;		} 
	JMP  cc532
cc533:
;} 
	ADD  SP,2
	RET
; 
;/***-----------------------------------------------***/ 
;/*** Div DW as DD`DX:AX -> AX`quot,DX`rem.  Word   ***/ 
;/** value is passed on the stack.                  ***/ 
;/** Use Division by Subtraction to avoid ovfl      ***/ 
;/*** Status: works ok, wordsz => 0..max`65535      ***/ 
; 
; 
;outdeci(number) int number; 
outdeci:
;{ 
;#asm 
;;outdeci(number)int number;{int k,zs;char c;zs = 0; 
;; k=10000;/**	if (number<0){number=(-number); 
;; outbyte('-');}***/while (k>=1){c=number/k + '0'; 
;; if ((c!='0')|(k==1)|(zs)){zs=1;putchar(c);} 
;; number=number%k;k=k/10;} } 
	mov  dx,0 
	pop  di		;; 0[ret]2[val] 
	pop  ax 
	push ax		;; caller cleans the stack 
	push di		;; restore return address. 
	pusha		;; save entry state... 
	mov  cx,0 
	mov  bx,10000 
	call Lnnd 
	mov  cx,0 
	mov  bx,1000 
	call Lnnd 
	mov  cx,0 
	mov  bx,100 
	call Lnnd 
	mov  cx,0 
	mov  bx,10 
	call Lnnd 
	mov  cx,0 
	mov  bx,1 
	call Lnnd 
  ;; Cleanup Stack, and return.. 
	popa 
	jmp  Cont 
Lnnd: 
	cmp  ax,bx 
	jb   .Lnxt1	;; less than 10k, else count. 
	sub  ax,bx 
	inc  cx 
	jmp  Lnnd 
.Lnxt1: 
	add  cx,30h ;; make ascii number 
	pusha 
	push cx 
	call putchar 
	pop  cx 
	popa 
	RET 
Cont: 
;} 
	RET
; 
;/***-----------------------------------------------***/ 
;/** ----------= S I M P L E   I / O =-------------- **/ 
;/***-----------------------------------------------***/ 
;/** define putchar() putc(c,stdout)                 **/ 
;/** -= Simple I/O =- **/ 
;putchar(c) 
putchar:
; char c; 
;{ 
;	OSfn_(CONOUT,c); 
	MOV  AX,2
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	CALL OSfn_
	ADD  SP,4
;/**	if(c==CR)		**/ 
;/**	OSfn_(CONOUT,LF);	**/ 
;/**	return(c & 255);	**/ 
;} 
	RET
; 
;/***-----------------------------------------------***/ 
;/** get buffered input from stdin, CONBUF #10       **/ 
;/** 1st byte of tbuff on call holds max_len,1..255  **/ 
;/** 2nd byte is set to string length inc terminator **/ 
;/** byte CR`0Dh.  Buffer must be preset before call **/ 
;/** Users returned string begins at third byte.     **/ 
; 
;/** Call 5 interface for internal use. **/ 
;c5gets(ubuff) char *ubuff;   
c5gets:
;{  /** use temp buffer with copy to userbuffer **/ 
;	char *ip,*pb,chr; 
	PUSH AX
	PUSH AX
	DEC  SP
; 
;	tbuff[0]=255;  /** use default max **/ 
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,255
	POP  BX
	MOV  [BX],AL
;	ip = &tbuff[1]; 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;	pb = &tbuff[2]; 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,2
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;	OSfn_(CONBUF,&tbuff[0]); /** Fn 10, DS:DX **/ 
	MOV  AX,10
	PUSH AX
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL OSfn_
	ADD  SP,4
;  /** copy string part to users buffer **/ 
;	while (*pb != 13) 
cc534:
	MOV  AX,1
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,13
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc535
;		{ 
;		chr = *pb++; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;		*ubuff++ = chr; 
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;		} 
	JMP  cc534
cc535:
;  /* chgs termination from CR to '$' */ 
;	*ubuff = '$'; 
	MOV  AX,7
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,36
	POP  BX
	MOV  [BX],AL
;	return (*ip); 
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	ADD  SP,5
	RET
;} 
; 
;/***-----------------------------------------------***/ 
;/**** Note: gets() for C functionality, append null ****/ 
;/**** Rets- caller's buffer ptr, or NULL if eof or err */ 
; 
;gets(ubuff) char *ubuff;  /** CONIN Fn **/ 
gets:
;{  /** use temp buffer with copy to userbuffer **/ 
;	char *ip,*pb, *tmpp, chr; 
	PUSH AX
	PUSH AX
	PUSH AX
	DEC  SP
; 
;	tmpp = ubuff;  /** local copy **/ 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;	tbuff[0]=255;  /** use default max inbuffsz **/ 
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,255
	POP  BX
	MOV  [BX],AL
;	ip = &tbuff[1]; /** fn10 sets to strlen entered **/ 
	MOV  AX,5
	ADD  AX,SP
	PUSH AX
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;	pb = &tbuff[2]; /** entered str start **/ 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,2
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;	OSfn_(CONBUF,&tbuff[0]); /** Fn 10, DS:DX struct **/ 
	MOV  AX,10
	PUSH AX
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL OSfn_
	ADD  SP,4
; 
;	if (0 == *ip) return (NULL); /** empty line **/ 
	MOV  AX,0
	PUSH AX
	MOV  AX,7
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc536
	MOV  AX,0
	ADD  SP,7
	RET
;  /** copy string part to users buffer **/ 
;	while (*pb != 13) /** input CR terminated **/ 
cc536:
cc537:
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,13
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc538
;		{ 
;		chr = *pb++; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,5
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;		*tmpp++ = chr; 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;		} 
	JMP  cc537
cc538:
;  /* chgs termination from CR to C's '0' */ 
;	*tmpp = 0; 
	MOV  AX,1
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AL
;	return (ubuff); 
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,7
	RET
;} 
; 
;/***-----------------------------------------------***/ 
;getch() 
getch:
;{ /* rets AH.01,AL.CharIn, echos to console   ***/ 
;	OSfn_(CONIN,0);  
	MOV  AX,1
	PUSH AX
	MOV  AX,0
	PUSH AX
	CALL OSfn_
	ADD  SP,4
;} 
	RET
; 
;/***-----------------------------------------------***/ 
;putstr(prntstr) /** must be '$' terminated, conout  **/ 
putstr:
; int *prntstr; 
;{ 
;	OSfn_(C_WRITESTR,prntstr); /* Fn 9, DS:DX */ 
	MOV  AX,9
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL OSfn_
	ADD  SP,4
;} 
	RET
; 
;/***-----------------------------------------------***/ 
;/*** 1:46 PM 8/15/2008				---***/ 
;/*** int puts(char *string) ; rets 0`success .else.***/ 
;/***  non-zero.  C strings are null terminated.	   ***/ 
;puts(str) char str[]; 
puts:
;{ 
;	char pstr[],*ptb,*ip,*op,*mx,chr; 
	PUSH AX
	PUSH AX
	PUSH AX
	PUSH AX
	PUSH AX
	DEC  SP
;	int  ndx; 
	PUSH AX
; 
;	mx = &tbuff[0];  /** holds byte len of tbuff **/ 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;	ip = &tbuff[1];  /** returns len entered **/ 
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;	ptb = &tbuff[2]; /** buffer data area **/ 
	MOV  AX,9
	ADD  AX,SP
	PUSH AX
	MOV  AX,tbuff
	PUSH AX
	MOV  AX,2
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;	op = ptb;	/** save start **/ 
	MOV  AX,5
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;	pstr = str; 
	MOV  AX,11
	ADD  AX,SP
	PUSH AX
	MOV  AX,17
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;	ndx = 0; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
; 
;	*mx = 127; /** set max length for string 0..126 **/ 
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,127
	POP  BX
	MOV  [BX],AL
;	*ip = 0; 
	MOV  AX,7
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AL
;		 
; 
;	while (1) 
cc539:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc540
;		{ 
;		if (ndx == 127) 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,127
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc541
;			{ /** internal max str len **/ 
;			NLfn(); 
	CALL NLfn
;			putstr("-= String maxed error =-$"); 
	MOV  AX,cc1+2315
	PUSH AX
	CALL putstr
	ADD  SP,2
;			return (BAD); 
	MOV  AX,1
	NEG  AX
	ADD  SP,13
	RET
;			} 
;		if (pstr[ndx] == 0) 
cc541:
	MOV  AX,11
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc542
;			{	/** found null **/ 
;			*ptb = '$';   /** chg termination **/ 
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,36
	POP  BX
	MOV  [BX],AL
;			*ip = ndx;    /** length of str in tbuff **/ 
	MOV  AX,7
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AL
;			putstr(op); 
	MOV  AX,5
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL putstr
	ADD  SP,2
;			return (ndx); /** pass back numb of chrs **/ 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,13
	RET
;			} 
;		else	{  /** not EO string yet, copy chr **/ 
	JMP  cc543
cc542:
;			chr = pstr[ndx]; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,13
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;			*ptb++ = chr; 
	MOV  AX,9
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;			} 
cc543:
;		ndx++; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
;		} 
	JMP  cc539
cc540:
;} 
	ADD  SP,13
	RET
; 
;/***-----------------------------------------------***/ 
;/*** dump2cons(fp_); write DTA to console, primitive.*/ 
;dump2cons(fp_) int fp_; 
dump2con:
;{	/** change index to _iod address **/ 
;	int *fptr, i, index; 
	PUSH AX
	PUSH AX
	PUSH AX
;	char fbuf[], byteval, *pccb; 
	PUSH AX
	DEC  SP
	PUSH AX
; 
;	pccb = _iod[fp_]; /** log address of CCB fcb **/ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,17
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;	fbuf = &pccb[FBUFFER]; 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,44
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;	i = 128; 
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  AX,128
	POP  BX
	MOV  [BX],AX
;	index = 0; 
	MOV  AX,5
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
;	while (i) 
cc544:
	MOV  AX,7
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc545
;		{ 
;		byteval = fbuf[index++]; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,5
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,9
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;		if (byteval == EOFCHR) break; 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,26
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc546
	JMP  cc545
;		if (isnprint (byteval))  
cc546:
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	CALL isnprint
	ADD  SP,2
	CMP  AX,0
	JNE  $+5
	JMP  cc547
;			{ /** non printable substitution **/ 
;			putchar('^'); 
	MOV  AX,94
	PUSH AX
	CALL putchar
	ADD  SP,2
;			continue; 
	JMP  cc544
;			} 
;		putchar(byteval); 
cc547:
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	CALL putchar
	ADD  SP,2
;		i--; 
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	DEC  AX
	POP  BX
	MOV  [BX],AX
	INC  AX
;		} 
	JMP  cc544
cc545:
;	return (index);	 
	MOV  AX,5
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,11
	RET
;} 
; 
;/***-----------------------------------------------***/ 
;/** ----------= F I L E   I / O =------------------ **/ 
;/***-----------------------------------------------***/ 
;/*** OS_ := direct OS calls which map to 'C' Fns.  ***/ 
;/***-----------------------------------------------***/ 
;/*** Program Terminate is Fn# 0, but use exit();   ***/ 
;/***-----------------------------------------------***/ 
;/** These minimal file io primitives req'd for sm-c **/ 
;/** int putc(int chr,FILE *fp); ret`chr`ok .else. EOF*/ 
;/** int getc(FILE *fp); ret`nxtchr`ok .else. EOF    **/ 
;/** fopen(name,mode) fclose(fp)			    **/ 
;/***-----------------------------------------------***/ 
;/** File Open 15 | On entry DS:DX := unopened FCB,  **/ 
;/** Ret: int fp_, index of iob structure assigned.  **/ 
;/** search thru CCB's, i.e. File Descriptors, for   **/ 
;/** free descriptor to use. Copy filename and mode  **/ 
;/** to descriptor fields.  OS Call 5 returns NULL if**/ 
;/** either open or create is successful, but fopen()**/ 
;/** returns fp#, or NULL if error opening the file. **/ 
; 
;fopen(filespec, mode) char *filespec, *mode;  
fopen:
;{ 
;	int result, fpi; 
	PUSH AX
	PUSH AX
;	char *ufdesc, *indx, *p_ccb, sval; 
	PUSH AX
	PUSH AX
	PUSH AX
	DEC  SP
;  /** available slot, first free _iod index is our **/ 
;  /** fp#, return this after further processing    **/ 
;	while (1)  
cc548:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc549
;		{ 
;		fpi = 3; 
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	POP  BX
	MOV  [BX],AX
;		p_ccb = _iod[fpi]; /** infile **/ 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;		sval = p_ccb[FSTATE]; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;		if ( sval == STATE_FR) {break;} 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc550
	JMP  cc549
; 
;		fpi = 4; 
cc550:
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  AX,4
	POP  BX
	MOV  [BX],AX
;		p_ccb = _iod[fpi]; /** outfile **/ 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;		sval = p_ccb[FSTATE]; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;		if ( sval == STATE_FR) {break;} 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc551
	JMP  cc549
; 
;		fpi = 5; 
cc551:
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  AX,5
	POP  BX
	MOV  [BX],AX
;		p_ccb = _iod[fpi]; /** temp **/ 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;		sval = p_ccb[FSTATE]; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;		if ( sval == STATE_FR) {break;} 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc552
	JMP  cc549
;	/** else none of the 3 CCB's are available **/ 
;		sval = STATE_ER; 
cc552:
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,1
	NEG  AX
	POP  BX
	MOV  [BX],AL
;		NLfn(); 
	CALL NLfn
;		putstr("No Available IOD$"); 
	MOV  AX,cc1+2341
	PUSH AX
	CALL putstr
	ADD  SP,2
;		break; 
	JMP  cc549
;		} 
	JMP  cc548
cc549:
;  /** catch error, return null  **/ 
;	if ( sval == STATE_ER ) 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,1
	NEG  AX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc553
;		{ 
;		NLfn(); 
	CALL NLfn
;		putstr("fopen STATE_ER error.$"); 
	MOV  AX,cc1+2359
	PUSH AX
	CALL putstr
	ADD  SP,2
;		return (NULL); 
	MOV  AX,0
	ADD  SP,11
	RET
;		} 
;  /** else presumed free descriptor **/ 
;  /** fpi holds index in _iod, which has addr of desc **/ 
;  /** p_ccb holds that addr. Copy it as ufdesc        **/ 
;	ufdesc = p_ccb; 
cc553:
	MOV  AX,5
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;  /** Set FMODE to mode **/ 
;	p_ccb[FMODE] = *mode; 
	MOV  AX,1
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,38
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,15
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;	p_ccb[DRV] = 0; /** current default drive **/ 
	MOV  AX,1
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AL
;				/** chg behavior in future version **/ 
; 
;  /** Copy Filefilespec as upper case to FNAME, FTYP **/ 
;	clearfcb(ufdesc); /** overwrite with spaces to clear **/ 
	MOV  AX,5
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL clearfcb
	ADD  SP,2
;	p_ccb = &p_ccb[FNAME]; 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;	indx = filespec; 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,17
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;	while (1) 
cc554:
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc555
;		{ /** null terminated strings **/ 
;		if (*indx == 0) break; 
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc556
	JMP  cc555
;		if (*indx == '.') 
cc556:
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,46
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc557
;			{ 
;			p_ccb = &ufdesc[FTYP]; 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  AX,7
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,9
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;			indx++; 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
;			} 
;		if (*indx)  
cc557:
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc558
;			{ 
;			*p_ccb = toupper(*indx); 
	MOV  AX,1
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,5
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	CALL toupper
	ADD  SP,2
	POP  BX
	MOV  [BX],AL
;			p_ccb++; indx++; 
	MOV  AX,1
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
;			} 
;		else break; 
	JMP  cc559
cc558:
	JMP  cc555
cc559:
;		} 
	JMP  cc554
cc555:
; 
;  /** call OS_fo, pass user file descriptor ptr -------------**/ 
;	result = OS_fo(ufdesc); 
	MOV  AX,9
	ADD  AX,SP
	PUSH AX
	MOV  AX,7
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL OS_fo
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
; 
;  /** process low level fopen result **/ 
;	if (result == NULL) 
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc560
;		{ /** successful open from lower level **/ 
;		  /** conout state information **/ 
;		if (VERBOSE) 
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc561
;			{ 
;			NLfn(); 
	CALL NLfn
;			putstr("CCB File Buffer assigned.$"); 
	MOV  AX,cc1+2382
	PUSH AX
	CALL putstr
	ADD  SP,2
;			NLfn(); 
	CALL NLfn
;			putstr ("fopen result reports not null.$"); 
	MOV  AX,cc1+2409
	PUSH AX
	CALL putstr
	ADD  SP,2
;			NLfn();outdeci(fpi);NLfn(); 
	CALL NLfn
	MOV  AX,7
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL outdeci
	ADD  SP,2
	CALL NLfn
;			} 
;		return fpi; 
cc561:
	MOV  AX,7
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,11
	RET
; 		} 
;	else 	{ /** unsuccessful open **/ 
	JMP  cc562
cc560:
;		if (VERBOSE) 
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc563
;			{ 
;			NLfn(); 
	CALL NLfn
;			putstr ("fopen result reports null.$"); 
	MOV  AX,cc1+2441
	PUSH AX
	CALL putstr
	ADD  SP,2
;			} 
;		return (NULL); 
cc563:
	MOV  AX,0
	ADD  SP,11
	RET
;		} 
cc562:
;} 
	ADD  SP,11
	RET
; 
;/***-----------------------------------------------***/ 
;/** File Open 15 | On entry DS:DX := unopened FCB,  **/ 
;/** the dir is searched searched for the named file **/ 
;/** and returns AL := FFh if not found, .else. AL:= **/ 
;/** 0, and the entry FCB is filled in, DRV:=current **/ 
;/** drv, Current Block :=0.  OS Call 5 returns NULL **/ 
;/** if either open or create is successful.         **/ 
; 
;OS_fo (ufdesc) char ufdesc[]; 
OS_fo:
;{ /** User File Descriptor*/ 
;	char cresult, *cbuff; 
	DEC  SP
	PUSH AX
;	int iresult, i; 
	PUSH AX
	PUSH AX
;	cresult = ufdesc[FMODE]; 
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,38
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
; 
;  /** if fmode := read, f must exist for std C **/ 
;	if ((cresult == 'r') | (cresult == 'R')) 
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,114
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,82
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc564
;		{ 
;		cresult = OSfn_(OPEN, ufdesc); 
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	MOV  AX,15
	PUSH AX
	MOV  AX,13
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL OSfn_
	ADD  SP,4
	POP  BX
	MOV  [BX],AL
; 
;	  /** OS Open op searches for f, returns FFh if not found **/ 
;		if (cresult == BAD) 
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,1
	NEG  AX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc565
;			{ 
;			NLfn(); 
	CALL NLfn
;			putstr("File Not Found for reading, Error..$"); 
	MOV  AX,cc1+2469
	PUSH AX
	CALL putstr
	ADD  SP,2
;			return (BAD); 
	MOV  AX,1
	NEG  AX
	ADD  SP,7
	RET
;			} 
;		else	{	/** Open Successful **/ 
	JMP  cc566
cc565:
;			NLfn(); 
	CALL NLfn
;			putstr("File Found and Opened for Reading.$"); 
	MOV  AX,cc1+2506
	PUSH AX
	CALL putstr
	ADD  SP,2
;			ufdesc[FSTATE] = STATE_FO; 
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,1
	POP  BX
	MOV  [BX],AL
;		/** assign DTA _and_ seed it from file **/ 
;			cbuff = &ufdesc[FBUFFER]; 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,44
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;			setdta(cbuff); 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL setdta
	ADD  SP,2
;			iresult = OS_sr(ufdesc); 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL OS_sr
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
;			if (iresult)	/** 0`ok, 1`EOF **/ 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc567
;				{  /** true if EOF, else null returned **/ 
;				ufdesc[FSTATE] = STATE_EF; 
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,8
	POP  BX
	MOV  [BX],AL
;				ufdesc[FBUFNDX] = 0; 
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,42
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AL
;				} 
;			else  { 
	JMP  cc568
cc567:
;				ufdesc[FBUFNDX] = 0; 
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,42
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AL
;				ufdesc[FSTATE] = STATE_DT; 
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,2
	POP  BX
	MOV  [BX],AL
;				} 
cc568:
;			return (cresult); 
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	ADD  SP,7
	RET
;			} 
cc566:
;		} 
;	  /** if fmode := write, f created or f overwritten for std C **/ 
; 
;	else if ((cresult == 'w') | (cresult == 'W')) 
	JMP  cc569
cc564:
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,119
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,87
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc570
;		{ /** fcb ptr to unopened fcb, FFh ret if no file, else ret 0 **/ 
;		cresult = OSfn_(OPEN, ufdesc); 
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	MOV  AX,15
	PUSH AX
	MOV  AX,13
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL OSfn_
	ADD  SP,4
	POP  BX
	MOV  [BX],AL
;	 
;		if (cresult == BAD) 
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,1
	NEG  AX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc571
;			{  /** fille not found in current directory **/ 
;			NLfn(); 
	CALL NLfn
;			putstr("File Not Found for writing, Creating..$"); 
	MOV  AX,cc1+2542
	PUSH AX
	CALL putstr
	ADD  SP,2
;			cresult = creatf(ufdesc); 
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL creatf
	ADD  SP,2
	POP  BX
	MOV  [BX],AL
;			if (cresult == BAD) return BAD; 
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,1
	NEG  AX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc572
	MOV  AX,1
	NEG  AX
	ADD  SP,7
	RET
;			else	{  /** Successful File Create for Writing **/ 
	JMP  cc573
cc572:
;				NLfn(); 
	CALL NLfn
;				putstr(" -File Created for Writing- $"); 
	MOV  AX,cc1+2582
	PUSH AX
	CALL putstr
	ADD  SP,2
;				ufdesc[FSTATE] = STATE_FO; 
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,1
	POP  BX
	MOV  [BX],AL
;				  /** assign DTA _and_ seed it with ^Z **/ 
;				cbuff = &ufdesc[FBUFFER]; 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,44
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;				setdta(cbuff); 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL setdta
	ADD  SP,2
;				i=127; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,127
	POP  BX
	MOV  [BX],AX
;				while (i) cbuff[i--] = CTRLZ; 
cc574:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc575
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	DEC  AX
	POP  BX
	MOV  [BX],AX
	INC  AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,26
	POP  BX
	MOV  [BX],AL
	JMP  cc574
cc575:
;				cbuff[i] = CTRLZ; /** position index 0 **/ 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,26
	POP  BX
	MOV  [BX],AL
;				return (NULL); 
	MOV  AX,0
	ADD  SP,7
	RET
;				} 
cc573:
;			} 
;		else	{  /** File Found and Successfully Opened for Writing. **/ 
	JMP  cc576
cc571:
;		  /** Note that file position is at the beginning of the file. **/ 
;		  /** seed buffer with ctl-z, eof marker **/ 
;			i=127; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,127
	POP  BX
	MOV  [BX],AX
;			cbuff = &ufdesc[FBUFFER]; 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,44
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;			while (i) cbuff[i--] = CTRLZ; 
cc577:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc578
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	DEC  AX
	POP  BX
	MOV  [BX],AX
	INC  AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,26
	POP  BX
	MOV  [BX],AL
	JMP  cc577
cc578:
;			cbuff[i] = CTRLZ; /** position index 0 **/ 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,26
	POP  BX
	MOV  [BX],AL
;			ufdesc[FSTATE] = STATE_FO; 
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,1
	POP  BX
	MOV  [BX],AL
;			return (cresult); 
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	ADD  SP,7
	RET
;			} 
cc576:
;		} 
;  /** else some major error **/ 
;	NLfn(); 
cc570:
cc569:
	CALL NLfn
;	putstr(" -Major FMODE error- $"); 
	MOV  AX,cc1+2612
	PUSH AX
	CALL putstr
	ADD  SP,2
;	return BAD; 
	MOV  AX,1
	NEG  AX
	ADD  SP,7
	RET
;} 
; 
;/***-----------------------------------------------***/ 
;/** File Close 16 | Req'd to update dir info. DS:DX **/ 
;/*** fclose() ret NULL if successful, else nz err  ***/ 
;/*** Call 5 ret FFh, BAD, means err, NULL is ok    ***/ 
; 
;fclose(fp_) int fp_;  
fclose:
;{ 
;	int *fptr, result; 
	PUSH AX
	PUSH AX
;  /** don't close standard files **/ 
;	if ((fp_==stdin)|(fp_==stdout)|(fp_==stderr)) return NULL; 
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	OR   AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc579
	MOV  AX,0
	ADD  SP,4
	RET
;  /** convert fp_ index to CCB ptr, then call lower level **/ 
;	fptr = _iod[fp_]; 
cc579:
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;	result = OS_fc(fptr); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL OS_fc
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
;	if (VERBOSE) 
	MOV  AX,1
	CMP  AX,0
	JNE  $+5
	JMP  cc580
;		{ 
;		if (result == NULL) 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc581
;			{ 
;			NLfn(); 
	CALL NLfn
;			putstr ("fclose result reports null, success.$"); 
	MOV  AX,cc1+2635
	PUSH AX
	CALL putstr
	ADD  SP,2
;			} 
;		else	{ 
	JMP  cc582
cc581:
;			NLfn(); 
	CALL NLfn
;			putstr ("fclose result reports not null, fail.$"); 
	MOV  AX,cc1+2673
	PUSH AX
	CALL putstr
	ADD  SP,2
;			NLfn();outdeci(fp_);NLfn(); 
	CALL NLfn
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL outdeci
	ADD  SP,2
	CALL NLfn
;			} 
cc582:
;		} 
;	return result; 
cc580:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,4
	RET
;} 
; 
;/***-----------------------------------------------***/ 
;/** File Close 16 | Req'd to update dir info. DS:DX **/ 
;/** := Close FCB, AL:=0 means ok, AL:=FFh means     **/ 
;/** error. (BAD).                                   **/ 
;/** at exit FCB must appear as unopened, clear FMODE */ 
;/**  FSTATE **/ 
; 
;OS_fc(ufdesc) char ufdesc[]; /** User File Descriptor*/ 
OS_fc:
;{ 
;	int result,cnt,idx; 
	PUSH AX
	PUSH AX
	PUSH AX
;	char stflg; 
	DEC  SP
; 
;  /** note default open read is STATE_FO **/ 
;  /** A Read changes FCB Block Values to current block **/ 
;  /** check for pending write before closing **/ 
;	stflg = ufdesc[FSTATE]; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
; 
;	if (stflg == STATE_PW) flushf(ufdesc); 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,4
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc583
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL flushf
	ADD  SP,2
;  /** ok, close. **/ 
;  /** successful close returns AL:=0, else FFh err  **/ 
;	result = OSfn_(CLOSE, ufdesc); 
cc583:
	MOV  AX,5
	ADD  AX,SP
	PUSH AX
	MOV  AX,16
	PUSH AX
	MOV  AX,13
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL OSfn_
	ADD  SP,4
	POP  BX
	MOV  [BX],AX
;	if (result == NULL) 
	MOV  AX,5
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc584
;		{ 
;		NLfn(); 
	CALL NLfn
;		putstr ("OS_fc result reports null, success.$"); 
	MOV  AX,cc1+2712
	PUSH AX
	CALL putstr
	ADD  SP,2
;		} 
;	else	{ 
	JMP  cc585
cc584:
;		NLfn(); 
	CALL NLfn
;		putstr ("OS_fc result reports non-null, error.$"); 
	MOV  AX,cc1+2749
	PUSH AX
	CALL putstr
	ADD  SP,2
;		} 
cc585:
;  /** Clear CCB, Free FMODE, FSTATE, fn **/ 
; 
;	ufdesc[FMODE] = 0; 
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,38
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AL
;	ufdesc[FSTATE] = ufdesc[DRV] = 0; 
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,11
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AL
	POP  BX
	MOV  [BX],AL
;/***	cnt = 171; idx = 0; while (cnt--) { ufdesc[idx++] = 0; } **/ 
;  /** Return reported result, note we clear CCB to **/ 
;  /** new, even on error. **/ 
;	if (result == BAD) return BAD; 
	MOV  AX,5
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	NEG  AX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc586
	MOV  AX,1
	NEG  AX
	ADD  SP,7
	RET
;	else return NULL; 
	JMP  cc587
cc586:
	MOV  AX,0
	ADD  SP,7
	RET
cc587:
;} 
	ADD  SP,7
	RET
; 
;/***--- Write Record according to current blk/rec  ***/ 
;/***--- settings in fcb                            ***/ 
;wr_rec() 
wr_rec:
;{ 
;} 
	RET
; 
;/***-----------------------------------------------***/ 
;/** int getc(FILE *fp); ret`nxtchr`ok .else. EOF    **/ 
;/**  init is fp_ index into _iob                    **/ 
; 
;getc(unit) int unit; 
getc:
;{ 
;	int ichr; 
	PUSH AX
;  /** fetch ascii character from file and return it **/ 
;	ichr = rd_ubuff(unit); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL rd_ubuff
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
;	if (ichr == EOF) return (EOF); 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	NEG  AX
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc588
	MOV  AX,1
	NEG  AX
	ADD  SP,2
	RET
;	return (ichr & 127); 
cc588:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,127
	POP  BX
	AND  AX,BX
	ADD  SP,2
	RET
;} 
;/***-----------------------------------------------***/ 
;/** int puts(char *string); ret`0`ok .else. `NZ`err **/ 
;/**  takes a pointer value to target string, decom- **/ 
;/**  pose targets' characters and pass each one to  **/ 
;/**  putc() until NULL in string. CONOUT.           **/ 
; 
;/***-----------------------------------------------***/ 
;/** int fputs(char *string, FILE *fp);             ***/ 
;/**  ret`0`ok .else. `NZ`err                        **/ 
;/**  takes a pointer value to target string, decom- **/ 
;/**  pose targets' characters and pass each one to  **/ 
;/**  putc() until NULL in string.  Does not append  **/ 
;/**  the new-line character to the end of the string**/ 
;/** Target string is C string, null terminated.     **/ 
; 
;fputs(str,fp_) char str[]; int fp_; 
fputs:
;{ 
;	char chr; int i; 
	DEC  SP
	PUSH AX
; 
;	i=0; chr = str[0]; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;	if (chr == 0) return BAD; 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc589
	MOV  AX,1
	NEG  AX
	ADD  SP,3
	RET
;	while (chr) 
cc589:
cc590:
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc591
;		{ 
;		putc(chr,fp_); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,7
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL putc
	ADD  SP,4
;		chr = str[++i]; /** read chr from ds:str **/ 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
;		} 
	JMP  cc590
cc591:
;} 
	ADD  SP,3
	RET
; 
;/***-----------------------------------------------***/ 
;/** int putc(int chr,FILE *fp); ret`chr`ok .else. EOF*/ 
;/** note: only retun EOF on File Error, ret null or **/ 
;/** chr only.  (echo back chr means success)		*/ 
;/** _get ptr to CCB; //DTA is CCB[FBUFFER]; putc to **/ 
;/**  //[FBUFFER]+[FBUFNDX];                         **/ 
;/** _get FBUFNDX,				    **/ 
;/** .if. == 0, set FSTATE == STATE_PW		    **/ 
;/** .if. == 128, flush buffer to file, set FBUFNDX==0*/ 
;/**      set FSTATE == STATE_DT;		    **/ 
;/** .else. place chr to FBUFNDX and incr FBUFNDX    **/ 
;/** NOTE: small-c will close outfile if putc rets<=0**/ 
; 
;putc(chr,fp_) char chr; int fp_; 
putc:
;{ 
;	int *fptr, i, index; 
	PUSH AX
	PUSH AX
	PUSH AX
;	char fbuf[], byteret, *pccb; 
	PUSH AX
	DEC  SP
	PUSH AX
;  /** First off, test for printable character passed **/ 
;  /**  isnprint returns 1 if not printable           **/ 
;  /**	if (isnprint(chr)) return (BAD);	**/ 
; 
;  /** convert fp_ index to CCB ptr **/ 
;	pccb = _iod[fp_]; /** log address of CCB fcb **/ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,17
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;	fbuf = &pccb[FBUFFER]; /** get buffer location **/ 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,44
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;	setdta(fbuf); /** indicate current DTA for write **/ 
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL setdta
	ADD  SP,2
;	index = pccb[FBUFNDX]; 
	MOV  AX,5
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,42
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AX
; 
;  /** put char to buffer **/ 
;	fbuf = &pccb[FBUFFER]; /** get buffer location **/ 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,44
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;	fbuf = fbuf + index; /** base + index **/ 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,5
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;	*fbuf = chr; /** chr placed into current buffer **/ 
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,17
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AL
; 
;	if (index == 0) pccb[FSTATE] = STATE_PW; 
	MOV  AX,5
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc592
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,4
	POP  BX
	MOV  [BX],AL
; 
;  /** ck if index is maxed, if so wr buffer and reset index **/ 
;	if (index == 127) /** maxed, signed byte compare **/ 
cc592:
	MOV  AX,5
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,127
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc593
;		{ /** flushf full buffer **/ 
;		byteret = flushf(pccb); 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL flushf
	ADD  SP,2
	POP  BX
	MOV  [BX],AL
;		if (byteret)  /** 0`ok .else. err **/ 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc594
;			{ /** error state **/ 
;			pccb[FSTATE] = STATE_ER; 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,1
	NEG  AX
	POP  BX
	MOV  [BX],AL
;			return BAD; 
	MOV  AX,1
	NEG  AX
	ADD  SP,11
	RET
;			} 
;		else	{ /** flushed ok, purge buff upd index **/ 
	JMP  cc595
cc594:
;			fbuf = &pccb[FBUFFER]; /** reset to begin **/ 
	MOV  AX,3
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,44
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;		 /** fill buffer with CTRLZ, EOF **/ 
;			i=127; 
	MOV  AX,7
	ADD  AX,SP
	PUSH AX
	MOV  AX,127
	POP  BX
	MOV  [BX],AX
;			while (i) fbuf[i--] = CTRLZ; 
cc596:
	MOV  AX,7
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc597
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,9
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	DEC  AX
	POP  BX
	MOV  [BX],AX
	INC  AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,26
	POP  BX
	MOV  [BX],AL
	JMP  cc596
cc597:
;			fbuf[i] = CTRLZ; /** position index 0 **/ 
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,9
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,26
	POP  BX
	MOV  [BX],AL
;			pccb[FSTATE] = STATE_DT; /** Closeable State **/ 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,2
	POP  BX
	MOV  [BX],AL
;			pccb[FBUFNDX] = 0; /** reset for next chr **/ 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,42
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AL
;			return (chr); 
	MOV  AX,15
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	ADD  SP,11
	RET
;			} 
cc595:
;		} /** sector written, chr or err has been returned **/ 
; 
;  /** update index return chr placed -echo- **/  
;  /**	pccb[FBUFNDX]++; ??questionable	**/ 
;	index++; 
cc593:
	MOV  AX,5
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	INC  AX
	POP  BX
	MOV  [BX],AX
	DEC  AX
;	pccb[FBUFNDX] = index; 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,42
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,7
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AL
;	return (chr); 
	MOV  AX,15
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	ADD  SP,11
	RET
;} 
; 
;/***-----------------------------------------------***/ 
;/*** set to spaces the fcb filename,typ		---***/ 
; 
;clearfcb(fcb) char fcb[]; 
clearfcb:
;{ 
;	int i; 
	PUSH AX
;	i=11; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,11
	POP  BX
	MOV  [BX],AX
;	while (i) fcb[i--] = ' '; 
cc598:
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc599
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  BX,AX
	MOV  AX,[BX]
	DEC  AX
	POP  BX
	MOV  [BX],AX
	INC  AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,32
	POP  BX
	MOV  [BX],AL
	JMP  cc598
cc599:
;} 
	ADD  SP,2
	RET
; 
;/***-----------------------------------------------***/ 
; 
;/***-----------------------------------------------***/ 
;/** Directory First Search 17**/ 
; 
;/***-----------------------------------------------***/ 
;/** Directory Subsequent Search 18 **/ 
; 
;/***-----------------------------------------------***/ 
;/** File Delete 19 **/ 
; 
;/***-----------------------------------------------***/ 
;/** File Sequential Read 20 | On Entry, DS:DX:=FCB **/ 
;/** The 128 byte record indicated by Current Block **/ 
;/** of 16k, and Current Record Fields, is loaded to**/ 
;/** the Disk Transfer Area, DTA, then the record   **/ 
;/** addressed by those fields is incremented. IF EOF*/ 
;/** THEN AL:=1, ELSE AL:=0.                        **/  
; 
;OS_sr(ufcb) char ufcb[]; 
OS_sr:
;{ 
;	int byte_result; 
	PUSH AX
; 
;	byte_result = OSfn_(SEQREAD,ufcb); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,20
	PUSH AX
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL OSfn_
	ADD  SP,4
	POP  BX
	MOV  [BX],AX
;	if (byte_result) return (EOF); 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc600
	MOV  AX,1
	NEG  AX
	ADD  SP,2
	RET
;	else return (0); 
	JMP  cc601
cc600:
	MOV  AX,0
	ADD  SP,2
	RET
cc601:
;} 
	ADD  SP,2
	RET
; 
;/***-----------------------------------------------***/ 
;/** rd_ubuff(int fp) read unit buffer, if last chr  **/ 
;/**  re index and fetch next file record.           **/ 
;/** Called by getc(fp_), so ret chr or EOF          **/ 
;/** Note: short sector files are null padded, catch **/ 
;/** partial buffer data.                            **/ 
;/** 30-Jul-08 05:08:51 PM. OS_sr returns 0 if ok,   **/ 
;/** .else. 1 if EOF. Fixed buffer clipping.         **/ 
; 
;rd_ubuff(fp_) int fp_; 
rd_ubuff:
;{	/** change fp_ index into _iod address **/ 
;	/** check _iod is read kind, else error **/ 
;	/** chr_ptr points to next_to_read **/ 
;	/** if chr_ptr == 0, ck STATE_EF for eof **/ 
;	/**  if EOF state return EOF **/ 
;	/** if chr_ptr == 127 retrieve chr, do seq **/ 
;	/** read to fill buffer, reindex chr_ptr =0 **/ 
;	/** if read_sq gives EOF, set state STATE_EF, **/ 
;	/** but return last chr to caller. **/ 
; 
;	int chr, index, result; 
	PUSH AX
	PUSH AX
	PUSH AX
;	char *p_ccb, *cdta, *cp; 
	PUSH AX
	PUSH AX
	PUSH AX
; 
;  /** Convert fp_ into addr of UFCB **/ 
;	p_ccb = _iod[fp_]; 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,18
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
; 
;  /** Also need to manage DTA for UFCB **/ 
;	cdta = &p_ccb[FBUFFER]; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,44
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;	cp = cdta; 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;	setdta(cdta); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL setdta
	ADD  SP,2
; 
;  /** check _iod is read kind, else error **/ 
;	if (p_ccb[FMODE] != 'r') 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,38
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,114
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JNZ  $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc602
;		{ /** mode error **/ 
;		NLfn(); 
	CALL NLfn
;		putstr("File Mode Error, not opened for Reading$"); 
	MOV  AX,cc1+2788
	PUSH AX
	CALL putstr
	ADD  SP,2
;		return (EOF); 
	MOV  AX,1
	NEG  AX
	ADD  SP,12
	RET
;		} 
;	if ((p_ccb[FSTATE] == STATE_EF) & (p_ccb[FBUFNDX] == 127)) 
cc602:
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,8
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,42
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,127
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	POP  BX
	AND  AX,BX
	CMP  AX,0
	JNE  $+5
	JMP  cc603
;		{  /** last low level read returned eof **/ 
;		NLfn(); 
	CALL NLfn
;		putstr("-= End of File Reached =- $"); 
	MOV  AX,cc1+2829
	PUSH AX
	CALL putstr
	ADD  SP,2
;		return (EOF); 
	MOV  AX,1
	NEG  AX
	ADD  SP,12
	RET
;		} 
;  /** fetch ascii character from file buffer and hold it **/   
;	index = p_ccb[FBUFNDX]; 
cc603:
	MOV  AX,8
	ADD  AX,SP
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,42
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AX
;	cp = cp + index;  /** base + index to chr in buffer **/ 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,12
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	ADD  AX,BX
	POP  BX
	MOV  [BX],AX
;	chr = *cp;		/** FBUFNDX points to next, got chr **/ 
	MOV  AX,10
	ADD  AX,SP
	PUSH AX
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	POP  BX
	MOV  [BX],AX
;  /** change null to sp ' ' char, these are text files only. **/ 
;	if (chr == NULL) chr = ' '; 
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,0
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc604
	MOV  AX,10
	ADD  AX,SP
	PUSH AX
	MOV  AX,32
	POP  BX
	MOV  [BX],AX
;  /** !! Convert eol 0Dh,0Ah to 20h,0Ah for small-c parser. !! **/ 
;	if (chr == 13) chr = ' '; 
cc604:
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,13
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc605
	MOV  AX,10
	ADD  AX,SP
	PUSH AX
	MOV  AX,32
	POP  BX
	MOV  [BX],AX
; 
;  /** Warning: an unprimed buffer could hold nulls, handle this **/ 
;  /** by priming buffer on fopen(fp_,'r') for reading.          **/ 
;  /** Still, should check here for ^Z, eof, marker and ret EOF. **/ 
;  /** But NO, file can be exact byte length without terminators.**/ 
; 
;  /** ck if index is maxed, if so rd buffer and reset index **/ 
;	if (index == 127)      /** maxed, signed byte compare **/ 
cc605:
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,127
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc606
;		{  /** eo buffer read, fetch next from seq read **/ 
;		result = OS_sr(p_ccb); 
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL OS_sr
	ADD  SP,2
	POP  BX
	MOV  [BX],AX
;		if (result) 
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	CMP  AX,0
	JNE  $+5
	JMP  cc607
;			{  /** true if EOF, else null returned **/ 
;			p_ccb[FSTATE] = STATE_EF; 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,8
	POP  BX
	MOV  [BX],AL
;			p_ccb[FBUFNDX] = 0; 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,42
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AL
;			return (chr); 
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,12
	RET
;			} 
;		else  { 
	JMP  cc608
cc607:
;			p_ccb[FBUFNDX] = 0; 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,42
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,0
	POP  BX
	MOV  [BX],AL
;			p_ccb[FSTATE] = STATE_DT; 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,2
	POP  BX
	MOV  [BX],AL
;			return (chr); /** added to fix clipping **/ 
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,12
	RET
;			} 
cc608:
;		} 
;	p_ccb[FBUFNDX]++; /** update for next chr fetch from buffer **/ 
cc606:
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,42
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	INC  AX
	POP  BX
	MOV  [BX],AL
	DEC  AX
;	return (chr); 
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	ADD  SP,12
	RET
;} 
; 
;/***-----------------------------------------------***/ 
;/** File Sequential Write 21 | On Entry, DS:DX:=FCB **/ 
;/** The 128 byte record indicated by Current Block  **/ 
;/** of 16k, and Current Record Fields, is written   **/ 
;/** from the Disk Transfer Area, DTA, to the file   **/ 
;/** then the record address is incremented. IF the  **/ 
;/** disk is too full, AL:=1, ELSE AL:=0.            **/ 
;/**	=	=	=	=	=	=   **/ 
;/*** write buffer, 80h long, to file sequentially. ***/ 
;/***  file fp_ must select open file. DTA must be  ***/ 
;/***  current to proper fp_.                       ***/ 
;/***  calls OSfn_ 21d Sequential Write, which rets ***/ 
;/*** al`0`ok .else. al`1`'disk full error'         ***/ 
;/***  flushf() rets`0`ok .else. `BAD`error         ***/ 
;/***-----------------------------------------------***/ 
; 
;flushf(pccb) char *pccb; 
flushf:
;{ 
;	char byte_result; 
	DEC  SP
;	if (pccb[FSTATE] == STATE_PW) 
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,4
	POP  BX
	CMP  BX,AX
	MOV  AX,1
	JZ   $+5
	MOV  AX,0
	CMP  AX,0
	JNE  $+5
	JMP  cc609
;		{ 
;		byte_result = OSfn_(SEQWRITE,pccb); 
	MOV  AX,0
	ADD  AX,SP
	PUSH AX
	MOV  AX,21
	PUSH AX
	MOV  AX,7
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL OSfn_
	ADD  SP,4
	POP  BX
	MOV  [BX],AL
;		if (byte_result) /** indicates err **/ 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	CMP  AX,0
	JNE  $+5
	JMP  cc610
;			{ 
;			pccb[FSTATE] = STATE_ER; 
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,1
	NEG  AX
	POP  BX
	MOV  [BX],AL
;			return (BAD); 
	MOV  AX,1
	NEG  AX
	ADD  SP,1
	RET
;			} 
;		pccb[FSTATE] = STATE_FO; /** mark as file open **/ 
cc610:
	MOV  AX,3
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,41
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,1
	POP  BX
	MOV  [BX],AL
;		return byte_result; 
	MOV  AX,0
	ADD  AX,SP
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	ADD  SP,1
	RET
;		} 
;	else return (BAD); /** no pending write state **/ 
	JMP  cc611
cc609:
	MOV  AX,1
	NEG  AX
	ADD  SP,1
	RET
cc611:
;} 
	ADD  SP,1
	RET
; 
;/***-----------------------------------------------***/ 
;/** File Create 22 Rets: FFh if no dir space else   **/ 
;/**  null == successful create                      **/ 
; 
;creatf(ufcb) char *ufcb; 
creatf:
;{ 
;	OSfn_(CREATE, ufcb); 
	MOV  AX,22
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL OSfn_
	ADD  SP,4
;} 
	RET
; 
;/***-----------------------------------------------***/ 
;/** ReName File 23 **/ 
;OS_rn() 
OS_rn:
;{ 
;} 
	RET
;/***-----------------------------------------------***/ 
;/** non-existent fn# 24 **/ 
;/***-----------------------------------------------***/ 
;/** Current Default Drive 25, 0`A,1`B,etc. **/ 
; 
;/***-----------------------------------------------***/ 
;/** Set Disk Transfer Addr 26 **/ 
;setdta(dta) int *dta; 
setdta:
;{  /**  !MUST! Set DTA address prior to File I/O **/ 
;	OSfn_(26,dta); /** Fn Set DTA -> DS:DX **/ 
	MOV  AX,26
	PUSH AX
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	CALL OSfn_
	ADD  SP,4
;} 
	RET
;/***-----------------------------------------------***/ 
;/** Allocation Table Addr 27 ret: DS:BX, DX := # of..*/ 
;/**  alloc units, AL := # rec per Alloc Unit.       **/ 
;/***-----------------------------------------------***/ 
;/** non-existent fn# 28, 29, 30 **/ 
;/***-----------------------------------------------***/ 
;/** Get Disk Parameter Address 31 ret: DS:BX table  **/ 
;/**  of params for current default disk **/ 
;/***-----------------------------------------------***/ 
;/** non-existent fn# 32 **/ 
;/***-----------------------------------------------***/ 
;/** File Random Read 33 **/ 
;/***-----------------------------------------------***/ 
;/** File Random Write 34 **/ 
;/***-----------------------------------------------***/ 
;/** File Size 35 **/ 
;/***-----------------------------------------------***/ 
;/** File Set Random Record Field 36 **/ 
;/***-----------------------------------------------***/ 
;/** Interrupt Set Vector 37 **/ 
;/***-----------------------------------------------***/ 
;/** Alloc, Create New Program Segment 38 **/ 
;/***-----------------------------------------------***/ 
;/** File Random Block Read 39 **/ 
;/***-----------------------------------------------***/ 
;/** Random Block Write **/ 
; 
;/***-----------------------------------------------***/ 
;/** initialize the fcb structure fields at main    ***/ 
; 
;initfcb() 
initfcb:
;{	char *cptr, *p_stdin, *p_stdout, *p_stderr; 
	PUSH AX
	PUSH AX
	PUSH AX
	PUSH AX
;	char *p_infile, *p_outfile, *p_tempfile; 
	PUSH AX
	PUSH AX
	PUSH AX
;	int  cnt; 
	PUSH AX
; 
;	p_stdin    = "STDIN   IOB"; /** null term.. **/ 
	MOV  AX,12
	ADD  AX,SP
	PUSH AX
	MOV  AX,cc1+2857
	POP  BX
	MOV  [BX],AX
;	p_stdout   = "STDOUT  IOB"; /**  in dseg    **/ 
	MOV  AX,10
	ADD  AX,SP
	PUSH AX
	MOV  AX,cc1+2869
	POP  BX
	MOV  [BX],AX
;	p_stderr   = "STDERR  IOB"; 
	MOV  AX,8
	ADD  AX,SP
	PUSH AX
	MOV  AX,cc1+2881
	POP  BX
	MOV  [BX],AX
;	p_infile   = "INFILE  TXT"; 
	MOV  AX,6
	ADD  AX,SP
	PUSH AX
	MOV  AX,cc1+2893
	POP  BX
	MOV  [BX],AX
;	p_outfile  = "OUTFILE TXT"; 
	MOV  AX,4
	ADD  AX,SP
	PUSH AX
	MOV  AX,cc1+2905
	POP  BX
	MOV  [BX],AX
;	p_tempfile = "TEMP    TXT"; 
	MOV  AX,2
	ADD  AX,SP
	PUSH AX
	MOV  AX,cc1+2917
	POP  BX
	MOV  [BX],AX
;	; 
;	setdta(fdta); /** default catch basin **/ 
	MOV  AX,fdta
	PUSH AX
	CALL setdta
	ADD  SP,2
;  /** setup _iod[] with addr of f_units **/ 
;	_iod[0] = &f_unit0; 
	MOV  AX,_iod
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,f_unit0
	POP  BX
	MOV  [BX],AX
;	_iod[1] = &f_unit1; 
	MOV  AX,_iod
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,f_unit1
	POP  BX
	MOV  [BX],AX
;	_iod[2] = &f_unit2; 
	MOV  AX,_iod
	PUSH AX
	MOV  AX,2
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,f_unit2
	POP  BX
	MOV  [BX],AX
;	_iod[3] = &f_unit3; 
	MOV  AX,_iod
	PUSH AX
	MOV  AX,3
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,f_unit3
	POP  BX
	MOV  [BX],AX
;	_iod[4] = &f_unit4; 
	MOV  AX,_iod
	PUSH AX
	MOV  AX,4
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,f_unit4
	POP  BX
	MOV  [BX],AX
;	_iod[5] = &f_unit5; 
	MOV  AX,_iod
	PUSH AX
	MOV  AX,5
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	PUSH AX
	MOV  AX,f_unit5
	POP  BX
	MOV  [BX],AX
; 
;  /** copy char const to each f_unit **/ 
;  /***  Also, **/ 
;  /** mark stdin as R, stdout, stderr as W in fmode **/ 
;  /** mark infile, outfile, temp as 'N'ull for now. **/ 
;  /**  open these 3 default files in main if desired**/ 
; 
;	cptr = _iod[0]; 
	MOV  AX,14
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,0
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;	*cptr[FMODE] = "r"; 
	MOV  AX,14
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,38
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,cc1+2929
	POP  BX
	MOV  [BX],AL
;	copystr(p_stdin, cptr+1); 
	MOV  AX,12
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,16
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL copystr
	ADD  SP,4
; 
;	cptr = _iod[1]; 
	MOV  AX,14
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,1
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;	*cptr[FMODE] = "w"; 
	MOV  AX,14
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,38
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,cc1+2931
	POP  BX
	MOV  [BX],AL
;	copystr(p_stdout, cptr+1); 
	MOV  AX,10
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,16
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL copystr
	ADD  SP,4
; 
;	cptr = _iod[2]; 
	MOV  AX,14
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,2
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;	*cptr[FMODE] = "w"; 
	MOV  AX,14
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,38
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,cc1+2933
	POP  BX
	MOV  [BX],AL
;	copystr(p_stderr, cptr+1); 
	MOV  AX,8
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,16
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL copystr
	ADD  SP,4
; 
;	cptr = _iod[3]; 
	MOV  AX,14
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,3
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;	*cptr[FMODE] = "n"; 
	MOV  AX,14
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,38
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,cc1+2935
	POP  BX
	MOV  [BX],AL
;	copystr(p_infile, cptr+1); 
	MOV  AX,6
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,16
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL copystr
	ADD  SP,4
; 
;	cptr = _iod[4]; 
	MOV  AX,14
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,4
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;	*cptr[FMODE] = "n"; 
	MOV  AX,14
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,38
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,cc1+2937
	POP  BX
	MOV  [BX],AL
;	copystr(p_outfile, cptr+1); 
	MOV  AX,4
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,16
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL copystr
	ADD  SP,4
; 
;	cptr = _iod[5]; 
	MOV  AX,14
	ADD  AX,SP
	PUSH AX
	MOV  AX,_iod
	PUSH AX
	MOV  AX,5
	ADD  AX,AX
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AX,[BX]
	POP  BX
	MOV  [BX],AX
;	*cptr[FMODE] = "n"; 
	MOV  AX,14
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,38
	POP  BX
	ADD  AX,BX
	MOV  BX,AX
	MOV  AL,[Byte BX]
	CBW
	PUSH AX
	MOV  AX,cc1+2939
	POP  BX
	MOV  [BX],AL
;	copystr(p_tempfile, cptr+1); 
	MOV  AX,2
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,16
	ADD  AX,SP
	MOV  BX,AX
	MOV  AX,[BX]
	PUSH AX
	MOV  AX,1
	POP  BX
	ADD  AX,BX
	PUSH AX
	CALL copystr
	ADD  SP,4
; 
;  /*** otherwise, fields are init to null by nasm ***/ 
;} 
	ADD  SP,16
	RET
; 
; 
;/*****************************************************/ 
;/** Test OSfn_ Call 0005h Interface **/ 
;/*****************************************************/ 
;/* CP/M system call codes                            */ 
;/*     -also-                                        */ 
;/* pcDos .COM Call 5 Interface.                      */ 
; 
; #asm 
BDOS	EQU	5	;; call 5 INTERFACE as CALL BDOS. 
CTRLZ	EQU	26	;end-of-file mark for text files 
TBUFF	EQU	80H	;address of default I/O address 
;;/** OSfn_(Fn#,Value) -> tos 0[ret]2[Value]4[Fn#] **/ 
OSfn_:  ;; small-c, top of stack[ret][Val][Fn] 
	pop  bx   ;; 
        pop  dx   ;; 
        pop  cx   ;; 
	push cx   ;; [Fn#] 
	push dx   ;; [Value] 
        push bx   ;; [ret]  
        call BDOS ;; values passed in registers. 
;; Test AL`CBW returned value... 
	cbw 
	RET       ;; Caller cleans the stack. 
;;exit:  ;; pause for keypress before return. 
;;	mov  ah,0 
;;	int  16h  ;; RomBios wait for keypress. 
exit:		  ;; don't wait. 
	int  19h  ;; reboot-> enviornment gets control. 
	ret       ;; (actually, never executed) 
;/***-----------------------------------------------***/ 
;/*****************************************************/ 
;/*       1         2         3         4         5   */ 
;/***-----------------------------------------------***/ 
;/** EO C5LIB.C **/ 
;                                                 
;/** -======== End of Compiler ========- **/ 
; 
;                            
	;-; SECTION .dseg align=16 ;; commented out for .com version
cc1:	DB 99,104,97,114,0,105,110,116,0,35
	DB 97,115,109,0,35,105,110,99,108,117
	DB 100,101,0,35,100,101,102,105,110,101
	DB 0,42,0,91,0,44,0,42,0,91
	DB 0,44,0,109,97,99,114,111,32,116
	DB 97,98,108,101,32,102,117,108,108,0
	DB 93,0,109,117,115,116,32,98,101,32
	DB 99,111,110,115,116,97,110,116,0,110
	DB 101,103,97,116,105,118,101,32,115,105
	DB 122,101,32,105,108,108,101,103,97,108
	DB 0,93,0,105,108,108,101,103,97,108
	DB 32,102,117,110,99,116,105,111,110,32
	DB 111,114,32,100,101,99,108,97,114,97
	DB 116,105,111,110,0,40,0,109,105,115
	DB 115,105,110,103,32,111,112,101,110,32
	DB 112,97,114,101,110,0,41,0,105,108
	DB 108,101,103,97,108,32,97,114,103,117
	DB 109,101,110,116,32,110,97,109,101,0
	DB 41,0,44,0,101,120,112,101,99,116
	DB 101,100,32,99,111,109,109,97,0,99
	DB 104,97,114,0,105,110,116,0,119,114
	DB 111,110,103,32,110,117,109,98,101,114
	DB 32,97,114,103,115,0,42,0,91,0
	DB 44,0,101,120,112,101,99,116,101,100
	DB 32,99,111,109,109,97,0,99,104,97
	DB 114,0,105,110,116,0,123,0,105,102
	DB 0,119,104,105,108,101,0,114,101,116
	DB 117,114,110,0,98,114,101,97,107,0
	DB 99,111,110,116,105,110,117,101,0,59
	DB 0,35,97,115,109,0,59,0,109,105
	DB 115,115,105,110,103,32,115,101,109,105
	DB 99,111,108,111,110,0,125,0,101,108
	DB 115,101,0,35,101,110,100,97,115,109
	DB 0,41,0,44,0,41,0,59,0,61
	DB 0,124,0,94,0,38,0,61,61,0
	DB 33,61,0,61,61,0,33,61,0,60
	DB 0,62,0,60,61,0,62,61,0,62
	DB 62,0,60,60,0,60,61,0,62,61
	DB 0,60,0,60,60,0,62,0,62,62
	DB 0,62,62,0,60,60,0,62,62,0
	DB 60,60,0,43,0,45,0,42,0,47
	DB 0,37,0,43,43,0,45,45,0,45
	DB 0,42,0,38,0,105,108,108,101,103
	DB 97,108,32,97,100,100,114,101,115,115
	DB 0,43,43,0,45,45,0,91,0,99
	DB 97,110,39,116,32,115,117,98,115,99
	DB 114,105,112,116,0,93,0,99,97,110
	DB 39,116,32,115,117,98,115,99,114,105
	DB 112,116,0,93,0,40,0,40,0,41
	DB 0,105,110,118,97,108,105,100,32,101
	DB 120,112,114,101,115,115,105,111,110,0
	DB 40,0,41,0,43,0,45,0,39,0
	DB 115,116,114,105,110,103,32,115,112,97
	DB 99,101,32,101,120,104,97,117,115,116
	DB 101,100,0,103,108,111,98,97,108,32
	DB 115,121,109,98,111,108,32,116,97,98
	DB 108,101,32,111,118,101,114,102,108,111
	DB 119,0,108,111,99,97,108,32,115,121
	DB 109,98,111,108,32,116,97,98,108,101
	DB 32,111,118,101,114,102,108,111,119,0
	DB 99,99,0,116,111,111,32,109,97,110
	DB 121,32,97,99,116,105,118,101,32,119
	DB 104,105,108,101,115,0,110,111,32,97
	DB 99,116,105,118,101,32,119,104,105,108
	DB 101,115,0,109,105,115,115,105,110,103
	DB 32,113,117,111,116,101,0,109,105,115
	DB 115,105,110,103,32,97,112,111,115,116
	DB 114,111,112,104,101,0,108,105,110,101
	DB 32,116,111,111,32,108,111,110,103,0
	DB 32,32,32,32,32,42,32,42,32,42
	DB 32,32,115,109,97,108,108,45,99,32
	DB 99,111,109,112,105,108,101,114,32,32
	DB 42,32,42,32,42,0,32,32,32,32
	DB 32,32,32,32,32,32,32,32,32,32
	DB 98,121,32,82,111,110,32,67,97,105
	DB 110,0,42,32,78,65,83,77,32,86
	DB 101,114,115,32,99,48,46,49,46,53
	DB 44,32,65,117,103,46,32,50,48,48
	DB 56,44,32,115,95,100,117,98,114,111
	DB 118,105,99,104,64,121,97,104,111,111
	DB 46,99,111,109,32,42,0,68,111,32
	DB 121,111,117,32,119,97,110,116,32,116
	DB 104,101,32,99,45,116,101,120,116,32
	DB 116,111,32,97,112,112,101,97,114,63
	DB 32,40,121,41,32,0,68,111,32,121
	DB 111,117,32,119,105,115,104,32,116,104
	DB 101,32,103,108,111,98,97,108,115,32
	DB 116,111,32,98,101,32,100,101,102,105
	DB 110,101,100,63,32,40,121,41,32,0
	DB 83,116,97,114,116,105,110,103,32,110
	DB 117,109,98,101,114,32,102,111,114,32
	DB 108,97,98,101,108,115,63,32,40,48
	DB 41,32,0,79,117,116,112,117,116,32
	DB 102,105,108,101,110,97,109,101,63,32
	DB 0,119,0,79,112,101,110,32,102,97
	DB 105,108,117,114,101,33,0,73,110,112
	DB 117,116,32,102,105,108,101,110,97,109
	DB 101,63,32,0,114,0,79,112,101,110
	DB 32,102,97,105,108,117,114,101,0,109
	DB 105,115,115,105,110,103,32,99,108,111
	DB 115,105,110,103,32,98,114,97,99,107
	DB 101,116,0,32,101,114,114,111,114,115
	DB 32,105,110,32,99,111,109,112,105,108
	DB 97,116,105,111,110,46,0,48,0,114
	DB 0,79,112,101,110,32,102,97,105,108
	DB 117,114,101,32,111,110,32,105,110,99
	DB 108,117,100,101,32,102,105,108,101,0
	DB 105,108,108,101,103,97,108,32,115,121
	DB 109,98,111,108,32,110,97,109,101,0
	DB 97,108,114,101,97,100,121,32,100,101
	DB 102,105,110,101,100,0,109,105,115,115
	DB 105,110,103,32,98,114,97,99,107,101
	DB 116,0,109,117,115,116,32,98,101,32
	DB 108,118,97,108,117,101,0,79,117,116
	DB 112,117,116,32,102,105,108,101,32,101
	DB 114,114,111,114,0,42,42,42,42,42
	DB 42,32,32,0,32,32,42,42,42,42
	DB 42,42,0,83,109,97,108,108,45,99
	DB 32,67,111,109,112,105,108,101,114,32
	DB 114,101,118,32,49,46,49,32,114,101
	DB 58,78,65,83,77,32,99,48,46,49
	DB 46,53,32,65,117,103,32,50,48,48
	DB 56,0,91,77,65,80,32,65,76,76
	DB 32,83,67,67,78,46,77,65,80,93
	DB 0,83,69,67,84,73,79,78,32,46
	DB 116,101,120,116,32,118,115,116,97,114
	DB 116,61,48,49,48,48,104,0,45,61
	DB 32,69,78,68,32,61,45,0,77,79
	DB 86,32,32,65,76,44,91,0,93,0
	DB 67,66,87,0,77,79,86,32,32,65
	DB 88,44,91,0,93,0,65,68,68,32
	DB 32,65,88,44,83,80,0,77,79,86
	DB 32,32,91,0,93,44,65,76,0,77
	DB 79,86,32,32,91,0,93,44,65,88
	DB 0,77,79,86,32,32,91,66,88,93
	DB 44,65,76,0,77,79,86,32,32,91
	DB 66,88,93,44,65,88,0,77,79,86
	DB 32,32,66,88,44,65,88,0,77,79
	DB 86,32,32,65,76,44,91,66,121,116
	DB 101,32,66,88,93,0,67,66,87,0
	DB 77,79,86,32,32,66,88,44,65,88
	DB 0,77,79,86,32,32,65,88,44,91
	DB 66,88,93,0,88,67,72,71,32,65
	DB 88,44,66,88,0,77,79,86,32,32
	DB 65,88,44,0,80,85,83,72,32,65
	DB 88,0,80,85,83,72,32,48,0,80
	DB 79,80,32,32,66,88,0,88,67,72
	DB 71,32,91,83,80,93,44,65,88,0
	DB 67,65,76,76,32,0,82,69,84,0
	DB 36,43,53,0,67,65,76,76,32,91
	DB 65,88,93,0,74,77,80,32,32,0
	DB 67,77,80,32,32,65,88,44,48,0
	DB 74,78,69,32,32,36,43,53,0,74
	DB 77,80,32,32,0,59,45,59,32,83
	DB 69,67,84,73,79,78,32,46,100,115
	DB 101,103,32,97,108,105,103,110,61,49
	DB 54,32,59,59,32,99,111,109,109,101
	DB 110,116,101,100,32,111,117,116,32,102
	DB 111,114,32,46,99,111,109,32,118,101
	DB 114,115,105,111,110,0,68,66,32,0
	DB 84,73,77,69,83,32,0,68,87,32
	DB 0,65,68,68,32,32,83,80,44,0
	DB 68,69,67,32,32,83,80,0,80,85
	DB 83,72,32,65,88,0,65,68,68,32
	DB 32,65,88,44,83,80,0,77,79,86
	DB 32,32,83,80,44,65,88,0,65,68
	DB 68,32,32,65,88,44,65,88,0,65
	DB 68,68,32,32,65,88,44,66,88,0
	DB 83,85,66,32,32,66,88,44,65,88
	DB 0,77,79,86,32,32,65,88,44,66
	DB 88,0,77,85,76,32,32,66,88,0
	DB 88,67,72,71,32,65,88,44,66,88
	DB 0,77,79,86,32,32,68,88,44,48
	DB 0,68,73,86,32,32,66,88,0,77
	DB 79,86,32,32,66,88,44,68,88,0
	DB 88,67,72,71,32,65,88,44,66,88
	DB 0,67,87,68,0,73,68,73,86,32
	DB 66,88,0,77,79,86,32,32,66,88
	DB 44,68,88,0,79,82,32,32,32,65
	DB 88,44,66,88,0,88,79,82,32,32
	DB 65,88,44,66,88,0,65,78,68,32
	DB 32,65,88,44,66,88,0,77,79,86
	DB 32,32,67,76,44,65,76,0,77,79
	DB 86,32,32,65,88,44,66,88,0,83
	DB 65,82,32,32,65,88,44,67,76,0
	DB 77,79,86,32,32,67,76,44,65,76
	DB 0,77,79,86,32,32,65,88,44,66
	DB 88,0,83,65,76,32,32,65,88,44
	DB 67,76,0,78,69,71,32,32,65,88
	DB 0,78,79,84,32,32,65,88,0,73
	DB 78,67,32,32,65,88,0,68,69,67
	DB 32,32,65,88,0,67,77,80,32,32
	DB 66,88,44,65,88,0,77,79,86,32
	DB 32,65,88,44,49,0,74,90,32,32
	DB 32,36,43,53,0,77,79,86,32,32
	DB 65,88,44,48,0,67,77,80,32,32
	DB 66,88,44,65,88,0,77,79,86,32
	DB 32,65,88,44,49,0,74,78,90,32
	DB 32,36,43,53,0,77,79,86,32,32
	DB 65,88,44,48,0,67,77,80,32,32
	DB 66,88,44,65,88,0,77,79,86,32
	DB 32,65,88,44,49,0,74,76,32,32
	DB 32,36,43,53,0,77,79,86,32,32
	DB 65,88,44,48,0,67,77,80,32,32
	DB 66,88,44,65,88,0,77,79,86,32
	DB 32,65,88,44,49,0,74,76,69,32
	DB 32,36,43,53,0,77,79,86,32,32
	DB 65,88,44,48,0,67,77,80,32,32
	DB 66,88,44,65,88,0,77,79,86,32
	DB 32,65,88,44,49,0,74,71,32,32
	DB 32,36,43,53,0,77,79,86,32,32
	DB 65,88,44,48,0,67,77,80,32,32
	DB 66,88,44,65,88,0,77,79,86,32
	DB 32,65,88,44,49,0,74,71,69,32
	DB 32,36,43,53,0,77,79,86,32,32
	DB 65,88,44,48,0,67,77,80,32,32
	DB 66,88,44,65,88,0,77,79,86,32
	DB 32,65,88,44,49,0,74,66,32,32
	DB 32,36,43,53,0,77,79,86,32,32
	DB 65,88,44,48,0,67,77,80,32,32
	DB 66,88,44,65,88,0,77,79,86,32
	DB 32,65,88,44,49,0,74,66,69,32
	DB 32,36,43,53,0,77,79,86,32,32
	DB 65,88,44,48,0,67,77,80,32,32
	DB 66,88,44,65,88,0,77,79,86,32
	DB 32,65,88,44,49,0,74,65,32,32
	DB 32,36,43,53,0,77,79,86,32,32
	DB 65,88,44,48,0,67,77,80,32,32
	DB 66,88,44,65,88,0,77,79,86,32
	DB 32,65,88,44,49,0,74,65,69,32
	DB 32,36,43,53,0,77,79,86,32,32
	DB 65,88,44,48,0,45,61,32,83,116
	DB 114,105,110,103,32,109,97,120,101,100
	DB 32,101,114,114,111,114,32,61,45,36
	DB 0,78,111,32,65,118,97,105,108,97
	DB 98,108,101,32,73,79,68,36,0,102
	DB 111,112,101,110,32,83,84,65,84,69
	DB 95,69,82,32,101,114,114,111,114,46
	DB 36,0,67,67,66,32,70,105,108,101
	DB 32,66,117,102,102,101,114,32,97,115
	DB 115,105,103,110,101,100,46,36,0,102
	DB 111,112,101,110,32,114,101,115,117,108
	DB 116,32,114,101,112,111,114,116,115,32
	DB 110,111,116,32,110,117,108,108,46,36
	DB 0,102,111,112,101,110,32,114,101,115
	DB 117,108,116,32,114,101,112,111,114,116
	DB 115,32,110,117,108,108,46,36,0,70
	DB 105,108,101,32,78,111,116,32,70,111
	DB 117,110,100,32,102,111,114,32,114,101
	DB 97,100,105,110,103,44,32,69,114,114
	DB 111,114,46,46,36,0,70,105,108,101
	DB 32,70,111,117,110,100,32,97,110,100
	DB 32,79,112,101,110,101,100,32,102,111
	DB 114,32,82,101,97,100,105,110,103,46
	DB 36,0,70,105,108,101,32,78,111,116
	DB 32,70,111,117,110,100,32,102,111,114
	DB 32,119,114,105,116,105,110,103,44,32
	DB 67,114,101,97,116,105,110,103,46,46
	DB 36,0,32,45,70,105,108,101,32,67
	DB 114,101,97,116,101,100,32,102,111,114
	DB 32,87,114,105,116,105,110,103,45,32
	DB 36,0,32,45,77,97,106,111,114,32
	DB 70,77,79,68,69,32,101,114,114,111
	DB 114,45,32,36,0,102,99,108,111,115
	DB 101,32,114,101,115,117,108,116,32,114
	DB 101,112,111,114,116,115,32,110,117,108
	DB 108,44,32,115,117,99,99,101,115,115
	DB 46,36,0,102,99,108,111,115,101,32
	DB 114,101,115,117,108,116,32,114,101,112
	DB 111,114,116,115,32,110,111,116,32,110
	DB 117,108,108,44,32,102,97,105,108,46
	DB 36,0,79,83,95,102,99,32,114,101
	DB 115,117,108,116,32,114,101,112,111,114
	DB 116,115,32,110,117,108,108,44,32,115
	DB 117,99,99,101,115,115,46,36,0,79
	DB 83,95,102,99,32,114,101,115,117,108
	DB 116,32,114,101,112,111,114,116,115,32
	DB 110,111,110,45,110,117,108,108,44,32
	DB 101,114,114,111,114,46,36,0,70,105
	DB 108,101,32,77,111,100,101,32,69,114
	DB 114,111,114,44,32,110,111,116,32,111
	DB 112,101,110,101,100,32,102,111,114,32
	DB 82,101,97,100,105,110,103,36,0,45
	DB 61,32,69,110,100,32,111,102,32,70
	DB 105,108,101,32,82,101,97,99,104,101
	DB 100,32,61,45,32,36,0,83,84,68
	DB 73,78,32,32,32,73,79,66,0,83
	DB 84,68,79,85,84,32,32,73,79,66
	DB 0,83,84,68,69,82,82,32,32,73
	DB 79,66,0,73,78,70,73,76,69,32
	DB 32,84,88,84,0,79,85,84,70,73
	DB 76,69,32,84,88,84,0,84,69,77
	DB 80,32,32,32,32,84,88,84,0,114
	DB 0,119,0,119,0,110,0,110,0,110
	DB 0
	;-; SECTION .dseg align=16 ;; commented out for .com version
symtab:	TIMES 5760	DB 	0
glbptr:	TIMES 1	DW 	0
locptr:	TIMES 1	DW 	0
wq:	TIMES 100	DW 	0
wqptr:	TIMES 1	DW 	0
litq:	TIMES 4000	DB 	0
litptr:	TIMES 1	DW 	0
macq:	TIMES 2176	DB 	0
macptr:	TIMES 1	DW 	0
line:	TIMES 80	DB 	0
mline:	TIMES 80	DB 	0
lptr:	TIMES 1	DW 	0
mptr:	TIMES 1	DW 	0
nxtlab:	TIMES 1	DW 	0
litlab:	TIMES 1	DW 	0
c_sp:	TIMES 1	DW 	0
argstk:	TIMES 1	DW 	0
ncmp:	TIMES 1	DW 	0
errcnt:	TIMES 1	DW 	0
eof:	TIMES 1	DW 	0
input:	TIMES 1	DW 	0
output:	TIMES 1	DW 	0
input2:	TIMES 1	DW 	0
glbflag:	TIMES 1	DW 	0
ctext:	TIMES 1	DW 	0
cmode:	TIMES 1	DW 	0
lastst:	TIMES 1	DW 	0
quote:	TIMES 2	DB 	0
cptr:	TIMES 1	DW 	0
iptr:	TIMES 1	DW 	0
_iod:	TIMES 6	DW 	0
f_unit0:	TIMES 1	DB 	0
fdd_01:	TIMES 171	DB 	0
f_unit1:	TIMES 1	DB 	0
fdd_02:	TIMES 171	DB 	0
f_unit2:	TIMES 1	DB 	0
fdd_03:	TIMES 171	DB 	0
f_unit3:	TIMES 1	DB 	0
fdd_04:	TIMES 171	DB 	0
f_unit4:	TIMES 1	DB 	0
fdd_05:	TIMES 171	DB 	0
f_unit5:	TIMES 1	DB 	0
fdd_06:	TIMES 171	DB 	0
fdta:	TIMES 128	DB 	0
tbuff:	TIMES 257	DB 	0
ubuff:	TIMES 257	DB 	0
cp:	TIMES 0	DW 	0

;0 errors in compilation.
;	-= END =-
</pre>
</code>
<P>
<H5>
11:50 AM 8/16/2008
</H5>
</p>
</html>

<!-- www.000webhost.com Analytics Code -->
<script type="text/javascript" src="http://analytics.hosting24.com/count.php"></script>
<noscript><a href="http://www.hosting24.com/"><img src="http://analytics.hosting24.com/count.php" alt="web hosting" /></a></noscript>
<!-- End Of Analytics Code -->
